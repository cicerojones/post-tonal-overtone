* setting-up
Each tutorial assumes you are starting up cold. While actually doing
so may seem an inconvenience (why would you ever want to leave
emacs??), it actuall is a good practice, akin to a conceptual and
code spring-cleaning.
** steps
Once you have followed the below steps:

1.

#+BEGIN_SRC bash
cd ~/git-projects/post_tonal_overtone
lein repl
#+END_SRC

or ~cider-jack-in~ from within the post_tonal_overtone
directory within emacs

2. 

evaluate (C-c C-k using CIDER) the post_tonal_definitions.clj file 

You will hopefully see overtone loading up in your cider-repl.

** considerations
*** printing to standard out
One advantage to starting a lein repl and then connecting cider to it
(with cider-connect) is that the terminal window (which becomes
dedicated to the overtone server once overtone is loaded) seems happy
to ~println~ things that cider-repl doesn't. 

For example see this function from an earlier section.
#+BEGIN_SRC clojure :results output
(defn voice-and-transpose-rand-set [set-type tn-level]
  (let [set (rand-nth set-type)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
	visible-pairings (map #(list % (mod % 12)) voiced-set)
        transposed-set (map #(+ tn-level %) voiced-set)
	paired-transposed-set (map #(list (mod % 12) (+ tn-level %)) (sort voiced-set))
        set-voicing-group (list :set set
                                :tn-level tn-level
				:reg visible-pairings
                                :sorted-trans paired-transposed-set)]
    (do
      (println set-voicing-group)
      #_set-voicing-group transposed-set)))

(voice-and-transpose-rand-set trichords 3)

;; (voice-and-transpose-rand-set set-class/trichords 3)
#+END_SRC

#+RESULTS:
: (:set (0 4 8) :tn-level 3 :reg ((36 0) (76 4) (80 8)) :sorted-trans ((0 39) (4 79) (8 83)))



Also, note that whether you start cider from within the /src directory
or the project directory will make a difference. Use the top-level
project directory, with the project.clj file.

*** idiomatic usage
What's the best way to set-up and define functions? For example the
above function is perhaps a little on the large side, and appears to
be doing a lot in the span of its one let form. Additionally, the
function as it is written is called with two arguments--is there
another way to do this that would present any relative advantages?
* loading namespaces and using the relevant vars 
** repl vs. babel
Again, there's more than one way to do this. You can choose to have
babel-blocks do the loading, but in this case the repl will remain
ignorant of what has been taking place (this hasn't always seemed to
be the case when working with both. But for whatever I have done, it
always seems to be the case now).

Maybe name a session to help learn about how babel and cider will
interact around namespaces

#+BEGIN_SRC clojure :session vle
 (in-ns 'post_tonal_overtone.core)
#+END_SRC

#+RESULTS:
: #<Namespace post_tonal_overtone.core>

#+BEGIN_SRC clojure :session vle
*ns*
#+END_SRC

#+RESULTS:
: #<Namespace user>

#+BEGIN_SRC clojure
*ns*
#+END_SRC

#+RESULTS:
: #<Namespace post_tonal_overtone.core>
** see what's available
*** resources that have been loaded in the background
Do you have access to certain data structures you are going to want to
use? If not, how do you load these things?

A "cheap" way is just to go to a file that contains such a ~def~
statement and evaluate it right there
#+BEGIN_SRC clojure :session vle
cmajtriads
#+END_SRC

#+RESULTS:
| 48 | 52 | 55 |
| 48 | 52 | 67 |
| 48 | 52 | 79 |
| 48 | 64 | 55 |
| 48 | 64 | 67 |
| 48 | 64 | 79 |
| 48 | 76 | 55 |
| 48 | 76 | 67 |
| 48 | 76 | 79 |
| 60 | 52 | 55 |
| 60 | 52 | 67 |
| 60 | 52 | 79 |
| 60 | 64 | 55 |
| 60 | 64 | 67 |
| 60 | 64 | 79 |
| 60 | 76 | 55 |
| 60 | 76 | 67 |
| 60 | 76 | 79 |
| 72 | 52 | 55 |
| 72 | 52 | 67 |
| 72 | 52 | 79 |
| 72 | 64 | 55 |
| 72 | 64 | 67 |
| 72 | 64 | 79 |
| 72 | 76 | 55 |
| 72 | 76 | 67 |
| 72 | 76 | 79 |

#+BEGIN_SRC clojure :session vle
set-class/cmajtriads
#+END_SRC



#+RESULTS:
| 48 | 52 | 55 |
| 48 | 52 | 67 |
| 48 | 52 | 79 |
| 48 | 64 | 55 |
| 48 | 64 | 67 |
| 48 | 64 | 79 |
| 48 | 76 | 55 |
| 48 | 76 | 67 |
| 48 | 76 | 79 |
| 60 | 52 | 55 |
| 60 | 52 | 67 |
| 60 | 52 | 79 |
| 60 | 64 | 55 |
| 60 | 64 | 67 |
| 60 | 64 | 79 |
| 60 | 76 | 55 |
| 60 | 76 | 67 |
| 60 | 76 | 79 |
| 72 | 52 | 55 |
| 72 | 52 | 67 |
| 72 | 52 | 79 |
| 72 | 64 | 55 |
| 72 | 64 | 67 |
| 72 | 64 | 79 |
| 72 | 76 | 55 |
| 72 | 76 | 67 |
| 72 | 76 | 79 |

*** background libraries
What about libraries of functions that you might want to use? What
kind of namespace-qualification are you going to have to use? Will you
need to ~use~ anything directly?

#+BEGIN_SRC clojure :session vle
(finite-prob/certainly 11)
#+END_SRC

#+RESULTS:
| 11 | 1 |

Take a look at some of the vars defined in other namespaces. Do you
know what they are, or how to use them? 

How far should you go with trying to document what you're using?
Personally, I like to err on the side of overly comprehensive, which
working with emacs and org-mode makes possible and not excessively
distracting.

#+BEGIN_SRC clojure :results output
(dir post_tonal_overtone.probability_functions.finite-distributions)
#+END_SRC

#+RESULTS:
#+begin_example
bernoulli
binomial
certainly
choose
cond-dist-m
cond-prob
dist-m
join-with
make-distribution
normalize
normalize-cond
prob
select
uniform
zipf
#+end_example

Note, during all this loading and checking, you may have received
mysterious errors. Have you checked your REPL lately? There may be
subtle spelling or procedural mistakes that you have made which you
will want to "debug" from the sometimes obscure error messages you
receive.

* check basic sounds and levels
This is akin to what happens at live shows, where the musician's and
sound engineers do "sound checks" (or really "line checks," in the
case of just making sure everything is working).
** sin wave
*** basic
#+BEGIN_SRC clojure :session vle
(demo (sin-osc))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: user/audition-synth 41>
*** louder
#+BEGIN_SRC clojure :session vle
(demo  (out 0 (* 2 (sin-osc))))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: user/audition-synth 42>

** white noise

#+BEGIN_SRC clojure :session vle
(demo (white-noise))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: user/audition-synth 43>
** loaded samples
*** piano
#+BEGIN_SRC clojure :session vle
(sampled-piano)
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: overtone.inst.973/sampled-piano 45>

#+BEGIN_SRC clojure :session vle
(sampled-piano (note :A4))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: overtone.inst.973/sampled-piano 46>
* construct meaningful musical units
In all the tutorials so far we have used the =doseq= function. Here it
is again, taken out of context and with some imagined function body
after the initial binding form.
** all-important idiom for playing a chord
#+BEGIN_SRC clojure
  (doseq [note a-chord] ;;pseudocode (player-function note))
#+END_SRC
*** simple middle C triad
So begin to note how the =doseq= function does what it does, which is
especially useful to us when we are interested in doing something
repetitive like playing all the notes in a chord.

#+BEGIN_SRC clojure :session vle
(defn play-piano-chord [a-chord]
        (doseq [note a-chord] (sampled-piano note)))

(play-piano-chord [60 64 67])
#+END_SRC

  #+RESULTS:
  : #'user/play-piano-chordnil
*** randomly voice an A7 flat9 sharp13, play chord as side-effect
So, with that reminder of how we can tidily play chords, we can now
look a little more deeply at some techniques for accessing and
rendering chords as built in to overtone.

**** 4 note voicings using built-in overtone functionality
     :PROPERTIES:
     :Freq_ALL: 1
     :END:
In the last tutorial, I spent most of my time dealing with the kinds
of harmonies that characterize post-tonal music. Overtone, however,
has ample support for the harmonic organization that typifies tonal
music, that is the chords and scales of Western (and some non-Western)
music. 

Without going into too much of a digression on the sometimes
overly-casual distinctions between tonal, post-tonal and "centric"
music, let's just look at (and listen to) a quick cool bit of
functionality.

#+BEGIN_SRC clojure :session vle :results output
;; overtone.live/rand-chord
;; ([root chord-name num-pitches pitch-range])
;;   Generates a random list of MIDI notes with cardinality num-pitches
;;   bound within the range of the specified root and pitch-range and
;;   only containing pitches within the specified chord-name. Similar to
;;   Impromptu's pc:make-chord

(defn mod12 [n] (mod n 12))

(let [midis (rand-chord :A2 :7+5-9 4 48)]
(do (println (map find-note-name midis))
    (println midis)
    (println (map mod12 midis))
    (play-piano-chord midis)
  ))
#+END_SRC

#+RESULTS:
: (:F3 :Bb3 :A4 :C#5)
: (53 58 69 73)
: (5 10 9 1)

Overtone supplies a rich set of built-in keyword args for dealing with
a system of naming chords that is common to jazz and 20th century
popular music: a mix of names and Arabic numberal, with a few odd
other symbols thrown in there.

Consulting the overtone documentation for chord only gives a small
picture of what actually is available when we crack open the overtone
=pitch.clj= source file.

#+BEGIN_SRC clojure :results output
(source chord)
#+END_SRC

#+RESULTS:
#+begin_example
(defn chord
  "Returns a set of notes for the specified chord. The root must be in
  midi note format i.e. :C4.

  (chord :c4 :major)  ; c major           -> #{60 64 67}
  (chord :a4 :minor)  ; a minor           -> #{57 60 64}
  (chord :Bb4 :dim)   ; b flat diminished -> #{70 73 76}
  "
  ([root chord-name]
   (chord root chord-name 0))
  ([root chord-name inversion]
     (let [root (note root)
           chord (resolve-chord chord-name)
           notes (map #(+ % root) chord)]
       (invert-chord notes inversion))))
#+end_example

**** pitch.clj source
  #+BEGIN_SRC clojure :session vle
(ns ^{:doc "Functions to help generate and manipulate frequencies and
    sets of related frequencies. This is the place for functions
    representing general musical knowledge, like scales, chords,
    intervals, etc."
      :author "Jeff Rose, Sam Aaron & Marius Kempe"}
  overtone.music.pitch
  (:use [overtone.helpers old-contrib]
        [overtone.helpers.map :only [reverse-get]]
        [overtone.algo chance])
  (:require [clojure.string :as string]))

;; Notes in a typical scale are related by small, prime number ratios. Of all
;; possible 7 note scales, the major scale has the highest number of consonant
;; intervals.

(defmacro defratio [rname ratio]
  `(defn ~rname [freq#] (* freq# ~ratio)))

; Perfect consonance
(defratio unison    1/1)
(defratio octave    2/1)
(defratio fifth     3/2)

; Imperfect consonance
(defratio sixth     5/3)
(defratio third     5/4)

; Dissonance
(defratio fourth    4/3)
(defratio min-third 6/5)
(defratio min-sixth 8/5)

(defn cents
  "Returns a frequency computed by adding n-cents to freq.  A cent is
  a logarithmic measurement of pitch, where 1-octave equals 1200
  cents."
  [freq n-cents]
  (* freq (java.lang.Math/pow 2 (/ n-cents 1200))))

;; MIDI
(def MIDI-RANGE (range 128))
(def MIDDLE-C 60)

;; Manipulating pitch using midi note numbers

(defn shift
  "Shift the 'notes' in 'phrase' by a given 'amount' of half-steps."
  [phrase notes amount]
  (if notes
    (let [note (first notes)
          shifted (+ (get phrase note) amount)]
      (recur (assoc phrase note shifted) (next notes) amount))
    phrase))

(defn flat
  "Flatten the specified notes in the phrase."
  [phrase notes]
  (shift phrase notes -1))

(defn sharp
  "Sharpen the specified notes in the phrase."
  [phrase notes]
  (shift phrase notes +1))

(defn invert
  "Invert a sequence of notes using either the first note as the
  stationary pivot point or the optional second argument."
  [notes & [pivot]]
  (let [pivot (or pivot (first notes))]
    (for [n notes] (- pivot (- n pivot)))))

(defn octave-note
  "Convert an octave and interval to a midi note."
  [octave interval]
  (+ (* octave 12) interval 12))

(def NOTES {:C  0  :c  0  :b# 0  :B# 0
            :C# 1  :c# 1  :Db 1  :db 1  :DB 1  :dB 1
            :D  2  :d  2
            :D# 3  :d# 3  :Eb 3  :eb 3  :EB 3  :eB 3
            :E  4  :e  4
            :E# 5  :e# 5  :F  5  :f  5
            :F# 6  :f# 6  :Gb 6  :gb 6  :GB 6  :gB 6
            :G  7  :g  7
            :G# 8  :g# 8  :Ab 8  :ab 8  :AB 8  :aB 8
            :A  9  :a  9
            :A# 10 :a# 10 :Bb 10 :bb 10 :BB 10 :bB 10
            :B  11 :b  11 :Cb 11 :cb 11 :CB 11 :cB 11})

(def REVERSE-NOTES
  {0 :C
   1 :C#
   2 :D
   3 :Eb
   4 :E
   5 :F
   6 :F#
   7 :G
   8 :Ab
   9 :A
   10 :Bb
   11 :B})

(defn canonical-pitch-class-name
  "Returns the canonical version of the specified pitch class pc."
  [pc]
  (let [pc (keyword (name pc))]
      (REVERSE-NOTES (NOTES pc))))

(def MIDI-NOTE-RE-STR "([a-gA-G][#bB]?)([-0-9]+)" )
(def MIDI-NOTE-RE (re-pattern MIDI-NOTE-RE-STR))
(def ONLY-MIDI-NOTE-RE (re-pattern (str "\\A" MIDI-NOTE-RE-STR "\\Z")))

(defn- midi-string-matcher
  "Determines whether a midi keyword is valid or not. If valid,
  returns a regexp match object"
  [mk]
  (re-find ONLY-MIDI-NOTE-RE (name mk)))

(defn- validate-midi-string!
  "Throws a friendly exception if midi-keyword mk is not
  valid. Returns matches if valid."
  [mk]
  (let [matches (midi-string-matcher mk)]
    (when-not matches
      (throw (IllegalArgumentException.
              (str "Invalid midi-string. " mk
                   " does not appear to be in MIDI format i.e. C#4"))))

    (let [[match pictch-class octave] matches]
      (when (< (Integer. octave) -1)
        (throw (IllegalArgumentException.
                (str "Invalid midi-string: " mk
                     ". Octave is out of range. Lowest octave value is -1")))))
    matches))

(defn note-info
  "Takes a string representing a midi note such as C4 and returns a map
  of note info"
  [midi-string]
  (let [[match pitch-class octave] (validate-midi-string! midi-string)
        pitch-class                (canonical-pitch-class-name pitch-class)
        octave                     (Integer. octave)
        interval                   (NOTES (keyword pitch-class))]
    {:match       match
     :pitch-class pitch-class
     :octave      (Integer. octave)
     :interval    interval
     :midi-note   (octave-note octave interval)}))

(defn mk-midi-string
  "Takes a string or keyword representing a pitch and a number
  representing an integer and returns a new string which is a
  concatanation of the two. Throws an error if the resulting midi
  string is invalid.

  (midi-string :F 7)  ;=> \"F7\"
  (midi-string :Eb 3) ;=> \"Eb3\""
  [pitch-key octave]
  (let [res (str (name pitch-key) octave)]
    (validate-midi-string! res)
    res))

(defn note
  "Resolves note to MIDI number format. Resolves upper and lower-case
  keywords and strings in MIDI note format. If given an integer or
  nil, returns them unmodified. All other inputs will raise an
  exception.

  Usage examples:

  (note \"C4\")  ;=> 60
  (note \"C#4\") ;=> 61
  (note \"eb2\") ;=> 39
  (note :F#7)    ;=> 102
  (note :db5)    ;=> 73
  (note 60)      ;=> 60
  (note nil)     ;=> nil"
  [n]
  (cond
    (nil? n) nil
    (integer? n) (if (>= n 0)
                   n
                   (throw (IllegalArgumentException.
                           (str "Unable to resolve note: "
                                n
                                ". Value is out of range. Lowest value is 0"))))
    (keyword? n) (note (name n))
    (string? n) (:midi-note (note-info n))
    :else (throw (IllegalArgumentException. (str "Unable to resolve note: " n ". Wasn't a recognised format (either an integer, keyword, string or nil)")))))

(defn match-note
  "Returns the first midi-note formatted substring in s. If passed
   optional prev and pos strings will use them to generate positive
   look ahead and behind matchers. "
  ([s] (match-note s "" ""))
  ([s prev-str post-str]
     (let [look-behind (if prev-str (str "(?<=" prev-str ")") "")
           look-ahead  (if post-str (str "(?=" post-str ")") "")
           match       (re-find (re-pattern (str look-behind MIDI-NOTE-RE-STR look-ahead)) s)]
       (when match
         (let [[match pitch-class octave] match]
           (note-info match))))))



;; * Each note in a scale acts as either a generator or a collector of other notes,
;; depending on their relations in time within a sequence.
;;  - How can this concept be developed into parameterized sequences with knobs for
;;  adjusting things like tension, dissonance, swing, genre (latin, asian, arabic...)
;;  - Can we develop a symbol language or visual representation so that someone could compose
;;  a piece by using mood tokens rather than specifying scales and notes directly?  Basically,
;;  generator functions would have to choose the scales, chords, notes and rhythm based on
;;  a mix of looking up aspects of the mood, and informed randomness.

;; Use a note (:C scale) or (:Eb scale)

;;  You may be interested to know that each of the seven degrees of the diatonic scale has its own name:
;;
;; 1 (do)  tonic
;; 2 (re)  supertonic
;; 3 (mi)  mediant
;; 4 (fa)  subdominant
;; 5 (sol) dominant
;; 6 (la)  submediant/superdominant
;; 7 (ti)  subtonic"


;; Various scale intervals in terms of steps on a piano, or midi note numbers
;; All sequences should add up to 12 - the number of semitones in an octave

(def SCALE
  (let [ionian-sequence     [2 2 1 2 2 2 1]
        hex-sequence        [2 2 1 2 2 3]
        pentatonic-sequence [3 2 2 3 2]
        rotate (fn [scale-sequence offset]
                 (take (count scale-sequence)
                       (drop offset (cycle scale-sequence))))]
    {:diatonic           ionian-sequence
     :ionian             (rotate ionian-sequence 0)
     :major              (rotate ionian-sequence 0)
     :dorian             (rotate ionian-sequence 1)
     :phrygian           (rotate ionian-sequence 2)
     :lydian             (rotate ionian-sequence 3)
     :mixolydian         (rotate ionian-sequence 4)
     :aeolian            (rotate ionian-sequence 5)
     :minor              (rotate ionian-sequence 5)
     :locrian            (rotate ionian-sequence 6)
     :hex-major6         (rotate hex-sequence 0)
     :hex-dorian         (rotate hex-sequence 1)
     :hex-phrygian       (rotate hex-sequence 2)
     :hex-major7         (rotate hex-sequence 3)
     :hex-sus            (rotate hex-sequence 4)
     :hex-aeolian        (rotate hex-sequence 5)
     :minor-pentatonic   (rotate pentatonic-sequence 0)
     :yu                 (rotate pentatonic-sequence 0)
     :major-pentatonic   (rotate pentatonic-sequence 1)
     :gong               (rotate pentatonic-sequence 1)
     :egyptian           (rotate pentatonic-sequence 2)
     :shang              (rotate pentatonic-sequence 2)
     :jiao               (rotate pentatonic-sequence 3)
     :pentatonic         (rotate pentatonic-sequence 4) ;; historical match
     :zhi                (rotate pentatonic-sequence 4)
     :ritusen            (rotate pentatonic-sequence 4)
     :whole-tone         [2 2 2 2 2 2]
     :whole              [2 2 2 2 2 2]
     :chromatic          [1 1 1 1 1 1 1 1 1 1 1 1]
     :harmonic-minor     [2 1 2 2 1 3 1]
     :melodic-minor-asc  [2 1 2 2 2 2 1]
     :hungarian-minor    [2 1 3 1 1 3 1]
     :octatonic          [2 1 2 1 2 1 2 1]
     :messiaen1          [2 2 2 2 2 2]
     :messiaen2          [1 2 1 2 1 2 1 2]
     :messiaen3          [2 1 1 2 1 1 2 1 1]
     :messiaen4          [1 1 3 1 1 1 3 1]
     :messiaen5          [1 4 1 1 4 1]
     :messiaen6          [2 2 1 1 2 2 1 1]
     :messiaen7          [1 1 1 2 1 1 1 1 2 1]
     :super-locrian      [1 2 1 2 2 2 2]
     :hirajoshi          [2 1 4 1 4]
     :kumoi              [2 1 4 2 3]
     :neapolitan-major   [1 2 2 2 2 2 1]
     :bartok             [2 2 1 2 1 2 2]
     :bhairav            [1 3 1 2 1 3 1]
     :locrian-major      [2 2 1 1 2 2 2]
     :ahirbhairav        [1 3 1 2 2 1 2]
     :enigmatic          [1 3 2 2 2 1 1]
     :neapolitan-minor   [1 2 2 2 1 3 1]
     :pelog              [1 2 4 1 4]
     :augmented2         [1 3 1 3 1 3]
     :scriabin           [1 3 3 2 3]
     :harmonic-major     [2 2 1 2 1 3 1]
     :melodic-minor-desc [2 1 2 2 1 2 2]
     :romanian-minor     [2 1 3 1 2 1 2]
     :hindu              [2 2 1 2 1 2 2]
     :iwato              [1 4 1 4 2]
     :melodic-minor      [2 1 2 2 2 2 1]
     :diminished2        [2 1 2 1 2 1 2 1]
     :marva              [1 3 2 1 2 2 1]
     :melodic-major      [2 2 1 2 1 2 2]
     :indian             [4 1 2 3 2]
     :spanish            [1 3 1 2 1 2 2]
     :prometheus         [2 2 2 5 1]
     :diminished         [1 2 1 2 1 2 1 2]
     :todi               [1 2 3 1 1 3 1]
     :leading-whole      [2 2 2 2 2 1 1]
     :augmented          [3 1 3 1 3 1]
     :purvi              [1 3 2 1 1 3 1]
     :chinese            [4 2 1 4 1]
     :lydian-minor       [2 2 2 1 1 2 2]}))

(defn resolve-scale
  "Either looks the scale up in the map of SCALEs if it's a keyword or
  simply returns it unnmodified. Allows users to specify a scale
  either as a seq such as [2 2 1 2 2 2 1] or by keyword such
  as :aeolian"
  [scale]
  (if (keyword? scale)
    (SCALE scale)
    scale))

(defn scale-field
  "Create the note field for a given scale.  Scales are specified with
  a keyword representing the key and an optional scale
  name (defaulting to :major):
  (scale-field :g)
  (scale-field :g :minor)"
  [skey & [sname]]
  (let [base (NOTES skey)
        sname (or sname :major)
        intervals (SCALE sname)]
    (reverse (next
      (reduce (fn [mem interval]
              (let [new-note (+ (first mem) interval)]
                (conj mem new-note)))
            (list base)
            (take (* 8 12) (cycle intervals)))))))

(defn nth-interval
  "Return the count of semitones for the nth degree from the start of
  the diatonic scale in the specific mode (or ionian/major by
  default).

  i.e. the ionian/major scale has an interval sequence of 2 2 1 2 2 2
       1 therefore the 4th degree is (+ 2 2 1 2) semitones from the
       start of the scale."
  ([n] (nth-interval :diatonic n))
  ([scale n]
     (reduce + (take n (cycle (scale SCALE))))))

(def DEGREE {:i     1
             :ii    2
             :iii   3
             :iv    4
             :v     5
             :vi    6
             :vii   7
             :_     nil})

(defn degree->int
  [degree]
  (if (some #{degree} (keys DEGREE))
    (degree DEGREE)
    (throw (IllegalArgumentException. (str "Unable to resolve degree: " degree ". Was expecting a roman numeral in the range :i -> :vii or the nil-note symbol :_")))))

(defn resolve-degree
  "returns a map representing the degree, and the octave semitone
  shift (i.e. sharp flat)"
  ([degree] (resolve-degree degree 0 0))
  ([degree octave-shift semitone-shift]
     (cond
      (.endsWith (name degree) "-")
      (resolve-degree (keyword (chop (name degree))) (dec octave-shift) semitone-shift)

      (.endsWith (name degree) "+")
      (resolve-degree (keyword (chop (name degree))) (inc octave-shift) semitone-shift)

      (.endsWith (name degree) "b")
      (resolve-degree (keyword (chop (name degree))) octave-shift (dec semitone-shift))

      (.endsWith (name degree) "#")
      (resolve-degree (keyword (chop (name degree))) octave-shift (inc semitone-shift))

      :default
      (let [degree (degree->int degree)]
        {:degree degree
         :octave-shift octave-shift
         :semitone-shift semitone-shift}))))

(defn degree->interval
  "Converts the degree of a scale given as a roman numeral keyword and
  converts it to the number of semitones from the tonic of
  the specified scale.

  (degree->interval :ii :major) ;=> 2

  Trailing #, b, + - represent sharps, flats, octaves up and down
  respectively.  An arbitrary number may be added in any order."
  [degree scale]
  (cond
    (nil? degree) nil
    (= :_ degree) nil

    (number? degree) (nth-interval scale (dec degree))

    (keyword? degree) (let [degree     (resolve-degree degree)
                            interval   (nth-interval scale (dec (:degree degree)))
                            oct-shift  (* 12 (:octave-shift degree))
                            semi-shift (:semitone-shift degree)]
                        (+ interval oct-shift semi-shift))))

(defn degrees->pitches
  "Convert intervals to pitches in MIDI number format.  Supports
  nested collections."
  [degrees scale root]
  (let [root (note root)]
    (when (nil? root)
      (throw (IllegalArgumentException. (str "root resolved to a nil value. degrees->pitches requires a non-nil root."))))
    (map (fn [degree]
           (cond
            (coll? degree) (degrees->pitches degree scale root)
            (nil? degree) nil
            :default (if-let [interval (degree->interval degree scale)]
                       (+ root interval))))
         degrees)))

(defn resolve-degrees
  "Either maps the degrees to integers if they're keywords using the map DEGREE
  or leaves them unmodified"
  [degrees]
  (map #(if (keyword? %) (DEGREE %) %) degrees))

(defn scale
  "Returns a list of notes for the specified scale. The root must be
   in midi note format i.e. :C4 or :Bb4


   (scale :c4 :major)  ; c major      -> (60 62 64 65 67 69 71 72)
   (scale :Bb4 :minor) ; b flat minor -> (70 72 73 75 77 78 80 82)"

  ([root scale-name] (scale root scale-name (range 1 8)))
  ([root scale-name degrees]
     (let [root (note root)
           degrees (resolve-degrees degrees)]
       (cons root (map #(+ root (nth-interval scale-name %)) degrees)))))

(def CHORD
  (let [major  #{0 4 7}
        minor  #{0 3 7}
        major7 #{0 4 7 11}
        dom7   #{0 4 7 10}
        minor7 #{0 3 7 10}
        aug    #{0 4 8}
        dim    #{0 3 6}
        dim7   #{0 3 6 9}]
    {:1         #{0}
     :5         #{0 7}
     :+5        #{0 4 8}
     :m+5       #{0 3 8}
     :sus2      #{0 2 7}
     :sus4      #{0 5 7}
     :6         #{0 4 7 9}
     :m6        #{0 3 7 9}
     :7sus2     #{0 2 7 10}
     :7sus4     #{0 5 7 10}
     :7-5       #{0 4 6 10}
     :m7-5      #{0 3 6 10}
     :7+5       #{0 4 8 10}
     :m7+5      #{0 3 8 10}
     :9         #{0 4 7 10 14}
     :m9        #{0 3 7 10 14}
     :m7+9      #{0 3 7 10 14}
     :maj9      #{0 4 7 11 14}
     :9sus4     #{0 5 7 10 14}
     :6*9       #{0 4 7 9 14}
     :m6*9      #{0 3 9 7 14}
     :7-9       #{0 4 7 10 13}
     :m7-9      #{0 3 7 10 13}
     :7-10      #{0 4 7 10 15}
     :9+5       #{0 10 13}
     :m9+5      #{0 10 14}
     :7+5-9     #{0 4 8 10 13}
     :m7+5-9    #{0 3 8 10 13}
     :11        #{0 4 7 10 14 17}
     :m11       #{0 3 7 10 14 17}
     :maj11     #{0 4 7 11 14 17}
     :11+       #{0 4 7 10 14 18}
     :m11+      #{0 3 7 10 14 18}
     :13        #{0 4 7 10 14 17 21}
     :m13       #{0 3 7 10 14 17 21}
     :major      major
     :M          major
     :minor      minor
     :m          minor
     :major7     major7
     :dom7       dom7
     :7          dom7
     :M7         major7
     :minor7     minor7
     :m7         minor7
     :augmented  aug
     :a          aug
     :diminished dim
     :dim        dim
     :i          dim
     :diminished7 dim7
     :dim7       dim7
     :i7         dim7}))

(defn resolve-chord
  "Either looks the chord up in the map of CHORDs if it's a keyword or
  simply returns it unnmodified. Allows users to specify a chord
  either with a set such as #{0 4 7} or by keyword such as :major"
  [chord]
  (if (keyword? chord)
    (CHORD chord)
    chord))

(defn- inc-first
  "Remove the first element, increment it by n, and append to seq."
  [elems n]
  (concat (next elems) [(+ n (first elems))]))

(defn- dec-last
  "Remove the last element, decrement it by n, and prepend to seq."
  [elems n]
  (concat [(- (last elems) n)] (next elems)))

(defn invert-chord
  "Move a chord voicing up or down.

    ;first inversion
    (invert-chord [60 64 67] 1) ;=> (64 67 72)

    ; second inversion
    (invert-chord [60 64 67] 1) ;=> (67 72 76)
  "
  [notes shift]
  (cond
    (pos? shift) (recur (inc-first notes 12) (dec shift))
    (neg? shift) (recur (dec-last notes 12) (inc shift))
    (zero? shift) notes))

(defn chord
  "Returns a set of notes for the specified chord. The root must be in
  midi note format i.e. :C4.

  (chord :c4 :major)  ; c major           -> #{60 64 67}
  (chord :a4 :minor)  ; a minor           -> #{57 60 64}
  (chord :Bb4 :dim)   ; b flat diminished -> #{70 73 76}
  "
  ([root chord-name]
   (chord root chord-name 0))
  ([root chord-name inversion]
     (let [root (note root)
           chord (resolve-chord chord-name)
           notes (map #(+ % root) chord)]
       (invert-chord notes inversion))))

(defn rand-chord
  "Generates a random list of MIDI notes with cardinality num-pitches
  bound within the range of the specified root and pitch-range and
  only containing pitches within the specified chord-name. Similar to
  Impromptu's pc:make-chord"
  [root chord-name num-pitches pitch-range]
  (let [chord (chord root chord-name)
        root (note root)
        max-pitch (+ pitch-range root)
        roots (range 0 max-pitch 12)
        notes (flatten (map (fn [root] (map #(+ root %) chord)) roots))
        notes (take-while #(<= % max-pitch) notes)]
    (sort (choose-n num-pitches notes))))

; midicps
(defn midi->hz
  "Convert a midi note number to a frequency in hz."
  [note]
  (* 440.0 (java.lang.Math/pow 2.0 (/ (- note 69.0) 12.0))))

; cpsmidi
(defn hz->midi
  "Convert from a frequency to the nearest midi note number."
  [freq]
  (java.lang.Math/round (+ 69
                 (* 12
                    (/ (java.lang.Math/log (* freq 0.0022727272727))
                       (java.lang.Math/log 2))))))

; ampdb
(defn amp->db
  "Convert linear amplitude to decibels."
  [amp]
  (* 20 (java.lang.Math/log10 amp)))

; dbamp
(defn db->amp
  "Convert decibels to linear amplitude."
  [db]
  (java.lang.Math/exp (* (/ db 20) (java.lang.Math/log 10))))

(defn nth-octave
  "Returns the freq n octaves from the supplied reference freq

   i.e. (nth-ocatve 440 1) will return 880 which is the freq of the
   next octave from 440."
  [freq n]
  (* freq (java.lang.Math/pow 2 n)))

(defn nth-equal-tempered-freq
  "Returns the frequency of a given scale interval using an
  equal-tempered tuning i.e. dividing all 12 semi-tones equally across
  an octave. This is currently the standard tuning."
  [base-freq interval]
  (* base-freq (java.lang.Math/pow 2 (/ interval 12))))

(defn interval-freq
  "Returns the frequency of the given interval using the specified
  mode and tuning (defaulting to ionian and equal-tempered
  respectively)."
  ([base-freq n] (interval-freq base-freq n :ionian :equal-tempered))
  ([base-freq n mode tuning]
     (case tuning
           :equal-tempered (nth-equal-tempered-freq base-freq (nth-interval n mode)))))

(defn find-scale-name
  "Return the name of the first matching scale found in SCALE
  or nil if not found

  ie: (find-scale-name [2 1 2 2 2 2 1]
  :melodic-minor-asc"
  [scale]
  (reverse-get SCALE scale))

(defn find-pitch-class-name
  "Given a midi number representing a note, returns the name of the note
  independent of octave.

  (find-pitch-class-name 62) ;=> :D
  (find-pitch-class-name 74) ;=> :D
  (find-pitch-class-name 75) ;=> :Eb"
  [note]
  (REVERSE-NOTES (mod note 12)))

(defn find-note-name
  [note]
  "Given a midi number representing a note, returns a keyword
  representing the note including octave number. Reverse of the fn note.

  (find-note-name 45) ;=> A2
  (find-note-name 57) ;=> A3
  (find-note-name 58) ;=> Bb3"
  (when note (let [octave (dec (int (/ note 12)))]
               (keyword (str (name (find-pitch-class-name note)) octave)))))

(defn- fold-note
  "Folds note intervals into a 2 octave range so that chords using
  notes spread across multiple octaves can be correctly recognised."
  [note]
  (if (or (< 21 note) (contains? #{20 19 16 12} note))
    (fold-note (- note 12))
     note ))

(defn- simplify-chord
  "Expects notes to contain 0 (the root note) Reduces all notes into 2
  octaves. This will allow identification of fancy jazz chords, but
  will miss some simple chords if they are spread over more than 1
  octave."
  [notes]
  (set (map (fn [x] (fold-note x)) notes)))

(defn- compress-chord
  "Expects notes to contain 0 (the root note) Reduces all notes into 1
  octave. This will lose all the fancy jazz chords but recognise
  sparse multiple octave simple chords"
  [notes]
  (set (map (fn [x] (mod x 12)) notes)))

(defn- select-root
  "Adds a new root note below the lowest note present in notes"
  [notes root-index]
  (if (< 0 root-index)
    (let [new-root (nth (seq (sort notes)) root-index)
         lowest-note (first (sort notes))
         octaves (+ 1 (quot (- new-root lowest-note) 12))]
      (set (cons (- new-root (* octaves 12)) notes)))
    notes))

(defn- find-chord-with-low-root
  "Finds the chord represented by notes
   Assumes the root note is the lowest note in notes
   notes can be spread over multiple octaves"
  [notes]
  (if (< 0 (count notes))
    (let [root (first (sort notes))
          adjusted-notes (set (map (fn [x] (- x root)) notes ))]
      (or (reverse-get CHORD (simplify-chord adjusted-notes))
          (reverse-get CHORD (compress-chord adjusted-notes))))))

(defn find-chord
  [notes]
  (loop [note 0]
    (if (< note (count notes) )
      (let [mod-notes (select-root notes note)
            chord  (find-chord-with-low-root mod-notes)
            root (find-pitch-class-name (first (sort mod-notes)))]
       (if chord
         {:root root :chord-type chord}
         (recur (inc note))))
      nil)))


(defn chord-degree
  "Returns the notes constructed by picking thirds in a given scale
  from in a given root. Useful if you want to try out playing standard
  chord progressions. For example:

  (chord-degree :i :c4 :ionian) ;=> (60 64 67 71)
  (chord-degree :ii :c4 :melodic-minor-asc) ;=> (62 65 69 72)
  "
  ([degree root mode]
    (chord-degree degree root mode 4))
  ([degree root mode num-notes]
    (let [d-int (degree->int degree)
          num-degrees (- (+ d-int (* num-notes 2)) 1)]
          (take-nth 2 (drop (degree->int degree) (scale root mode (range num-degrees)))))))

;; * shufflers (randomize a sequence, or notes within a scale, etc.)
;; *
;;* Sequence generators
;; - probabilistic arpeggiator
;; - take a rhythym seq, note seq, and groove seq
;; - latin sounds
;; - house sounds
;; - minimal techno sounds
;; - drum and bass sounds
;;
;;* create a library of sequence modifiers and harmonizers

;;; ideas:

;;; represent all notes with midi numbers
;;; represent sequences of notes (i.e. scales) with vectors/lists
;;; represent sequences of durations with vectors/lists
;;; [1 3 5 7]
;;; represent chords with sets
;;; #{1 3 5}
;;
;;[1 3 5 #{1 4 5} 7]
;;[1 1 2     6    3]


;; chromatic notes -> 0-11
;; degrees -> i -> vii

;; chord - concrete: (60 64 67)
;; chord - concrete - chromatic notes: (4 7 12)


;; chord - abstract - chromatic notes: (0 4 7)
;; chord - abstract - chromatic notes: (0 4 7)
;; chord - abstract - degrees: (i iii v)

  #+END_SRC

** remember meaningful phenomena
While randomly generating material can be great fun, sometimes you
strike on something you really like, or you desire to start building
up something more permament and substantial. 
*** write 6 note voicing to disk
Let's use another version of the block from the last section. In this
case, however, we have added a function that will write out data to a
file on disk.

#+BEGIN_SRC clojure :session vle :results output
;; Note, we use the mod12 function defined in the last block

(let [midis (rand-chord :A2 :7+5-9 6 48)]
  (play-piano-chord midis)
  (do (println (map find-note-name midis))
      (println midis)
      (println (map mod12 midis))
      (spit "src/post_tonal_overtone/data/saved-voicings.clj"
            (pr-str midis) :append true)
  ))
#+END_SRC

#+RESULTS:
: (:Bb3 :C#4 :A4 :F5 :G5 :A5)
: (58 61 69 77 79 81)
: (10 1 9 5 7 9)

Reading and writing to disk gets rather quickly into some deep and
critical stuff about using programming languages to accomplish things
that will persist. We can think a little about this now, but will
largely skirt the issue until later.

*** stateful versions (?)
So the reasons for keeping track of what you have done should be
clear. For example, you might think "This generated chord was
particularly attractive. Wouldn't it be nice to keep track of such
things? And to revist and try out sequences of these things? And then
be able to vary their order? And articulate them differently? Or
subsume them within some larger structure that begins to emerge after
using a bunch of them?"

(Or at least, that's what I think!)

By capturing our work in emacs and org-mode, we can get a limited sort
of persistence, but presents some problems when we think about
convenience, usability and maintainability.

For example, how do you cycle between these two things?


#+BEGIN_SRC clojure
(play-piano-chord '(57 58 65 67 79 85))
;; (play-piano-chord '(53 57 58 65 79 81))
#+END_SRC

#+RESULTS:
: nil

Well, we will need to take advantage of some of Clojure's capabilities
for doing "stateful" things, which may require some kind of swap-ping
or dereferencing of a stateful thing. Huh?

*** using an atom and swap to derefence and set a new value
An atom is one of Clojure's techniques for managing "stateful things,"
that is, named "objects" that store or refer to some kind of value.
This can all be rather abstract. Let's look at an example

#+BEGIN_SRC clojure
;; [[__ 57 58 65 67 79 __ 85]
;;  [53 57 58 65 __ 79 81]]
(def a (atom (vec (take 100 (cycle [[57 58 65 67 79 85]
                                    [53 57 58 65 79 81]])))))
#+END_SRC

#+RESULTS:
: #'user/a

#+BEGIN_SRC clojure
(first (swap! a rest))
#+END_SRC

#+RESULTS:
| 57 | 58 | 65 | 67 | 79 | 85 |

#+BEGIN_SRC clojure
(play-piano-chord (first (swap! a rest)))
#+END_SRC  

#+RESULTS:
: nil

Most interstingly, let's re-use a bit of that function from above that
prints out some details about our notes.

#+BEGIN_SRC clojure :results output
(let [midis (first (swap! a rest))]
(do (println (map find-note-name midis))
    (println midis)
    (println (map mod12 midis))
    (println (count @a))
    (play-piano-chord midis)
  ))
#+END_SRC

#+RESULTS:
: (:A3 :Bb3 :F4 :G4 :G5 :C#6)
: [57 58 65 67 79 85]
: (9 10 5 7 7 1)
: 90

*** let's make a cycle with a few more things
If we can alternate between two things in this fashion, if might be
fun to proceed through between a longer sequence of such things

#+BEGIN_SRC clojure
(def b (atom (vec (take 100 (cycle '((53 55 58 61 77 85)(57 58 65 67 79 85)(45 55 61 65 67 70)(45 61 65 67 70 77)))))))
#+END_SRC

#+RESULTS:
: #'user/b

Now we work through a series of 4 different voicings of this
interesting chord>

#+BEGIN_SRC clojure :results output
(let [midis (first (swap! b rest))]
(do (println (map find-note-name midis))
    (println midis)
    (println (map mod12 midis))
    (println (count @b))
    (play-piano-chord midis)
  ))
#+END_SRC

#+RESULTS:
: (:A2 :G3 :C#4 :F4 :G4 :Bb4)
: (45 55 61 65 67 70)
: (9 7 1 5 7 10)
: 94

#+BEGIN_SRC clojure :session getting-started :tangle yes 
(definst saw1 [freq 330 attack 0.3 sustain 0.15 release 0.25 vol 0.2 length 5]
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (saw freq)
     vol))

(saw1)
#+END_SRC

#+RESULTS:
: #<instrument: saw1>#<synth-node[loading]: user/saw1 152>

#+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn play-chord-saw1 [a-chord]
  (doseq [note a-chord] (saw1 (midi->hz note))))
#+END_SRC

#+RESULTS:
: #'user/play-chord-saw1

And now let's read it from another source
#+BEGIN_SRC clojure :results output
(let [midis (first (swap! b rest))]
(do (println (map find-note-name midis))
    (println midis)
    (println (map mod12 midis))
    (println (count @b))
    (play-chord-saw1 midis)
  ))
#+END_SRC

#+RESULTS:
: (:A2 :C#4 :F4 :G4 :Bb4 :F5)
: (45 61 65 67 70 77)
: (9 1 5 7 10 5)
: 89

*** working with stateful objects without atom management
You CAN do this, but whether you should is another matter. Or rather
an exact understanding of why you should or shouldn't and how to do it
if you do is what ultimately is most important (and involves ~atoms~,
as above).

For now, however, let's see how this works, in contrast to using
~atoms~.

#+BEGIN_SRC clojure :session vle :results output
(def stateful-chord (rand-chord :A2 :7+5-9 6 48))

(let [midis stateful-chord]
  (play-piano-chord midis)
  (do (println (map find-note-name midis))
  (println midis)
  (println (map mod12 midis)
    )))
#+END_SRC

#+RESULTS:
: (:F3 :G3 :A3 :F5 :G5 :A5)
: (53 55 57 77 79 81)
: (5 7 9 5 7 9)

See it here again:

#+BEGIN_SRC clojure
(let [midis stateful-chord]
  (play-piano-chord midis))

stateful-chord
#+END_SRC

#+RESULTS:
: nil(53 55 57 77 79 81)

#+BEGIN_SRC clojure
stateful-chord
#+END_SRC

#+RESULTS:
| 53 | 55 | 57 | 77 | 79 | 81 |

What's the harm in constantly generating new values for this
"stateful-chord" thing? Perhaps the simplest thing to say is that it
prevents us from learning how to work through Clojure's existing
mechanisms that have been finely-wrought for navigating the complexity
that is potentially involved.

*** reading from and writing to disk
Now, as above, we might be interested enough in what we have generated
to save it to disk.

#+BEGIN_SRC clojure
(spit "src/post_tonal_overtone/data/fave-voicings.clj"
      (pr-str stateful-chord) :append true)
#+END_SRC

#+RESULTS:
: nil

Which is great, but how do we most conveniently get it back? Reading
it from disk in the following manner doesn't quite work the way you
would want.

#+BEGIN_SRC clojure
(read-string (slurp "src/post_tonal_overtone/data/fave-voicings.clj"))
#+END_SRC

#+RESULTS:
| 53 | 55 | 58 | 61 | 77 | 85 |

It's great that we getting the first thing we saved to that file, but
there's more there!

(In emacs, on my local system, I can confirm this by visiting the following:

And C-c C-o to see that the file contains the last "stateful chord"
[[file:~/git-projects/post_tonal_overtone/src/post_tonal_overtone/data/fave-voicings.clj]]
*** we want to read-write with streams instead
To start getting into more sophisticated ways of persisting data, we
may need to delve into one of the things that makes Clojure unique:
it's ability to use the underlying mechanisms of the JVM to work with
the local system.

(note some of this is derived from section [[file:~/git/org/clojure-books.org::*4.9.%20Reading%20and%20Writing%20Text%20Files][4.9. Reading and Writing
Text Files]] in the Clojure Cookbook)

 #+BEGIN_SRC clojure
(with-open [w (clojure.java.io/writer "stuff.txt")]
  (doseq [line some-large-seq-of-strings]
    (.write w line)
    (.newLine w)))
 #+END_SRC



*** with-open and java file writing interop
In order to delve deeply, we need to understand how to build up a
little larger piece of java interop
 #+BEGIN_SRC clojure
;; "src/post_tonal_overtone/transposed-data.clj"

;;  /Users/a/git-projects/post_tonal_overtone/src/post_tonal_overtone/data:

 (require '[clojure.java.io :as io])

(defn append-to [f text]
  (with-open [w (io/writer f :append true)]
    (doto w (.write text) .flush)))


 #+END_SRC

 #+RESULTS:
 : nil#'post_tonal_overtone.core/append-to

=Append-to= is our little wrapper around writing some kind of text to a file that
we pass in as an argument. 
 #+BEGIN_SRC clojure
(append-to "src/post_tonal_overtone/data/short-test.clj" " still more text with spaces ")
 #+END_SRC

 #+RESULTS:
 : #<BufferedWriter java.io.BufferedWriter@1f28c0ea>


 #+BEGIN_SRC clojure
(slurp "src/post_tonal_overtone/data/short-test.clj")
 #+END_SRC

 #+RESULTS:
 : [:a :b :c]this is textthis is more text still more text with spaces 

While this is nice for proving that we can take arbitrary output from
our programs and store them in a file, we still have to deal with easy
ways of accessing that stuff.

For example, using read-string on the =slurp=-ing that we just did
still leaves the same problem of getting back more than the first
thing.
 #+BEGIN_SRC clojure
(read-string (slurp "src/post_tonal_overtone/data/short-test.clj"))

 #+END_SRC

 #+RESULTS:
 | :a | :b | :c |

What would be nice would be to cycle through the contents of some file
in a piecemeal fashion. What we are bumping into here is a
 /sine qua non/ of programming, which is getting information from a
database.

We'll think more deeply about this soon enough.

*** developing an understanding of state
One of the main issues in all the above is when there are other
"clients" interacting with the data we have stored to some "object" or
"location." Or what about if you wanted to keep that object available
in clojure and not just on disk somehow, i.e. how should it persist?

And what if you wanted to keep that thing around when using clojure
and wanted it to contain an ever expanding list of your favorite
chords?

Why, then you would be interested in an honest-to-goodness database!

This whole other can of worms is described in an in-progress tutorial
on using Clojure to store info using SQL.

** playing a melody involves time idioms
We've seen a little before about how to get sound to happen with
overtone at a particular time.
*** start simply with 'this' moment
#+BEGIN_SRC clojure :session vle
(at (now) (play-piano-chord (chord :C4 :major)))
#+END_SRC

#+RESULTS:
: nil


Or now, set-off by 1000 milliseconds.

#+BEGIN_SRC clojure :session vle
(at (+ 1000 (now)) (play-piano-chord (chord :C4 :major)))
#+END_SRC

#+RESULTS:
: nil

*** using a metronome as timer for more sequenced items
However, we rarely want to schedule just a single event.
**** copied standard example
Here's a version of a common example to demonstrate scheduling several
events.

  #+BEGIN_SRC clojure
;; We can play a chord progression on the synth
;; using times:
(defn chord-progression-time []
  (let [time (now)]
    (at time (play-piano-chord (chord :C4 :major)))
    (at (+ 2000 time) (play-piano-chord (chord :G3 :major)))
    (at (+ 3000 time) (play-piano-chord (chord :F3 :sus4)))
    (at (+ 4300 time) (play-piano-chord (chord :F3 :major)))
    (at (+ 5000 time) (play-piano-chord (chord :G3 :major)))))

(chord-progression-time)

  #+END_SRC

  #+RESULTS:
  : #'user/chord-progression-timenil
**** cleaned up standard modified with other chord qualities
But once we get how this works, we can recognize that it is rather
brittle (not to mention that the chord progression does not especially
reflect the impetus behind this tutorial, which is to think about how
to make music in a post-tonal style. 

Let's try out some of the other common chord types overtone makes
available. Additionally we'll take the wise step of removing the
hard-coded times at which the events should start.

  #+BEGIN_SRC clojure
;; you will now be able to assign play-times relative to the start
;; time, by passing in a list of "on-times" in milliseconds
(defn my-chord-progression-time [times]
  (let [time (now)
        [time1 time2 time3 time4 time5] times]
    (at time (play-piano-chord (chord :C4 :dom7)))
    (at (+ time1 time) (play-piano-chord (chord :G3 :major7)))
    (at (+ time2 time) (play-piano-chord (chord :F3 :sus4)))
    (at (+ time3 time) (play-piano-chord (chord :F3 :sus2)))
    (at (+ time4 time) (play-piano-chord (chord :G3 :minor7)))
    (at (+ time5 time) (play-piano-chord (chord :C3 :dim)))))



  #+END_SRC

  #+RESULTS:
  : #'user/my-chord-progression-time

#+BEGIN_SRC clojure
(my-chord-progression-time '(2000 4000 6000 9000 13000 15000))
#+END_SRC

#+RESULTS:
: nil

*** defined ~play~ doesn't have an example in the documentation
Let's look at another example of making a function that will play
things for us in time.

**** as defined, will play a sequence separated by a specified millisecond amount
This version has been slightly modified to use the sampled-piano instrument

Whereas other timing functions we have used were motivated by the
desire to play chords, here we can demonstrate another kind of common
musical phenomenon: the arpeggio, which is basically just a chord
played spread out over the course of brief span of time.

#+BEGIN_SRC clojure :session vle
(defn play [time notes sep]
  (let [note (first notes)]
    (when note
      (at time (sampled-piano note)))
    (let [next-time (+ time sep)]
      (apply-at next-time play [next-time (rest notes) sep]))))
#+END_SRC

#+RESULTS:
: #'user/play

#+BEGIN_SRC clojure :session vle
(play (now) [60 64 71] 200)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 1, created-at: Thu 07:07:50s, initial-delay: 199, desc: "Overtone delayed fn", scheduled? true>

: #<ScheduledJob id: 1, created-at: Thu 06:28:00s, initial-delay: 198, desc: "Overtone delayed fn", scheduled? true>

**** nice: provide a large list as an argument and get out a long sequence of notes
#+BEGIN_SRC clojure
(recording-start "/Users/a/Google Drive/wav-file-uploads/arps1.wav")
#+END_SRC

#+RESULTS:
: :recording-started

#+BEGIN_SRC clojure :session vle
(play (now) (flatten cmajtriads) 100)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 331450, created-at: Thu 10:45:18s, initial-delay: 99, desc: "Overtone delayed fn", scheduled? true>



#+RESULTS:
: :recording-started

#+BEGIN_SRC clojure
(recording-stop)
#+END_SRC

#+RESULTS:
: /Users/a/Google Drive/wav-file-uploads/arps1.wav

#+BEGIN_SRC clojure :session vle
(play (now) (flatten set-class/cmajtriads) 100)
#+END_SRC

#+RESULTS:


#+RESULTS:
: /Users/a/Google Drive/wav-file-uploads/arps1.wav



: #<ScheduledJob id: 45, created-at: Sat 01:46:34s, initial-delay: 99, desc: "Overtone delayed fn", scheduled? true>


: #<ScheduledJob id: 4401268, created-at: Wed 04:48:49s, initial-delay: 200, desc: "Overtone delayed fn", scheduled? true>

**** modified (fails?)
Why do you need to pass in the time it starts? Any reason that
shouldn't be now? Wouldn't be more useful to be able to vary what
instrument you want to be playing? Here's a version that add an
instrument function.

#+BEGIN_SRC clojure :session vle
(defn my-play [inst notes sep]
  (let [note (first notes)
        time (now)]
    (when note
      (at time (inst note)))
    (let [next-time (+ time sep)]
      (apply-at next-time my-play [inst (rest notes) sep]))))
#+END_SRC

#+RESULTS:
: #'user/my-play

#+BEGIN_SRC clojure :session vle
(my-play sampled-piano [60 64 67] 2000)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 1440, created-at: Thu 07:09:30s, initial-delay: 1998, desc: "Overtone delayed fn", scheduled? true>

**** modify to play with random intervals between notes (fails to reapply)
This naive attempt to get different rhythms reveals that there is some
misconception in how =apply-at= works. We'll have to deal with this
question of different rhythms in the next major section.

#+BEGIN_SRC clojure :session vle
(defn new-play [time notes seps]
  (let [note (first notes)
        sep (rand-nth seps)]
    (when note
      (at time (sampled-piano note))
      (println sep))
    (let [next-time (+ time (rand-nth seps))]
      (apply-at next-time play [next-time (rest notes) (rand-nth seps)]))))
#+END_SRC

#+RESULTS:
: #'user/new-play

#+BEGIN_SRC clojure
(new-play (now) (flatten cmajtriads) [100 1000])
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 1695, created-at: Thu 07:09:46s, initial-delay: 98, desc: "Overtone delayed fn", scheduled? true>

#+BEGIN_SRC clojure :session vle
(new-play (now) (flatten set-class/cmajtriads) [100 1000])
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 4637, created-at: Sat 01:51:36s, initial-delay: 998, desc: "Overtone delayed fn", scheduled? true>

* generate large databases of musical events
Once we start playing these long sequences of some related chords, it
becomes apparent that there are some obvious ways that extend this and
make it more musically interesting.
** transpose triply nested list
Thus begins the task of working with other structures taken from files
saved to disk.
#+BEGIN_SRC clojure :session vle
(defn tn-colls [tn coll-of-colls]
  (map (fn [coll] (map #(+ tn %) coll)) coll-of-colls))
#+END_SRC

#+RESULTS:
: #'user/tn-colls

#+BEGIN_SRC clojure :session vle
(first nested-transposed-tetrachords)
#+END_SRC

#+RESULTS:
| 11 | 12 | 13 | 14 |
| 10 | 11 | 12 | 13 |
|  9 | 10 | 11 | 12 |
|  8 |  9 | 10 | 11 |
|  7 |  8 |  9 | 10 |
|  6 |  7 |  8 |  9 |
|  5 |  6 |  7 |  8 |
|  4 |  5 |  6 |  7 |
|  3 |  4 |  5 |  6 |
|  2 |  3 |  4 |  5 |
|  1 |  2 |  3 |  4 |

#+BEGIN_SRC clojure :session vle
(first set-class/nested-transposed-tetrachords)
#+END_SRC

#+RESULTS:
| 11 | 12 | 13 | 14 |
| 10 | 11 | 12 | 13 |
|  9 | 10 | 11 | 12 |
|  8 |  9 | 10 | 11 |
|  7 |  8 |  9 | 10 |
|  6 |  7 |  8 |  9 |
|  5 |  6 |  7 |  8 |
|  4 |  5 |  6 |  7 |
|  3 |  4 |  5 |  6 |
|  2 |  3 |  4 |  5 |
|  1 |  2 |  3 |  4 |

#+BEGIN_SRC clojure :session vle
(tn-colls 60 (first nested-transposed-tetrachords))

;; (tn-colls 60 (first set-class/nested-transposed-tetrachords))
#+END_SRC

#+RESULTS:
| 71 | 72 | 73 | 74 |
| 70 | 71 | 72 | 73 |
| 69 | 70 | 71 | 72 |
| 68 | 69 | 70 | 71 |
| 67 | 68 | 69 | 70 |
| 66 | 67 | 68 | 69 |
| 65 | 66 | 67 | 68 |
| 64 | 65 | 66 | 67 |
| 63 | 64 | 65 | 66 |
| 62 | 63 | 64 | 65 |
| 61 | 62 | 63 | 64 |


#+BEGIN_SRC clojure :session vle
(subvec (vec nested-transposed-tetrachords) 0 2)
;; (subvec (vec set-class/nested-transposed-tetrachords) 0 2)
#+END_SRC

#+RESULTS:
| (11 12 13 14) | (10 11 12 13) | (9 10 11 12) | (8 9 10 11) | (7 8 9 10) | (6 7 8 9)  | (5 6 7 8) | (4 5 6 7) | (3 4 5 6) | (2 3 4 5) | (1 2 3 4) |
| (11 12 13 15) | (10 11 12 14) | (9 10 11 13) | (8 9 10 12) | (7 8 9 11) | (6 7 8 10) | (5 6 7 9) | (4 5 6 8) | (3 4 5 7) | (2 3 4 6) | (1 2 3 5) |

#+BEGIN_SRC clojure :session vle
((fn [cococ] (map #(tn-colls 60 %) cococ)) (subvec (vec nested-transposed-tetrachords) 0 3))
;; ((fn [cococ] (map #(tn-colls 60 %) cococ)) (subvec (vec set-class/nested-transposed-tetrachords) 0 3))
#+END_SRC

#+RESULTS:
| (71 72 73 74) | (70 71 72 73) | (69 70 71 72) | (68 69 70 71) | (67 68 69 70) | (66 67 68 69) | (65 66 67 68) | (64 65 66 67) | (63 64 65 66) | (62 63 64 65) | (61 62 63 64) |
| (71 72 73 75) | (70 71 72 74) | (69 70 71 73) | (68 69 70 72) | (67 68 69 71) | (66 67 68 70) | (65 66 67 69) | (64 65 66 68) | (63 64 65 67) | (62 63 64 66) | (61 62 63 65) |
| (71 72 74 75) | (70 71 73 74) | (69 70 72 73) | (68 69 71 72) | (67 68 70 71) | (66 67 69 70) | (65 66 68 69) | (64 65 67 68) | (63 64 66 67) | (62 63 65 66) | (61 62 64 65) |
** start working with keyworded maps instead of unadorned lists
*** basic uses of hashes (sets)
#+BEGIN_SRC clojure :session vle
#{:a '(1 2 3) :b '(12 13 14)}
#+END_SRC

#+RESULTS:
: #{(12 13 14) (1 2 3) :b :a}

#+BEGIN_SRC clojure :session vle
(type #{:a '(1 2 3) :b '(12 13 14)})
#+END_SRC

#+RESULTS:
: clojure.lang.PersistentHashSet
** note names vs. midi numbers--note vs. find-note-name
#+BEGIN_SRC clojure :session vle
(note :A4)
#+END_SRC

#+RESULTS:
: 69

#+BEGIN_SRC clojure :session vle
(find-note-name 21)
#+END_SRC

#+RESULTS:
: :A0

#+BEGIN_SRC clojure :session vle
(note-info "C#5")
#+END_SRC

#+RESULTS:
: '(:match "C#5"  :pitch-class :C#  :octave 5  :interval 1  :midi-note 73)
* data
#+BEGIN_SRC clojure
(def cmajtriads '((48 52 55) (48 52 67) (48 52 79) (48 64 55) (48 64 67) (48 64 79) (48 76 55) (48 76 67) (48 76 79) (60 52 55) (60 52 67) (60 52 79) (60 64 55) (60 64 67) (60 64 79) (60 76 55) (60 76 67) (60 76 79) (72 52 55) (72 52 67) (72 52 79) (72 64 55) (72 64 67) (72 64 79) (72 76 55) (72 76 67) (72 76 79)))
(def nested-transposed-tetrachords '(((11 12 13 14) (10 11 12 13) (9 10 11 12) (8 9 10 11) (7 8 9 10) (6 7 8 9) (5 6 7 8) (4 5 6 7) (3 4 5 6) (2 3 4 5) (1 2 3 4)) ((11 12 13 15) (10 11 12 14) (9 10 11 13) (8 9 10 12) (7 8 9 11) (6 7 8 10) (5 6 7 9) (4 5 6 8) (3 4 5 7) (2 3 4 6) (1 2 3 5)) ((11 12 14 15) (10 11 13 14) (9 10 12 13) (8 9 11 12) (7 8 10 11) (6 7 9 10) (5 6 8 9) (4 5 7 8) (3 4 6 7) (2 3 5 6) (1 2 4 5)) ((11 12 13 16) (10 11 12 15) (9 10 11 14) (8 9 10 13) (7 8 9 12) (6 7 8 11) (5 6 7 10) (4 5 6 9) (3 4 5 8) (2 3 4 7) (1 2 3 6)) ((11 12 13 17) (10 11 12 16) (9 10 11 15) (8 9 10 14) (7 8 9 13) (6 7 8 12) (5 6 7 11) (4 5 6 10) (3 4 5 9) (2 3 4 8) (1 2 3 7)) ((11 12 13 18) (10 11 12 17) (9 10 11 16) (8 9 10 15) (7 8 9 14) (6 7 8 13) (5 6 7 12) (4 5 6 11) (3 4 5 10) (2 3 4 9) (1 2 3 8)) ((11 12 15 16) (10 11 14 15) (9 10 13 14) (8 9 12 13) (7 8 11 12) (6 7 10 11) (5 6 9 10) (4 5 8 9) (3 4 7 8) (2 3 6 7) (1 2 5 6)) ((11 12 16 17) (10 11 15 16) (9 10 14 15) (8 9 13 14) (7 8 12 13) (6 7 11 12) (5 6 10 11) (4 5 9 10) (3 4 8 9) (2 3 7 8) (1 2 6 7)) ((11 12 17 18) (10 11 16 17) (9 10 15 16) (8 9 14 15) (7 8 13 14) (6 7 12 13) (5 6 11 12) (4 5 10 11) (3 4 9 10) (2 3 8 9) (1 2 7 8)) ((11 13 14 16) (10 12 13 15) (9 11 12 14) (8 10 11 13) (7 9 10 12) (6 8 9 11) (5 7 8 10) (4 6 7 9) (3 5 6 8) (2 4 5 7) (1 3 4 6)) ((11 12 14 16) (10 11 13 15) (9 10 12 14) (8 9 11 13) (7 8 10 12) (6 7 9 11) (5 6 8 10) (4 5 7 9) (3 4 6 8) (2 3 5 7) (1 2 4 6)) ((11 13 14 17) (10 12 13 16) (9 11 12 15) (8 10 11 14) (7 9 10 13) (6 8 9 12) (5 7 8 11) (4 6 7 10) (3 5 6 9) (2 4 5 8) (1 3 4 7)) ((11 12 14 17) (10 11 13 16) (9 10 12 15) (8 9 11 14) (7 8 10 13) (6 7 9 12) (5 6 8 11) (4 5 7 10) (3 4 6 9) (2 3 5 8) (1 2 4 7)) ((11 13 14 18) (10 12 13 17) (9 11 12 16) (8 10 11 15) (7 9 10 14) (6 8 9 13) (5 7 8 12) (4 6 7 11) (3 5 6 10) (2 4 5 9) (1 3 4 8)) ((11 12 14 18) (10 11 13 17) (9 10 12 16) (8 9 11 15) (7 8 10 14) (6 7 9 13) (5 6 8 12) (4 5 7 11) (3 4 6 10) (2 3 5 9) (1 2 4 8)) ((11 12 15 17) (10 11 14 16) (9 10 13 15) (8 9 12 14) (7 8 11 13) (6 7 10 12) (5 6 9 11) (4 5 8 10) (3 4 7 9) (2 3 6 8) (1 2 5 7)) ((11 12 16 18) (10 11 15 17) (9 10 14 16) (8 9 13 15) (7 8 12 14) (6 7 11 13) (5 6 10 12) (4 5 9 11) (3 4 8 10) (2 3 7 9) (1 2 6 8)) ((11 14 15 18) (10 13 14 17) (9 12 13 16) (8 11 12 15) (7 10 11 14) (6 9 10 13) (5 8 9 12) (4 7 8 11) (3 6 7 10) (2 5 6 9) (1 4 5 8)) ((11 12 15 18) (10 11 14 17) (9 10 13 16) (8 9 12 15) (7 8 11 14) (6 7 10 13) (5 6 9 12) (4 5 8 11) (3 4 7 10) (2 3 6 9) (1 2 5 8)) ((11 12 15 19) (10 11 14 18) (9 10 13 17) (8 9 12 16) (7 8 11 15) (6 7 10 14) (5 6 9 13) (4 5 8 12) (3 4 7 11) (2 3 6 10) (1 2 5 9)) ((11 12 16 19) (10 11 15 18) (9 10 14 17) (8 9 13 16) (7 8 12 15) (6 7 11 14) (5 6 10 13) (4 5 9 12) (3 4 8 11) (2 3 7 10) (1 2 6 9)) ((11 13 15 17) (10 12 14 16) (9 11 13 15) (8 10 12 14) (7 9 11 13) (6 8 10 12) (5 7 9 11) (4 6 8 10) (3 5 7 9) (2 4 6 8) (1 3 5 7)) ((11 13 15 18) (10 12 14 17) (9 11 13 16) (8 10 12 15) (7 9 11 14) (6 8 10 13) (5 7 9 12) (4 6 8 11) (3 5 7 10) (2 4 6 9) (1 3 5 8)) ((11 13 16 18) (10 12 15 17) (9 11 14 16) (8 10 13 15) (7 9 12 14) (6 8 11 13) (5 7 10 12) (4 6 9 11) (3 5 8 10) (2 4 7 9) (1 3 6 8)) ((11 13 15 19) (10 12 14 18) (9 11 13 17) (8 10 12 16) (7 9 11 15) (6 8 10 14) (5 7 9 13) (4 6 8 12) (3 5 7 11) (2 4 6 10) (1 3 5 9)) ((11 13 17 19) (10 12 16 18) (9 11 15 17) (8 10 14 16) (7 9 13 15) (6 8 12 14) (5 7 11 13) (4 6 10 12) (3 5 9 11) (2 4 8 10) (1 3 7 9)) ((11 14 16 19) (10 13 15 18) (9 12 14 17) (8 11 13 16) (7 10 12 15) (6 9 11 14) (5 8 10 13) (4 7 9 12) (3 6 8 11) (2 5 7 10) (1 4 6 9)) ((11 13 16 19) (10 12 15 18) (9 11 14 17) (8 10 13 16) (7 9 12 15) (6 8 11 14) (5 7 10 13) (4 6 9 12) (3 5 8 11) (2 4 7 10) (1 3 6 9)) ((11 14 17 20) (10 13 16 19) (9 12 15 18) (8 11 14 17) (7 10 13 16) (6 9 12 15) (5 8 11 14) (4 7 10 13) (3 6 9 12) (2 5 8 11) (1 4 7 10))))
#+END_SRC

#+RESULTS:
: #'user/cmajtriads#'user/nested-transposed-tetrachords

