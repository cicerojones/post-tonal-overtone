* Busses
:PROPERTIES:
:ID:       BC1BF72C-E838-4484-B73D-843F0EEAF72F
:END:
#+BEGIN_SRC clojure

#+END_SRC
**   (ns overtone.examples.buses.getonthebus
#+BEGIN_SRC clojure
  (ns overtone.examples.buses.getonthebus
    (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure


  ;; Buses are like wires or pipes that you can use to connect the output
  ;; of one synth to the inputs of one or more other synths.
  ;; There are two types of buses - control buses and audio buses.

  ;; Control buses are designed to carry control signals - values changing
  ;; at a human rate (i.e. the speed you may turn a dial or slide a slider).

  ;; Audio buses are designed to carry audio signals - values changing at
  ;; a rate that makes them audible.

  ;; Audio buses can carry both audio and control rate signals. However,
  ;; they will use more computational resources. Therefore, consider using
  ;; a control bus if you're signal doesn't need to change more than, say,
  ;; 60 times a second.

  ;; You can create many new control and audio buses. However, your system
  ;; will start with one audio bus per audio input and one audio bus per audio
  ;; output. For example, your left speaker is represented by audio bus 0
  ;; and your right speaker is represented by audio bus 1

  ;; Let's create some buses to carry some control rate signals

  ;; We use the defonce construct to avoid new buses being created and
  ;; assigned accidentally, if the forms get re-evaluated.
  (defonce tri-bus (audio-bus))
  (defonce sin-bus (audio-bus))

  ;; These are synths created to send data down the buses.
  ;; They are set up so that you can modify both the bus they output on and
  ;; their frequency whilst they're running via standard ctl messages.
  ;;
  ;; Note that we use the :kr variant of the out ugen. This tells the synth
  ;; to output to a control bus rather than an audio bus which is the default.
  (defsynth tri-synth [out-bus 0 freq 5]
    (out:kr out-bus (lf-tri:kr freq)))

  (defsynth sin-synth [out-bus 0 freq 5]
    (out:kr out-bus (sin-osc:kr freq)))

  ;; Probably the most important lesson about using buses is to understand that
  ;; the execution of the synthesis on the server is strictly ordered. Running
  ;; synths are placed in a node tree which is evaluated in a depth-first order.
  ;; This is important to know because if you want synth instance A to be able to
  ;; communicate with synth instance B via a bus, A needs to be *before* B in the
  ;; synthesis node tree.

  ;; The way to gain control over the order of execution within the synthesis tree
  ;; is to use groups. Let's create some now:

  (defonce main-g (group "get-on-the-bus main"))
  (defonce early-g (group "early birds" :head main-g))
  (defonce later-g (group "latecomers" :after early-g))

  ;; Let's create some source synths that will send signals on our buses. Let's
  ;; also put them in the early group to ensure that their signals get sent first.

  (comment
    (def tri-synth-inst (tri-synth [:tail early-g] tri-bus))
    (def sin-synth-inst (sin-synth [:tail early-g] sin-bus))
    )

  ;; Notice how these synths aren't making or controlling any sound. This is because
  ;; they're control rate synths and also because their output is going to the buses
  ;; we created which aren't connected to anything. The signals are therefore ignored.

  ;; We can verify that they're running by viewing the node tree. We can do this
  ;; easily with the following fn:
  (pp-node-tree)

  ;; This will print the current synthesis node-tree to the REPL. This can get pretty
  ;; hairy and large, but if you've only evaluated this tutorial since you started
  ;; Overtone, it should be pretty manageable. You should be able to see the tri-synth
  ;; and sin-synth within the early birds group, which itself is within the
  ;; get-on-the-bus main group which itself is within the Overtone Default group.

  ;; Now, let's use these signals to make actual noise!

  ;; First, let's define a synth that we'll use to receive the signal from the bus to
  ;; make some sound:

  (defsynth modulated-vol-tri [vol-bus 0 freq 220]
    (out 0 (pan2 (* (in:kr vol-bus) (lf-tri freq)))))

  ;; Notice how this synth is using the default audio rate version of the out
  ;; ugen to output a signal to the left speaker of your computer. It is also
  ;; possible to use out:ar to achieve the same result.

  ;; This synth reads the value off the bus (at control rate)
  ;; and multiplies it with the lf-tri ugen's sample value.  The overall
  ;; result is then sent to two consecutive buses: 0 and 1. (pan2 duplicates
  ;; a single channel signal to two channels; this is documented in more detail
  ;; in some of the getting-started examples).


  ;; This synth is a little trickier.  It calculates the frequency
  ;; by taking the sample value from the bus, multipling it by
  ;; the frequency amplitude, and then adding the result to the midpoint
  ;; or median frequency.  Therefore, if you hook it up to a bus carrying
  ;; a sine wave signal and use the defalt mid-freq and freq-amp values
  ;; you'll get an lf-tri ugen that oscillates between 165 and 275 Hz
  ;; (165 is 55 below 220, and 275 is 55 above 220)
  (defsynth modulated-freq-tri [freq-bus 0 mid-freq 220 freq-amp 55]
    (let [freq (+ mid-freq (* (in:kr freq-bus) freq-amp))]
      (out 0 (pan2 (lf-tri freq)))))


  ;; One of the nifty things about buses is that you can have multiple synths reading
  ;; them from the same time.

  ;; Evaluate these to use the signals on the buses to modulate synth parameters
  (comment
    (def mvt (modulated-vol-tri [:tail later-g] sin-bus))
    (def mft (modulated-freq-tri [:tail later-g] sin-bus))
    )

  ;; Fun fact: These two examples are key features
  ;; of AM and FM radio transmitters, respectively.

  ;; Switch the bus that is modulating the frequency
  ;; to be the triangle bus.
  ;;
  (comment
    (ctl mft :freq-bus tri-bus)
    )

  ;; Change the frequency of the triangle wave on the tri-bus
  ;; This causes the modulation of the volume to happen more slowly
  (comment
    (ctl tri-synth-inst :freq 0.5)
    )

  ;; Switch the modulated-vol-tri instance to be modulated by the triangle
  ;; bus as well.
  (comment
    (ctl mvt :vol-bus tri-bus)
    )

  ;; Kill the two things that are making noise
  (comment
    (do
      (kill mft)
      (kill mvt))
    )

  ;; At this point, the buses are still carrying data from the tri-synth and sin-synth;
  ;; you'll have to kill them as well explicitly or invoke (stop) if you want them to stop.

  ;; Or can re-use them!
  (comment
    (def mvt-2 (modulated-vol-tri [:tail later-g] sin-bus 110))
    (kill mvt-2)
    )

  ;; Wacky heterodyning stuff!
  (comment
    (do
      (ctl tri-synth-inst :freq 5)
      (ctl sin-synth-inst :freq 5)
      (def mft-2 (modulated-freq-tri [:tail later-g] sin-bus 220 55))
      (def mft-3 (modulated-freq-tri [:tail later-g] tri-bus 220 55)))
    (ctl sin-synth-inst :freq 4)
    (kill mft-2 mft-3)
    )

  (comment
    "For when you're ready to stop all the things"
    (stop)
    )

#+END_SRC
* Compositions
  :PROPERTIES:
  :HEADER-ARGS: :results silent
  :END:
** (ns overtone.examples.compositions.at-all
#+BEGIN_SRC clojure
(ns overtone.examples.compositions.at-all
  (:use
    overtone.live
    [overtone.inst.sampled-piano :only [sampled-piano]]))
#+END_SRC

#+BEGIN_SRC clojure

(defn from [metro offset]
  (fn [beat] (metro (+ beat offset))))

(defn speed-up [metro factor]
  (fn [beat] (metro (/ beat factor))))

(def base 60)

(defn play-note [relative-midi]
  (-> relative-midi (+ base) sampled-piano))

(defn play-chord [chord]
  (doseq [note (vals chord)] (play-note note)))

(defn ionian [degree]
  (let [interval (mod degree 7)
        note ([0 2 4 5 7 9 11] interval)
        octave (quot (- degree interval) 7)]
    (+ (* 12 octave) note)))

(defn triad [scale root]
  (zipmap [:i :iii :v]
          [(scale root)
           (scale (+ root 2))
           (scale (+ root 4))]))

(defn lower [note] (- note 12))
(defn raise [note] (+ note 12))

(defn with-base [chord]
  (assoc chord :base
         (lower (:i chord))))

(def I (with-base (triad ionian 0)))
(def II (with-base (triad ionian 1)))
(def V (with-base (triad ionian 4)))

(def progression [I I II II II V I (update-in V [:base] lower)])

(defn rhythm-n-bass [timing [chord1 chord2 & chords]]
  (do
    (at (timing 0) (play-note (:base chord1)))
    (at (timing 2) (play-chord (dissoc chord1 :base)))
    (at (timing 3) (play-note (:base chord1)))
    (at (timing 4) (play-note (:base chord2)))
    (at (timing 6) (play-chord (dissoc chord2 :base)))
    (let [next (from timing 8)]
      (if chords
        (rhythm-n-bass next chords)
        next))))

(defn even-melody [timing [note & notes]]
  (do
    (at (timing 0) (play-note note))
    (let [next (from timing 1)]
      (if notes
        (even-melody next notes)
        next))))

(defn intro [timing]
    (even-melody timing (take 32 (cycle (map ionian [5 4]))))
    (rhythm-n-bass timing (take 8 (cycle progression))))

(defn first-bit [timing]
  (-> timing
    (from -1)
    (speed-up 2)
    (even-melody (map ionian [2 4 5 4 4 2 4]))
    (from 9)
    (even-melody (map ionian [-2 1 2 1 1 -2 1]))
    (from 9)
    (even-melody (map ionian [-2 1 2 1 1 -2 1 2 3 4]))
    (from 6)
    (even-melody (map ionian [-1 -2 -3 0 0 -3 0 1 0 -3])))
  (rhythm-n-bass timing (take 8 (cycle progression))))

(defn variation [timing]
  (-> timing
    (speed-up 2)
    (from 9)
    (even-melody (map ionian [11 11 12 9 7]))
    (from 11)
    (even-melody (map ionian [8 8 9 8 3]))
    (from 11)
    (even-melody (map ionian [8 8 9 6 4]))
    (from 11)
    (even-melody (map ionian [11 11 12 11 8])))
  (first-bit timing))

(defn final-chord [timing]
  (-> timing
    (from -1)
    (speed-up 2)
    (even-melody (map ionian [11 13 14])))
  (at (timing 0)
      (play-chord (update-in I [:i] raise))))

(defn play [] (-> (metronome 160) (from 2) intro first-bit
                 (speed-up 3/2) variation final-chord))

(play)
#+END_SRC
** 
** (nsovertone.examples.compositions.auto-dubstep
#+BEGIN_SRC clojure
(nsovertone.examples.compositions.auto-dubstep
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

;; Dan Stowells' Dubstep Synth:
;; SClang version:
;;
;;s.waitForBoot{Ndef(\a).play;Ndef(\a,
;;{
;;var trig, freq, notes, wob, sweep, kickenv, kick, snare, swr, syn, bpm, x;
;;x = MouseX.kr(1, 4);
;;
;;
;;// START HERE:
;;
;;bpm = 120;
;;
;;notes = [40, 41, 28, 28, 28, 28, 27, 25, 35, 78];
;;
;;trig = Impulse.kr(bpm/120);
;;freq = Demand.kr(trig, 0, Dxrand(notes, inf)).lag(0.25).midicps;
;;swr = Demand.kr(trig, 0, Dseq([1, 6, 6, 2, 1, 2, 4, 8, 3, 3], inf));
;;sweep = LFTri.ar(swr).exprange(40, 3000);
;;
;;
;;// Here we make the wobble bass:
;;wob = Saw.ar(freq * [0.99, 1.01]).sum;
;;wob = LPF.ar(wob, sweep);
;;wob = Normalizer.ar(wob) * 0.8;
;;wob = wob + BPF.ar(wob, 1500, 2);
;;wob = wob + GVerb.ar(wob, 9, 0.7, 0.7, mul: 0.2);
;;
;;
;;// Here we add some drums:
;;kickenv = Decay.ar(T2A.ar(Demand.kr(Impulse.kr(bpm / 30),0,Dseq([1,0,0,0,0,0,1,0, 1,0,0,1,0,0,0,0],inf))),0.7);
;;kick = SinOsc.ar(40+(kickenv*kickenv*kickenv*200),0,7*kickenv).clip2;
;;snare = 3*PinkNoise.ar(1!2)*Decay.ar(Impulse.ar(bpm / 240, 0.5),[0.4,2],[1,0.05]).sum;
;;snare = (snare + BPF.ar(4*snare,2000)).clip2;
;;
;;// This line actually outputs the sound:
;;(wob + kick + snare).clip2;
;;
;;})}
;;
;; Directly translated to Overtone:

(demo 60
      (let [bpm     120
            ;; create pool of notes as seed for random base line sequence
            notes   [40 41 28 28 28 27 25 35 78]
            ;; create an impulse trigger firing once per bar
            trig    (impulse:kr (/ bpm 120))
            ;; create frequency generator for a randomly picked note
            freq    (midicps (lag (demand trig 0 (dxrand notes INF)) 0.25))
            ;; switch note durations
            swr     (demand trig 0 (dseq [1 6 6 2 1 2 4 8 3 3] INF))
            ;; create a sweep curve for filter below
            sweep   (lin-exp (lf-tri swr) -1 1 40 3000)
            ;; create a slightly detuned stereo sawtooth oscillator
            wob     (mix (saw (* freq [0.99 1.01])))
            ;; apply low pass filter using sweep curve to control cutoff freq
            wob     (lpf wob sweep)
            ;; normalize to 80% volume
            wob     (* 0.8 (normalizer wob))
            ;; apply band pass filter with resonance at 5kHz
            wob     (+ wob (bpf wob 1500 2))
            ;; mix in 20% reverb
            wob     (+ wob (* 0.2 (g-verb wob 9 0.7 0.7)))

            ;; create impulse generator from given drum pattern
            kickenv (decay (t2a (demand (impulse:kr (/ bpm 30)) 0 (dseq [1 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0] INF))) 0.7)
            ;; use modulated sine wave oscillator
            kick    (* (* kickenv 7) (sin-osc (+ 40 (* kickenv kickenv kickenv 200))))
            ;; clip at max volume to create distortion
            kick    (clip2 kick 1)

            ;; snare is just using gated & over-amplified pink noise
            snare   (* 3 (pink-noise) (apply + (* (decay (impulse (/ bpm 240) 0.5) [0.4 2]) [1 0.05])))
            ;; send through band pass filter with peak @ 2kHz
            snare   (+ snare (bpf (* 4 snare) 2000))
            ;; also clip at max vol to distort
            snare   (clip2 snare 1)]
   ;; mixdown & clip
   (clip2 (+ wob kick snare) 1)))
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.compositions.auto-dubstep-bass
#+BEGIN_SRC clojure
(nsovertone.examples.compositions.auto-dubstep-bass
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

;;Dan Stowell's dubstep bass

;;//s.boot
;;{
;; var trig, note, son, sweep;
;;
;; trig = CoinGate.kr(0.5, Impulse.kr(2));
;;
;; note = Demand.kr(trig, 0, Dseq((22,24..44).midicps.scramble, inf));
;;
;; sweep = LFSaw.ar(Demand.kr(trig, 0, Drand([1, 2, 2, 3, 4, 5, 6, 8, 16], inf))).exprange(40, 5000);
;;
;; son = LFSaw.ar(note * [0.99, 1, 1.01]).sum;
;; son = LPF.ar(son, sweep);
;; son = Normalizer.ar(son);
;; son = son + BPF.ar(son, 2000, 2);
;;
;; //////// special flavours:
;; // hi manster
;; son = Select.ar(TRand.kr(trig: trig) < 0.05, [son, HPF.ar(son, 1000) * 4]);
;; // sweep manster
;; son = Select.ar(TRand.kr(trig: trig) < 0.05, [son, HPF.ar(son, sweep) * 4]);
;; // decimate
;; son = Select.ar(TRand.kr(trig: trig) < 0.05, [son, son.round(0.1)]);
;;
;; son = (son * 5).tanh;
;; son = son + GVerb.ar(son, 10, 0.1, 0.7, mul: 0.3);
;; son.dup
;;}.play

(demo 30
      (let [trig (coin-gate 0.5 (impulse:kr 2))
            note (demand trig 0 (dseq (shuffle (map midi->hz (conj (range 24 45) 22))) INF))
            sweep (lin-exp (lf-saw (demand trig 0 (drand [1 2 2 3 4 5 6 8 16] INF))) -1 1 40 5000)

            son (mix (lf-saw (* note [0.99 1 1.01])))
            son (lpf son sweep)
            son (normalizer son)
            son (+ son (bpf son 2000 2))

            ;;special flavours
            ;;hi manster
            son (select (< (t-rand:kr :trig trig) 0.05) [son (* 4 (hpf son 1000))])

            ;;sweep manster
            son (select (< (t-rand:kr :trig trig) 0.05) [son (* 4 (hpf son sweep))])

            ;;decimate
            son (select (< (t-rand:kr :trig trig) 0.05) [son (round son 0.1)])

            son (tanh (* son 5))
            son (+ son (* 0.3 (g-verb son 10 0.1 0.7)))
            son (* 0.3 son)]

        [son son]))

;;(stop)
#+END_SRC
** 
** (nsovertone.examples.compositions.bells
#+BEGIN_SRC clojure
(nsovertone.examples.compositions.bells
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

;;http://computermusicresource.com/Simple.bell.tutorial.html
(def dull-partials
  [
   0.56
   0.92
   1.19
   1.71
   2
   2.74
   3
   3.76
   4.07])

;; http://www.soundonsound.com/sos/Aug02/articles/synthsecrets0802.asp
;; (fig 8)
(def partials
  [
   0.5
   1
   3
   4.2
   5.4
   6.8])

;; we make a bell by combining a set of sine waves at the given
;; proportions of the frequency. Technically not really partials
;; as for the 'pretty bell' I stuck mainly with harmonics.
;; Each partial is mixed down proportional to its number - so 1 is
;; louder than 6. Higher partials are also supposed to attenuate
;; quicker but setting the release didn't appear to do much.

(defcgen bell-partials
  "Bell partial generator"
  [freq {:default 440 :doc "The fundamental frequency for the partials"}
   dur  {:default 1.0 :doc "Duration multiplier. Length of longest partial will
                            be dur seconds"}
   partials {:default [0.5 1 2 4] :doc "sequence of frequencies which are
                                        multiples of freq"}]
  "Generates a series of progressively shorter and quieter enveloped sine waves
  for each of the partials specified. The length of the envolope is proportional
  to dur and the fundamental frequency is specified with freq."
  (:ar
   (apply +
          (map
           (fn [partial proportion]
             (let [env      (env-gen (perc 0.01 (* dur proportion)))
                   vol      (/ proportion 2)
                   overtone (* partial freq)]
               (* env vol (sin-osc overtone))))
           partials ;; current partial
           (iterate #(/ % 2) 1.0)  ;; proportions (1.0  0.5 0.25)  etc
           ))))


(definst dull-bell [freq 220 dur 1.0 amp 1.0]
  (let [snd (* amp (bell-partials freq dur dull-partials))]
    (detect-silence snd :action FREE)
    snd))

(definst pretty-bell [freq 220 dur 1.0 amp 1.0]
  (let [snd (* amp (bell-partials freq dur partials))]
    (detect-silence snd :action FREE)
    snd))

;; TUNE - Troika from Lieutenant Kije by Sergei Prokofiev
;; AKA the Sleigh song
;; AKA that tune they play in most Christmas adverts

(def bell-metro  (metronome 400))

;; Two lines - the i-v loop that sort of sounds right
;; and the melody. _ indidcates a rest, we don't have to worry
;; about durations as this is percussion!
(def kije-troika-intervals
  (let [_ nil]
    [[ :i++ :v++ ]
     [ :i :i ]
     [_     _    _     _    _     _   _   _
      _     _    _     _    _     _  :v   _
      :i+  :vii  :vi  :vii  :i+   _  :vi  _
      :v    _     :vi  _   :iii   _  :v   _
      :vi  :v     :iv  _   :i+   _   :vii :i+
      :v   _      _    _   _     _   :iv  :iii
      :ii  _      :vi  _  :v     _   :iv  _   :v :iv
      :iii :iv    :v   _  :i+   :vi :iv  _   :iii  :iv :v _ :v _ :i ]]))

;; Playing in C major
(def troika-hz
  "Map all nested kije troika intervals to hz using the major scale with root C5"
  (let [scale [:major :C5]]
    (letfn [(intervals->hz [intervals]
              (map #(when % (midi->hz %)) (apply degrees->pitches intervals scale)))]
      (map intervals->hz kije-troika-intervals))))

;; Plays the tune endlessly
(defn play-bells
  "Recursion through time over an sequence of infinite sequences of hz notes
  (or nils representing rests) to play with the pretty bell at the specific
  time indicated by the metronome"
  [beat notes]
  (let [next-beat     (inc beat)
        notes-to-play (remove nil? (map first notes))]
    (at (bell-metro beat)
        (dorun
         (map #(pretty-bell % :amp 0.5) notes-to-play)))
    (apply-by (bell-metro next-beat) #'play-bells [next-beat (map rest notes)])))

;; Start the bells ringing...
(defn runner
  "Start up the play-bells recursion with a repeating troika melody and baseline"
  []
  (play-bells (bell-metro) (map cycle troika-hz)))

;; (pretty-bell 440) ;; sounds a bit woodblock
;; (pretty-bell 2000 7.00) ;; diiiiiiiiinnng
;; (dull-bell 600 5.0) ;;  ddddddonnnngg
;; (runner) ;; happy xmas
;; (stop)
#+END_SRC
** 
** (nsovertone.examples.compositions.blues
#+BEGIN_SRC clojure
(nsovertone.examples.compositions.blues
  (:use overtone.live)
  (:use [overtone.inst synth drum]))
#+END_SRC

#+BEGIN_SRC clojure

(definst beep [note 60 amp 0.2]
  (let [freq (midicps note)
        src (sin-osc freq)
        env (env-gen (perc 0.3 2) :action FREE)]
    (* amp src env)))

(def ps (atom []))

(defn play-blues [instr pitch-classes]
  (doseq [pitch pitch-classes]
    (swap! ps conj pitch)
    (instr pitch)))

(defn play-seq [count instr notes durs time odds]
  (when (and notes durs)
    (let [dur   (- (/ (first durs) 1.2) 10 (rand-int 20))
          pitch (first notes)
          n-time (+ time dur)]
      (at time
          (when (> (rand) (- 1 odds))
            (tom))

          (when (zero? count)
            (kick)
            (bass (midi->hz (first pitch)) (* 4 (/ dur 1000.0))))

          (when (#{1 3} count)
            (if (> (rand) (- 1 odds))
              (bass (midi->hz (first pitch)) (* 4 (/ dur 1000.0 2)) 0.1))
            (snare))

          (when (= 2 count)
            (kick))

          (play-blues instr pitch))
      (at (+ time (* 0.5 dur))
          (closed-hat 0.1))
      (apply-by n-time #'play-seq
                [(mod (inc count) 4) instr (next notes) (next durs) n-time odds]))))

; TODO: Strum the chord

(def blues-chords
  [:i  :major
   :iv :major
   :i  :major7
   :i  :7
   :iv :major
   :iv :7
   :i  :major
   :i  :major
   :v  :major
   :v  :7
   :i  :major
   :v  :7])

; Bass note on the one
(def bass-line (map first (partition 4 blues-chords)))

(defn progression [chord-seq key-note octave scale]
  (for [[roman-numeral chord-type] (partition 2 chord-seq)]
    (chord (+ (note (str (name key-note) octave))
              (degree->interval roman-numeral scale))
           chord-type)))

(defn blue-beep []
  (play-seq 0 beep
            (cycle (mapcat #(repeat 4 %) (map sort (progression blues-chords :a 3 :ionian))))
            (cycle [1200 1204 1195 1206])
            (now)
            0.2))

;;(blue-beep)
(stop)

; Be sure to try moving the mouse around...
(defn blue-ks1 []
  (play-seq 0 ks1
            (cycle (map sort (progression blues-chords :a 2 :ionian)))
            (take 80 (map #(* 1.5 %) (cycle [530 524 532 528])))
            (now)
            0.5))

(defn blue-ks1-demo []
  (play-seq 0 ks1-demo
            (cycle (map sort (progression blues-chords :a 2 :ionian)))
            (take 80 (map #(* 1.5 %) (cycle [530 524 532 528])))
            (now)
            0.5))

;(blue-ks1)
;(blue-ks1-demo)
;(stop)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Something like Steve Reich - Clapping Music ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+END_SRC
** 
** (nsovertone.examples.compositions.clapping-music
#+BEGIN_SRC clojure
(nsovertone.examples.compositions.clapping-music
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

(def clap (freesound 48310))
(def clap2 (freesound 132676))
;(clap)
;(clap2)

(def pattern-1 [1 1 1 0 1 1 0 1 0 1 1 0])
(def pattern-2 [1 1 1 0 1 1 0 1 0 1 1 0])

(defn my-cycle []
  (def pattern-2 (let [e (last pattern-2)
                       p (drop-last pattern-2)]
                   (vec (conj p e)))))

(def m (metronome 32))

(defn play-beat [beat]
  (dorun (map (fn [i]
                (let [v (if (= 0 (mod i 3)) 1 0.5)]
                  (when (= (pattern-1 i) 1)
                    (at (m (+ (/ i 12.0) beat)) (clap 1 0 0 (* v 0.33))))
                  (when (= (pattern-2 i) 1)
                    (at (m (+ (/ i 12.0) beat)) (clap2 1 0 0 v)))))
              (range 12))))

(defn player [beat]
  (when (= (mod beat 4) 0) (my-cycle))
  (play-beat beat)
  (apply-by (m (inc beat)) #'player (inc beat) []))

(player (m))
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.compositions.extemp-piano
#+BEGIN_SRC clojure
(nsovertone.examples.compositions.extemp-piano
  (:use [overtone.live]
        [overtone.inst synth sampled-piano]))
#+END_SRC

#+BEGIN_SRC clojure

;; This example has been translated from the Extempore code demonstrated in
;; http://vimeo.com/21956071 (found around the 10 minute mark)

;; Original Extempore code:
;; (load-sampler sampler "/home/andrew/Documents/samples/piano")
;; (define scale (pc:scale 0 'aeolian))
;; (define loop
;;   (lambda (beat dur root)
;;      (for-each (lambda (p offset)
;;                   (play (+ offset) sampler p 100 (* 2.0 dur)))
;;                (pc:make-chord 40 (cosr 75 10 1/32) 5
;;                               (pc:chord root (if (member root '(10 8))
;;                                                '^7
;;                                                '-7)))
;;                '(1/3 1 3/2 1 2 3))
;;      (callback (*metro* (+ beat (* 0.5 dur))) 'loop (+ dur beat)
;;                dur
;;                (if (member root '(0 8))
;;                  (random '(2 7 10))
;;                  (random '(0 8))))))

(def chord-prog
  [#{[2 :minor7] [7 :minor7] [10 :major7]}
   #{[0 :minor7] [8 :major7]}])

(def beat-offsets [0 0.1 0.2 1/3  0.7 0.9])

(def metro (metronome 20))

(def root 40)
(def max-range 35)
(def range-variation 10)
(def range-period 8)

(defn beat-loop
  [metro beat chord-idx]
  (let [[tonic chord-name] (choose (seq (nth chord-prog chord-idx)))
        nxt-chord-idx      (mod (inc chord-idx) (count chord-prog))
        note-range         (cosr beat range-variation  max-range range-period)
        notes-to-play      (rand-chord (+ root tonic)
                                       chord-name
                                       (count beat-offsets)
                                       note-range)]
    (dorun
     (map (fn [note offset]
            (at (metro (+ beat offset)) (sampled-piano note 0.3)))
          notes-to-play
          beat-offsets))
    (apply-by (metro (inc beat)) #'beat-loop [metro (inc beat) nxt-chord-idx])))

;;start the music:
(beat-loop metro (metro) 0)

;;try changing the beat-offsets on the fly
;(def beat-offsets [0 0.2 1/3  0.5 0.8])
;(def beat-offsets [0 0.2 0.4  0.6 0.8])
;(def beat-offsets [0 0.1 0.2  0.3 0.4])
;(def beat-offsets [0 0.1 0.11 0.13 0.15 0.17 0.2 0.4 0.5 0.55 0.6 0.8])

;;to stop call (stop)
;(stop)
#+END_SRC
** 
** (nsovertone.examples.compositions.funk
#+BEGIN_SRC clojure
(nsovertone.examples.compositions.funk
    "This example creates a simple drum and bass pattern, based off of
    the James Brown classic 'Licking Stick', with Bootsy Collins on bass,
    and John Jab'o Starks on drums"
    (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

; model a plucked string, we'll use this for our bass
(definst string [note 60 amp 1.0 dur 0.5 decay 30 coef 0.3 gate 1]
  (let [freq (midicps note)
        noize (* 0.8 (white-noise))
        dly   (/ 1.0 freq)
        plk   (pluck noize gate dly dly decay coef)
        dist  (distort plk)
        filt  (rlpf dist (* 12 freq) 0.6)
        clp   (clip2 filt 0.8)
        reverb (free-verb clp 0.4 0.8 0.2)]
    (* amp (env-gen (perc 0.0001 dur) :action 0) reverb)))

; define a simple drumkit using freesound samples
(def snare (sample (freesound-path 26903)))
(def kick (sample (freesound-path 2086)))
(def close-hihat (sample (freesound-path 802)))
(def open-hihat (sample (freesound-path 26657)))


(defn subdivide
    "subdivide two time intervals by 4, and return the time interval
    at position. this is a cheap hack to schedule 16th notes without
    defining the whole pattern with the metronome firing every 16th note."
    [a b position]
    (+ a (* position (/ (- b a) 4) )))

(defn drums [nome]
    (let [beat (nome)]
        ; hi-hat pattern
        (at (nome beat) (close-hihat))
        (at (nome (+ 1 beat)) (open-hihat))
        (at (nome (+ 2 beat)) (close-hihat))
        (at (nome (+ 3 beat)) (close-hihat))
        (at (nome (+ 4 beat)) (close-hihat))
        (at (nome (+ 5 beat)) (open-hihat))
        (at (nome (+ 6 beat)) (close-hihat))
        (at (nome (+ 7 beat)) (close-hihat))

        ; snare pattern
        (at (nome (+ 2 beat)) (snare))
        (at (subdivide (nome (+ 2 beat)) (nome (+ 4 beat)) 3) (snare))
        (at (subdivide (nome (+ 4 beat)) (nome (+ 6 beat)) 1) (snare))
        (at (nome (+ 6 beat)) (snare))
        (at (subdivide (nome (+ 6 beat)) (nome (+ 8 beat)) 3) (snare))

        ; kick drum pattern
        (at (nome beat) (kick))
        (at (nome (+ 5 beat)) (kick))
        (at (nome (+ 7 beat)) (kick))
        (apply-by (nome (+ 8 beat)) drums nome [])))

(defn bass [nome]
    (let [beat (nome)]
    (at (nome beat) (string 51))
    (at (subdivide (nome beat) (nome (+ 2 beat)) 1) (string 51))
    (at (subdivide (nome beat) (nome (+ 2 beat)) 3) (string 51))
    (at (subdivide (nome (+ beat 1)) (nome (+ 3 beat)) 1) (string 51))
    (at (subdivide (nome (+ beat 1)) (nome (+ 3 beat)) 3) (string 51))
    (at (nome (+ 4 beat)) (string 51))
    (at (subdivide (nome (+ 4 beat)) (nome (+ 6 beat)) 1) (string 49))
    (at (nome (+ 5 beat)) (string 46))
    (at (nome (+ 6 beat)) (string 51))
    (at (subdivide (nome (+ 6 beat)) (nome (+ 8 beat)) 1) (string 49))
    (at (nome (+ 7 beat)) (string 46))
    (at (nome (+ 8 beat)) (string 51))
    (at (nome (+ 12 beat)) (string 51))
    (at (subdivide (nome (+ 12 beat)) (nome (+ 14 beat)) 1) (string 51))
    (apply-by (nome (+ 16 beat)) bass nome [])))

(defn section [nome]
    (drums nome)
    (bass nome))

;; define a metronome that will fire every eighth note
;; at 100 bpm

(def met (metronome (* 100 2)))
;; to play the beat, just run
;; (section met)
;; (stop)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; A kind of jazz music      ;;
;; By Mikkel Gravgaard, 2012 ;;
;;                           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+END_SRC
** 
** (ns^:hw overtone.examples.compositions.jazz
#+BEGIN_SRC clojure
(ns^:hw overtone.examples.compositions.jazz
  (:use [overtone.live]
        [overtone.inst.drum]
        [overtone.inst.synth]
        [overtone.examples.compositions.rotater]))
#+END_SRC

#+BEGIN_SRC clojure

(remove-event-handler :breakbeat-handler)

;; just a simple example of a synth
;; we'll use this together with the bass
(definst beep [note 60]
  (let
      [src (sin-osc (midicps note))
       env (env-gen (perc 0.01 0.9) :action FREE)]
    (* src env)))

;; drums
(def ride (sample (freesound-path 436)))

(def cymbal (sample (freesound-path 13254)))

(def snap (sample (freesound-path 87731)))

;; swing
(defn offnote? [time]
  (= (mod time 1 ) 0.5))

(defn swing [time]
  (if (offnote? time)
    (+ time 0.2)
    time))

(def tempo 160)

(def metro (metronome tempo))

(defn play-bar [bar-beat bar]
  (doseq [hit (bar)]
    (let [hit-time (swing (first hit))
          instr (second hit)]
      (at (metro (+ bar-beat hit-time))
        (instr)))))

(defn loop-play [bar len]
  (let [beat (metro)]
    (play-bar beat bar)
    (apply-by (metro (+ len beat)) #'loop-play [bar len])))

(def length 4)

(defn jazzdrums
  []
  ;; filter out all nils
  (filter #(not (nil? %))
          (concat
           ;; ride on every beat
           (map (fn [t] [t ride]) (range 0 length))
           ;; off-beat ride
           (map #(when (< (rand) 0.3) [% ride]) (range 0.5 length))

           ;; snaps on every other beat
           ;; the snaps are a bit late, subtract a bit to get them on time
           (map (fn [t] [(- t 0.02) snap]) (range 1 length 2))

           ;; off-beat snare once in a while
           (map #(when (< (rand) 0.1) [% snare]) (range 0.5 length))

           ;; 'hit' consisting of cymbal+kick at some random off-beat
           ;; doing it this way allows us to place two drums on same beat
           (when (< (rand) 0.1)
             (let [t (+ 0.5 (rand-int length))]
               (list [t kick] [t cymbal])))
           )))

(defn limit [n minimum maximum]
  (max minimum
       (min maximum n)))

(def jazz-intervals '(-7 -6 -5 5 6 7))
(def maxbass 40)
(def minbass 65)


(defn jazzbass
  ([] (let [start-note 45
            beat (metro)
            next-even (if (zero? (mod beat 2))
                        beat
                        (inc beat))]
        (apply-by (metro next-even) #'jazzbass [start-note])))
  ([n]
     (let [beat (metro)
           tick (metro beat)
           note (if (not (zero? (mod beat 2)))
                  ;; just go half a step down
                  (dec n)
                  ;; keep tone inside interval
                  ;; TODO - avoid hanging around at the limits
                  (limit (+ n (rand-nth jazz-intervals)) maxbass minbass))]
       (at tick
         (beep note)
         (bass (midi->hz note)))
       ;; extra off-beat note with same tone
       (when (> 0.1 (rand))
         (at (metro (+ beat (swing 0.5)) )
           (beep note)
           (bass (midi->hz note))))
       (apply-by (metro (+ beat 1)) #'jazzbass [note]))))


;; Set up rotater

(def device-filter [ :midi-device "Novation DMS Ltd" "Launchpad" "Launchpad"])


(on-event (conj device-filter :note-on)
          (fn [e]
            (rotater e 0))
          :handle-rotate-on)

(on-event (conj device-filter :note-off)
          (fn [e]
            (rotater e 0))
          :handle-rotate-off)

(defn rotater-hit [note vel len]
  (let [start (+ 1 (metro))]
   (do
     (at (metro start)
       (rotater-on note vel))
     (apply-by
      (metro (+ len start))
      #'rotater-off [note]))))

(defn stab []
  (let [note (rand-nth (range 56 67))
        vel (rand-nth (range 10 80 5))
        len (rand-nth (range 0.05 0.3 0.05))
        interval (rand-nth [4])]
    (map #(rotater-hit % vel len) (list note (+ note interval)))))

;; Place cursor at the end of these expressions
;; and do C-x e to execute them

;; Play drums
;; (loop-play #'jazzdrums length)

;; Play bass
;; (jazzbass)

;; Play some pno!
;; currently, this sends out midi, so you'll have to
;; connect something at the other end ;-)
;; Check the synth-out def in rotater.clj
;; (stab)

;; (stop)

;; TODO - a way of ensuring that we start drums+bass at (zero? (mod beat 4))


;; TODO - some way to go to double tempo - the one below turns music into noise!
;; (metro :bpm (* 2 tempo))

;; And back to music!
;; (metro :bpm tempo)
#+END_SRC
** 
** (nsovertone.examples.compositions.piano-phase
#+BEGIN_SRC clojure
(nsovertone.examples.compositions.piano-phase
  (:use overtone.live
        overtone.inst.sampled-piano))
#+END_SRC

#+BEGIN_SRC clojure

;; Steve Reich's Piano Phase

(def piece [:E4 :F#4 :B4 :C#5 :D5 :F#4 :E4 :C#5 :B4 :F#4 :D5 :C#5])

(defn player
  [t speed notes]
  (let [n      (first notes)
        notes  (next notes)
        t-next (+ t speed)]
    (when n
      (at t
        (sampled-piano (note n)))
      (apply-by t-next #'player [t-next speed notes]))))

(def num-notes 1000)

(do
  (player (now) 338 (take num-notes (cycle piece)))
  (player (now) 335 (take num-notes (cycle piece))))

;;(stop)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Midi rotater                ;;
;;                             ;;
;; Inspired by this video:     ;;
;; http://youtu.be/4kBpxBJkknY ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+END_SRC
** 
** (ns^:hw overtone.examples.compositions.rotater
#+BEGIN_SRC clojure
(ns^:hw overtone.examples.compositions.rotater
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure


;; Specify output device
(def synth-out (first (midi-connected-receivers)))

;; Rotate between these notes
(def rotation-notes (ref '(-10 -7 -14 -5)) )

;; TODO - use a pointer into the list mod list length instead
(defn next-rotate []
  (let [note (first @rotation-notes)]
    (ref-set rotation-notes (concat (rest @rotation-notes) (list note)))
    note))


;; Init a vector of 128 empty lists
(def notes-playing
  (ref (vec (repeat 128 '()))))

(defn add-notes [note notes]
  (ref-set notes-playing
           (assoc @notes-playing note notes)))

(defn rotater-on [note vel]
  (dosync ;; (next-rotate) and (add-notes) must be sync'ed
   (let [notes (map #(+ % note) [(next-rotate) 0 7])]
     (prn 'on notes)
     (add-notes note notes) ;; mapping note => notes
     (doseq [n notes] (midi-note-on synth-out n vel))
     )))

(defn rotater-off [note]
  (let [notes (@notes-playing note)]
    (prn 'off notes)
    (doseq [n notes] (midi-note-off synth-out n))
    ))

;; the rotater function to handle incoming midi
(defn rotater [event ts]
  (let [chan (:chan event)
        cmd (:command event)
        note (:note event)
        vel (:velocity event)]
    (case cmd
      :note_-on (rotater-on note vel)
      :note-off (rotater-off note))))
#+END_SRC
* getting started
** 
** (nsovertone.examples.getting-started.basic
#+BEGIN_SRC clojure
(nsovertone.examples.getting-started.basic
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

;; Some of the examples gathered here were found on this page:
;; http://en.wikibooks.org/wiki/Designing_Sound_in_SuperCollider/Print_version
;; which come originally from the book Designing Sound by Andy Farnell.

(defsynth foo [freq 200 dur 0.5]
  (let [src (saw [freq (* freq 1.01) (* 0.99 freq)])
        low (sin-osc (/ freq 2))
        filt (lpf src (line:kr (* 10 freq) freq 10))
        env (env-gen (perc 0.1 dur) :action FREE)]
    (out 0 (pan2 (* 0.8 low env filt)))))

;;(foo 440)

(defn foo-pause
  []
  (dotimes [i 10]
    (foo (* i 220) 1)
    (Thread/sleep 300)))

;;(foo-pause)

;; Using Thread/sleep like above can result in JVM pauses with unknown
;; wakeup times, so in order to make sure sounds are triggered exactly
;; when you want them to you can wrap any call to a synthesizer function
;; in the (at <timestamp> ...) macro.  This will schedule all enclosed
;; synthesizer calls to play at the specified time.
(defn foo-timed
  []
  (let [n (now)]
    (dotimes [i 10]
      (at (+ n (* i 300))
          (foo (* i 220) 1)))))

;;(foo-timed)

;; A simple pad sound using definst rather than defsynth, which will
;; automatically take the enclosing synth and send it to a bus.
;; (Note how in comparison to foo above it doesn't use the out and pan ugens.)
(definst overpad [note 60 amp 0.7 attack 0.001 release 2]
  (let [freq  (midicps note)
        env   (env-gen (perc attack release) :action FREE)
        f-env (+ freq (* 3 freq (env-gen (perc 0.012 (- release 0.1)))))
        bfreq (/ freq 2)
        sig   (apply +
                     (concat (* 0.7 (sin-osc [bfreq (* 0.99 bfreq)]))
                             (lpf (saw [freq (* freq 1.01)]) f-env)))]
    (* amp env sig)))

;;(overpad 41 :attack 10 :release 20)

(def metro (metronome 128))

(definst kick []
  (let [src (sin-osc 80)
        env (env-gen (perc 0.001 0.3) :action FREE)]
    (* 0.7 src env)))

;;(kick)

(defn player [beat notes]
  (let [notes (if (empty? notes)
                [50 55 53 50]
                notes)]
    (at (metro beat)
        (kick))
    (at (metro beat)
        (if (zero? (mod beat 5))
          (overpad (+ 24 (choose notes)) 0.2 0.75 0.005)))
    (at (metro (+ 0.5 beat))
        (if (zero? (mod beat 6))
          (overpad (+ 12 (choose notes)) 0.5 0.15 0.1)
          (overpad (choose notes) 0.5 0.15 0.1)))
  (apply-by (metro (inc beat)) #'player (inc beat) (next notes) [])))

;;(player (metro) [])
;;(stop)

(defn play-notes [t beat-dur notes attacks]
  (when notes
    (let [note      (+ 12 (first notes))
          attack    (first attacks)
          amp       0.5
          release   0.1
          next-beat (+ t beat-dur)]
      (at t (overpad note amp attack release))
      (apply-by next-beat #'play-notes next-beat beat-dur (next notes) (next attacks) []))))

;;(play-notes (now) 425 (cycle [40 42 44 45 47 49 51 52]) (repeat 0.4))
;;(play-notes (now) 300 (scale :c4 :major) (repeat 0.05))
;;(play-notes (now) 300 (take 15 (cycle [40 42 44 45 47 49 51 52])) (repeat 0.3))
;;(play-notes (now) 100 (take 50 (cycle (scale :a4 :minor))) (repeat 0.4))
;;(stop)

;; Inspired by "How do I play a chord" from Impromptu website
(defn chord-notes []
 [(choose [58 60 60 62])
  (choose [62 63 63 65])
  (choose [65 67 68 70])])

(def metro (metronome 70))

(defn play-chords [b]
  (let [tick (* 2 (choose [125 500 250 250 500 250 500 250]))
        next-beat (inc b)]
    (at (metro b)
        (doseq [note (map #(- %  12) (chord-notes))]
            (overpad note 0.3 (/ tick 1020))))
    (apply-by (metro next-beat) #'play-chords [next-beat])))

;;(play-chords (metro))
;;(metro-bpm metro 70)
;;(stop)

;; You can load samples from freesound.org using their ID number:
(def kick-d (freesound 41155))
;;(kick-d)

(defn looper [t dur notes]
  (at t (kick-d))
  (at (+ t 350) (doseq [note (chord-notes)] (overpad (first notes) 0.3 0.1)))
  (at t (overpad (- (first notes) 36) 0.3 (/ dur 1000)))
  (apply-by (+ t dur) #'looper (+ t dur) dur (next notes) []))

;;(looper (now) 500 (cycle [60 67 65 72 75 70]))
;;(stop)

;; When a multiplication is done involving UGen objects, then
;; multiply UGens will be produced with the operands as their
;; inputs.  (Note that synthdefs can have doc strings too.)
(defsynth pedestrian-crossing
  "Street crossing in Britain."
  [out-bus 0]
  (out out-bus (pan2 (* 0.2 (sin-osc 2500) (lf-pulse 5)))))
;;(pedestrian-crossing)
;;(stop)

;; You can mix signals by adding them together.  The soundcard can take audio
;; data between -1 and 1, so if you add up signals remember to multiply
;; by a fractional number or else you will have clipping distortion.
(definst trancy-waves []
  (* 0.2
     (+ (sin-osc 200) (saw 200) (saw 203) (sin-osc 400))))

;; (trancy-waves)
;; (stop)

;; A noise filter, using the mouse to control the bandpass frequency and bandwidth
(demo 10 (bpf (* [0.5 0.5] (pink-noise))
              (mouse-y 10 10000)
              (mouse-x 0.0001 0.9999)))

;; Move your mouse around to hear the random sine waves moving around
(defsynth roaming-sines
  []
  (let [freqs (take 5 (repeatedly #(ranged-rand 40 2000)))
        ampmod [(mouse-x 0 1) (mouse-y 1 0)]
        snd (splay (* 0.5 (sin-osc freqs)))
        snd (* (sin-osc ampmod) snd)]
    (out 0 snd)))
;;(roaming-sines)
;;(stop)

;; Gangsta scratch
(defsynth scratch-pendulum []
  (let [kon (sin-osc:kr (* 10 (mouse-x)))
        k2 (sin-osc:kr (* 5 (mouse-x)))
        lpk (lin-lin:kr kon -1 1 0 1000)
        foo (poll:kr (impulse:kr 20) lpk)
        src (lpf (white-noise) lpk)
        src (pan2 src k2)
        bak (* 0.5 (lpf (white-noise)))]
    (out 0 (+ src [bak bak]))))
;;(scratch-pendulum)
;;(stop)


;; The functions representing UGens support what's called multi-channel
;; expansion.  What this means is that if pass a collection of N arguments
;; where a single value is expected, then N instances of the UGen will
;; be created, each using the successive values.
(definst dial-tone [freq-a 350 freq-b 440]
  (apply + (* (sin-osc [freq-a freq-b]) 0.2)))

;;(dial-tone)
;;(stop)

;; Synths can also communicate back to us.  Here we use the send-trig
;; UGen, which sends a "/tr" trigger message every time it gets an
;; input trigger.  The message includes an id number, and the current
;; input value of its last input.

(defsynth trigger-finger []
  (send-trig:kr (impulse:kr 0.2) 200 (num-output-buses)))

;;(on-event "/tr" #(println "trigger: " %) ::trigger-test)
;;(trigger-finger)
;;(stop)

(defsynth dtest []
  (send-trig:kr (impulse:kr 2) 1 (demand:kr (impulse:kr 0.5) 1 (dwhite))))

;; (dtest)
;; (stop)

(defsynth adder [a 1 b 2]
  (let [v1 (- a b)
        v2 (- b a)
        sum (+ a b)
        product (* a b)]
    (send-trig:kr v1 201 sum)
    (send-trig:kr v2 202 product)))

;;(adder)

;; You can read audio data in from your sound card using the regular (in <bus-num>) ugen,
;; but you need to know where your input buses start.  The output buses start at number 0,
;; and then the input buses begin, so you need to know how many outputs you have to know
;; the right bus to read from.
(defsynth external-input [out-bus 0]
  (out out-bus (in (num-output-buses:ir))))


(definst ticker [freq 2]
  (* (sin-osc 440) (env-gen (perc 0.1 0.2) (sin-osc:kr freq))))

;;(ticker)

(definst sizzle [amp 0.4 depth 10 freq 220 lfo 8]
  (* amp (saw (+ freq (* depth (sin-osc:kr lfo))))))

;;(sizzle)
;;(ctl sizzle :depth 100 :lfo 0.5)

;;(stop)

;; It's typical to use a pulse as a sort of on off switch like this.
(defsynth line-two [bus 0]
  (let [sig (lf-pulse 1/6 0 0.25)]
    (out 0 (* 0.5 (sin-osc [480 440]) (lag sig)))))

;; (line-two)
;; (stop)

(definst busy-signal []
  (let [on-off (lag (lf-pulse 2) 0.1)]
    (* 0.2
       (apply + (* (sin-osc [480 620]) on-off)))))

;;(busy-signal)
;;(stop)

;; Need to make a call?
(def DTMF-TONES {1  [697, 1209]
                 2  [770, 1209]
                 3  [852, 1209]
                 4  [697, 1336]
                 5  [770, 1336]
                 6  [852, 1336]
                 7  [697, 1477]
                 8  [770, 1477]
                 9  [852, 1477]
                 \* [697, 1633]
                 0  [770, 1633]
                 \# [852, 1633]})

(definst dtmf [freq-a 770 freq-b 1633 gate 1]
  (let [sig (* 0.2 (+ (sin-osc freq-a) (sin-osc freq-b)))
        env (env-gen (asr 0.001 1 0.001) gate 1 0 1 FREE)]
    (* sig env)))

(defn dial-number [num-seq]
  (loop [t (now)
         nums num-seq]
    (when nums
      (let [t-on  (+ t 160 (rand-int 200))
            t-off (+ t-on 160 (rand-int 80))
            [a b] (get DTMF-TONES (first nums))]
        (at t-on (dtmf a b))
        (at t-off (ctl dtmf :gate 0))
        (recur t-off (next nums))))))

;; Try this:
;;(dial-number [0 6 2 1 2 2 4 2 9 8])


;; The done ugen can act as a flag for the completion of envelopes and other ugens that
;; have a done action.  Listen to the noise come on after the 2 second sine wave.
(definst done-trigger []
  (let [line (line:kr 1 0 2)]
    (* 0.1 (+ (* line (sin-osc 440)) (* (done line) (white-noise))))))

;;(done-trigger)
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.getting-started.intro
#+BEGIN_SRC clojure
(nsovertone.examples.getting-started.intro
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

;; ## Outputting sound
;;
;; The "out" ugen is used to send data to a bus, and if passed multiple
;; channels it will automatically start at the first bus and send to successive
;; buses.  The first bus goes to your left audio channel on the sound card.
;;
;; Output a 440 hz sin wave to the left channel:
(defsynth beep [] (out 0 (* 0.1 (sin-osc 440))))

;; (beep) plays synth and returns an integer ID of a synth instance
;; (kill <id>) kills a specific synth instance
;; (stop) kills all synths

;; ## Controlling Amplitude
;;
;; The amplitude of a signal can be controlled using a multiply ugen, as is
;; used above.  Notice how we can pass arguments to synths too.
;; Try passing different values:
(defsynth beep2 [freq 440 amp 0.1]
  (out 0 (* amp (sin-osc freq))))

;; (beep2)
;; (beep2 220 0.4)
;; (beep2 80 0.8)
;; (stop)

;; ## Multi-channel output

;; The first N audio buses correspond to your soundcard output channels, so
;; outputting in stereo means sending audio data to buses 0 and 1, while 4
;; channel surround would require sending audio to buses 0 through 3.

;; We can make two parallel sin wave oscillators to output in stereo:
(defsynth beep3 [freq 440 amp 0.1]
  (let [a (* amp (sin-osc freq))
        b (* amp (sin-osc freq))]
    (out 0 [a b])))

;; (beep3)
;; (stop)

;; It would be annoying to have to duplicate everything anytime we want multi-channel
;; output, so Overtone also supports something called multi-channel expansion, which
;; is borrowed from sclang.  Expansion lets you pass a seq of arguments to any ugen
;; where a value is expected, and then it will create a new instance of the ugen
;; for each value in the seq.
;;
;; This is equivalent to the previous synth:

(defsynth beep4 [freq 440 amp 0.1]
  (out 0 (* amp (sin-osc [freq freq]))))

;; (beep4)
;; (stop)

;; This can be used in all sorts of ways, for example, here we slightly offset
;; the frequency in one channel:

(defsynth beep5 [freq 440 amp 0.1 offset 7]
  (out 0 (* amp (sin-osc [freq (+ offset freq)]))))

;; Try adjusting the offset to hear what it sounds like at different distances
;; from the main frequency.  You can adjust parameters of a running synth instance
;; using the (ctl <id> <:param> <val>) function like this:
;;
;; (def b (beep5))
;; (ctl b :offset 3)
;; (ctl b :offset 30)
;; (ctl b :offset 300)
;; (stop)

;; ## Delay
(defsynth beep6 [freq 440 amp 0.1 offset 7 delay 0.4]
  (let [src (* (env-gen (perc) :action FREE) (sin-osc [freq (+ offset freq)]))
        del (delay-n src delay delay)]
    (out 0 (* amp (+ src del)))))

;; (beep6)

;; ## Flanger
;;
;; A flanger is created by a signal added to a delayed copy of itself, where
;; the amount of the delay is varied over time.

(defsynth beep7 [freq 440 amp 0.1 offset 3 rate 4 depth 0.2 delay 0.3]
  (let [src (* (env-gen (perc 0.2 0.4) (dust:kr 1)) (sin-osc [freq (+ offset freq)]))
        lfo (* depth (abs (sin-osc rate)))
        del (delay-n src 2 (* lfo delay))]
    (out 0 (distort (* amp (+ src del))))))

;; (beep7)
;; (stop)

;; ## Chorus
;;
;; A chorus effect is created by adding multiple delayed copies of a signal
;; together, possibly modifying the amplitude and other factors of each
;; voice to give them unique sounds.
;;

;; ## Overdrive and Distortion
;;
;; Basic distortion and overdrive can be created by clipping a signal when it goes
;; above a certain threshold.
;;

;; Random experiment...

(defsynth voices []
  (let [n 8
        src (* 0.6 (dust (repeat n 2)))
        del (comb-l src 0.1 (repeatedly n #(+ (rand 0.004) 0.003)) 4)]
    (out 0 (splay del :spread 0.8))))

;; (voices)
;; (stop)
#+END_SRC
** 
** (nsovertone.examples.getting-started.melody
#+BEGIN_SRC clojure
(nsovertone.examples.getting-started.melody
    (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

(defn string
  [freq duration]
  (with-overloaded-ugens
    (* (line:kr 1 1 duration FREE)
       (pluck (* (white-noise) (env-gen (perc 0.001 5) :action FREE))
              1 1 (/ 1 freq) (* duration 2) 0.25))))

(definst harpsichord [freq 440]
  (let [duration 1
        snd  (string freq duration)
        t1   (* 0.2 (string (* 2/1 freq) duration))
        t2   (* 0.15 (string (* 3/2 freq) duration))
        t3   (* 0.1 (string (* 4/3 freq) duration))
        t4   (* 0.1 (string (* 5/4 freq) duration))
        snd  (+ snd (mix [t1 t2 t3 t4]))]
    snd))

(def melody
  (let [pitches
        [67 67 67 69 71             ; Row, row, row your boat,
         71 69 71 72 74             ; Gently down the stream,
         79 79 79 74 74 74 71 71 71 ; Merrily, merrily, merrily, merrily,
         67 67 67 74 72 71 69 67]   ; Life is but a dream!
        durations
        [1 1 2/3 1/3 1
         2/3 1/3 2/3 1/3 2
         1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3 1/3
         2/3 1/3 2/3 1/3 2]
        times (reductions + 0 durations)]
    (map vector times pitches)))

(defn play [metro notes]
  (let [play-note (fn [[beat midi]] (at (metro beat) (-> midi midi->hz harpsichord)))]
    (dorun (map play-note notes))))

(defn after [beats metro] (comp metro #(+ % beats)))

(defn play-round [metro notes]
  (play metro notes)
  (play (after 4 metro) notes)
  (play (after 8 metro) notes)
  (play (after 16 metro) notes))

;(play (metronome 120) melody)
;(play-round (metronome 120) melody)

(defn -main [& args]
  (let [metro (metronome 120)]

    ;; play the melody
    (play metro melody)
    (play-round (after 16 metro) melody)

    ;; wait for the melody to finish
    (Thread/sleep (- (metro 48) (now)))));; Making Music with Clojure
;; Live Coding is all the Rage at Raves
;; By Sam Aaron
;; Originally published in PragPub, December 2013
;; Copyright 2014 Sam Aaron


;; The laser beams sliced through the wafts of smoke as the subwoofer
;; pumped bass deep into the bodies of the crowd. The atmosphere was
;; ripe with a heady mix of synths and dancing. However something wasn't
;; quite right in this nightclub. Projected in bright colours above the
;; DJ booth was futuristic text, moving, dancing flashing. This wasn't
;; fancy visuals, it was merely a projection of a terminal containing
;; Emacs. The occupants of the DJ booth weren't spinning disks, they
;; were writing, editing and evaluating code. This was a Meta-eX
;; (http://meta-ex.com) gig. The code was their musical interface and
;; they were playing it live.

;; This wasn't a scene from a cheesy sci-fi film. Coding music like this
;; is a growing trend and is often described as Live Coding
;; (http://toplap.org). One of the recent directions this approach to
;; music making has taken is the Algorave (http://algorave.com) - events
;; where artists code music for people to dance to. However, you don't
;; need to be in a nightclub to Live Code - you can do it anywhere you
;; can take your laptop and a pair of headphones. In this article, we'll
;; explore one of the most powerful Live Coding toolkits available:
;; Overtone (http://overtone.github.io). Once you reach the end, you'll
;; be programming your own beats and modifying them live. Where you go
;; afterwards will only be constrained by your imagination.

;; Installation

;; To follow along, you'll need a couple of dependencies
;; installed. Firstly you'll need a JVM (https://java.com/getjava)
;; (v1.6+) and you'll also need a handy tool called Leiningen
;; (http://leiningen.org) (v2.0+). Both links provide installation
;; instructions, but ultimately you'll want to be able to run the `lein`
;; command on a terminal/command window and see a list of options.

;; Once you have a JVM and `lein`, create a new project with:

;; lein new insane-sounds

;; You then need to fire up your trusty text editor, open
;; `insane-sounds/project.clj` and add Overtone as a dependency. The file
;; should look as follows:

(defproject foo "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [overtone "0.9.1"]])

;; Save the file, then `cd` into the `insane-sounds` directory and run:

;; lein repl

;; This may take some time depending on the speed of your internet
;; connection as it will download all of Overtone's dependencies
;; (including the SuperCollider synthesis server) and then boot you into
;; a Clojure REPL. You should see the following prompt:

;; user=>

;; Now you can start and boot Overtone by typing and entering:

(use 'overtone.live)

;; Evaluating this will start up an audio synthesis server and connect to
;; it for you. Once this process has finished, you should see the following
;; on your console:

;; --> Loading Overtone...
;; --> Booting internal SuperCollider server...
;;
;;    _____                 __
;;   / __  /_  _____  _____/ /_____  ____  ___
;;  / / / / | / / _ \/ ___/ __/ __ \/ __ \/ _ \
;; / /_/ /| |/ /  __/ /  / /_/ /_/ / / / /  __/
;; \____/ |___/\___/_/   \__/\____/_/ /_/\___/
;;
;;  Collaborative Programmable Music. v0.9.1
;;
;; Hello Sam. Do you feel it? I do. Creativity is rushing through your veins today!

;; Let's make a simple sound:

(demo (pan2 (sin-osc)))

;; Beeep! Testing, testing, 1, 2, 3! We can go crazy and change the
;; frequency:

(demo (pan2 (sin-osc 220)))

;; Play around with changing the frequency to different values. How high
;; can you go and still hear it? How low can you go? Try it with some
;; decent headphones/speakers and hear the deep bass pump out...

;; We can even swap out the oscillator generator. Try replacing
;; `sin-osc` with the following: `saw`, `square`,
;; `lf-tri`. Additionally, try removing the `pan2` and replacing the
;; frequency number with a vector of two values:

(demo (saw [55 55.2]))

;; Try different values for `saw`, `100` and `101`. Don't worry too much
;; about what any of this *means* just experiment and have fun! Come
;; back when you've finished giving all your friends a headache...

;; Hello again. Enough with that new fangled synth nonsense. Let's play
;; something more traditional. Pull in the piano synth:

(use 'overtone.inst.piano)

;; We can now trigger a piano sound by calling the `piano` function:

(piano)

;; We can even call it with a MIDI number as an argument to specify the
;; piano note to play:

(piano 63)

;; Luckily, for those that haven't memorised all the MIDI
;; numbers, Overtone provides a handy function:

(note :C4)

;; This then brings us to our first use of Clojure's datastructures for
;; music - we can represent a chord using a vector:

(def c4-minor [(note :C4) (note :Eb4) (note :G4)])

;; This can easily be rendered as audio:

(doseq [note c4-minor]
  (piano note))

;; Or played as a simple arpegio:

(doseq [note c4-minor]
  (piano note)
  (Thread/sleep 200))

;; With the information provided so far in this section, it is
;; completely plausible to imagine piano compositions that consist of
;; interposed calls to `piano` and `Thread/sleep`:

(do
  (piano 50)
  (Thread/sleep 100)
  (piano 72)
  (Thread/sleep 50)
  (piano 49)
  (Thread/sleep 190)
  (piano 68)
  ;;.
  ;;.
  ;;. etc...)

;; The main drawback to defining our composition in such a procedural
;; manner is not only inelegant but also restricts creative flexibility
;; and freedom. Instead, it's often better to use Clojure's
;; datastructures to represent the composition in a declarative
;; style. This then opens us up to using Clojure's powerful set of
;; higher order functions to directly manipulate our compositions. This
;; is something which is explicitly explored in Chris Ford's [Leipzig]
;; (http://github.com/ctford/leipzig) library which can be used to
;; succinctly represent Bach's canons at a very high level. However,
;; rather than look towards Bach, today we're going to consider more
;; contemporary electronic music - live dance and dubstep.

;; Let's drop our piano and introduce some drums. First up, the mighty
;; kick drum:

(def dirty-kick (freesound 30669))

;; You will notice that evaluating this form for the first time may take
;; a few moments to complete. This is because this kick drum is actually
;; a recording of a kick drum in wav format which is available on the
;; fantastic Freesound website (http://freesound.org) and released under
;; a creative commons license. The `freesound` function takes the unique
;; ID of the sound (in this case 30669) and then downloads it on a
;; separate thread caching the file to your hard drive under
;; `~/.overtone`. Therefore the next time you access this particular
;; sound, it will retrieve it from your local file system rather than
;; from the Freesound server.

;; Once this form has completed evaluation, the var `dirty-kick` now
;; references a function which can be used to trigger the sound:

(dirty-kick)

;; Let's define a few more sounds:

(def ring-hat (freesound 12912))
(def snare (freesound 26903))
(def click (freesound 406))
(def wop (freesound 85291))
(def subby (freesound 25649))

;; Feel free to add some of your own. Just navigate to
;; http://freesound.org search around for a sound, make sure it's either
;; a wav or aiff find the ID of the sound (you can see it in the URL)
;; and then pass it as a parameter to the `freesound` function.

;; Let's make a driving beat:

(defonce cont? (atom true))

(future
  (while @cont?
    (subby)
    (Thread/sleep 300)
    (snare)
    (Thread/sleep 300)))

;; OK, so it's more like something out of a marching band than a driving
;; dubstep beat, but it's a good start. To stop it just reset the atom
;; to false:

(reset! cont? false)

;; There's a significant technical issue with this approach related to
;; timing - `Thread/sleep` can never be relied on for strongly timed
;; programs. The main issue here is that it defines a *minimum* amount
;; of time for the current thread to pause not the *precise* amount of
;; time. So, a call to `(Thread/sleep 200)` actually pauses the current
;; thread for `(+ 200 delay-t)` milliseconds where `delay-` is dependent
;; on the internal behaviour and workload of the scheduler and any GC
;; pauses. It can therefore be assumed that `delay-t` is
;; non-deterministic. This means that basing timing on top of
;; `Thread/sleep` will cause temporal drifting which is less than ideal
;; if you want to generate a steady rhythm or beat.

;; Overtone has an excellent solution for this issue - temporal
;; recursion. This is similar to recursion, except for applying the
;; current function at the tail position, we instead schedule it to
;; execute at some future time:

(defn scheduled-hello-world [curr-t sep-t]
  (println "hello world")
  (let [new-t (+ curr-t sep-t)]
    (apply-at new-t #'scheduled-hello-world [new-t sep-t])))

;; Here we create a standard Clojure function which accepts two
;; arguments, the current time and a separation time. The function
;; greets the world and then schedules itself to be executed in the
;; future where the time for execution is the current time plus the
;; separation time. This new time is then passed on to the new function
;; invocation along with the unmodified separation time. When we run
;; this function, with `(now)` and 200 as parameters we'll immediately
;; see our friendly greeting appear on the console every 200ms:

(scheduled-hello-world (now) 200)

;; Luckily this scheduled function honours the `stop` function, so to
;; cease the persistent and repeated friendliness just issue:

(stop)

;; Of course, we can perform any action inside this function, so instead
;; of printing to the console, let's make some sound. However, before we
;; do this, we need just one more time-related concept - the `at`
;; macro. As we saw above, `apply-at` will apply the specified function
;; at the specified time. However, this approach is completely
;; susceptible to similar timing issues as `Thread/sleep`. Through the
;; explicit handling of time, we won't see any cumulative drift
;; effect. However, each individual execution of the scheduled function
;; itself is arbitrarily delayed due to our non-deterministic friend
;; `delay-t`. Luckily we can combat this issue via a two-pronged
;; attack. Firstly, we can use `apply-by` in place of `apply-at`, this
;; will execute our function slightly ahead of our specified time to
;; give room for any execution delay. We then wrap any sound-making
;; triggers or controls within the `at` macro which instructs the audio
;; server to enact the trigger exactly at the specified time:

;; Play the piano 2 seconds from now
(at (+ (now) 2000) (piano))

;; As the audio server is written in highly optimised C++ it can do a
;; far better job of ensuring the action is performed at precisely the
;; correct time. Therefore, by calling our `at` macro sufficiently ahead
;; of time, we can ensure that we suffer no time delays or drift:

(defn beat [curr-t sep-t]
  (at curr-t (subby))
  (let [new-t (+ curr-t sep-t)]
    (apply-by new-t #'beat [new-t sep-t])))

(beat (now) 600)

;; Again we can stop this by calling the stop fn:

(stop)

;; Given this sound-playing and strongly-timed scheduling functionality,
;; we now have the full power of Clojure to build the sound system of
;; our dreams. Let's start by building a simple 8-step sequencer. We can
;; represent the state of a single sequence with a simple vector:

[1 0 0 0 0 0 0 0] ;; One beat at the start of the bar
[1 1 1 1 1 1 1 1] ;; Eight beats per bar
[1 0 1 1 0 0 0 1] ;; A more interesting rhythm

(defn simple-sequencer [curr-t sep-t pattern]
  (at curr-t (when (= 1 (first pattern))
               (subby)))
  (let [new-t (+ curr-t sep-t)]
    (apply-by new-t #'simple-sequencer [new-t sep-t (rest pattern)])))


(simple-sequencer (now) 200 (cycle [1 1 0 1 0 1 0 0]))
(stop) ;; Stop the beat

;; Our simple sequencer lets us play different patterns represented by
;; Clojure vectors. We also take advantage of laziness by creating an
;; infinite lazy sequence of cycles of the pattern to keep the beat
;; rolling on. However, there are a few limitations to this
;; approach. For example, we can only play one pattern at a time, it's
;; hard-coded to play the subby sound and we can't modify it at
;; run-time. Let's tackle each of these issues.

;; One way of representing multiple patterns with arbitrary sounds is to
;; use a map for our representation. For example, the vals within our
;; map could be the patterns and the correspdonding keys the sound
;; functions themselves:

(def pats {subby [1 1 0 1 0 1 0 0]
           snare [1 0 0 1 0 0 1 0]
           wop   [1 0 0 0 0 0 0 1]})

;; For this, we can modify our simple sequencer to work with arbitrary
;; sounds:

(defn play-pattern [curr-t sep-t pattern sound]
  (at curr-t (when (= 1 (first pattern))
               (sound)))
  (let [new-t (+ curr-t sep-t)]
    (apply-by new-t #'play-pattern [new-t sep-t (rest pattern) sound])))

;; We can then create a multi-patterned sequencer:

(defn sequencer [sep-t sequences]
  (let [t (+ (now) 200)]
    (doseq [[sound pattern] sequences]
      (play-pattern t sep-t (cycle pattern) sound))))

(sequencer 200 pats)
(stop)

;; In order to allow us to live-modify the patterns whilst the sequencer
;; is playing, we need to make some modifications. The key change is to
;; store our patterns in an atom. We also need to move away from
;; representing our patterns as an infinite lazy sequence which is
;; defined when the sequencer is created and closed for
;; modification. Instead we can explicitly store the current beat number
;; and on each temporally recursive call into the scheduling function,
;; we can look up the appropriate patten index (which is a mod of the
;; beat number and the size of the pattern). If the value of the pattern
;; at this index is 1 we can then schedule the matching sound to be
;; played. Each time round the temporal recursion we simply need to
;; update the schedule time and increment the beat count.

(def live-pats (atom pats))

(defn live-sequencer
  ([curr-t sep-t live-patterns] (live-sequencer curr-t sep-t live-patterns 0))
  ([curr-t sep-t live-patterns beat]
     (doseq [[sound pattern] @live-patterns
             :when (= 1 (nth pattern (mod beat (count pattern))))]
       (at curr-t (sound)))
     (let [new-t (+ curr-t sep-t)]
       (apply-by new-t #'live-sequencer [new-t sep-t live-patterns (inc beat)]))))

;; Once we have implemented this new live-sequencer function, we can
;; trigger it and then start modifying our live-pats atom:

(live-sequencer (+ 200 (now)) 200 live-pats)

(swap! live-pats assoc subby [1 1 0 1 0 0 1 1])
(swap! live-pats assoc snare [1 1 0 0 0 1 0 0])
(swap! live-pats assoc wop   [1 0 1 0 0 0 1 1])
(stop)

;; Try changing the pattern vector (swapping 1s for 0s and visa versa)
;; and have fun live jamming! When you've had enough, just issue a
;; `(stop)` command.

;; So, how can we have more fun than this? Typically in Overtone land,
;; the feeling that more fun could be had usually indicates that there's
;; an opportunity for us to add more control. One clear way to give us
;; greater control is to allow our patterns to convey information richer
;; than just 1s and 0s to represent on and off. For example, we might
;; want to specify the amplitude or the rate of each individual
;; beat. Luckily our sound function already provides this via keyword
;; arguments:

(subby :rate 2 :amp 0.5)

;; Given this new knowledge, we can now increase our pattern
;; representation from using just 1s and 0s to also include argument
;; maps through the use of the following simple helper fn:

(defn flatten1
  "Takes a map and returns a seq of all the key val pairs:
      (flatten1 {:a 1 :b 2 :c 3}) ;=> (:b 2 :c 3 :a 1)"
  [m]
  (reduce (fn [r [arg val]] (cons arg (cons val r))) [] m))

;; We can now call our synth fn using `apply` and our flattened arg
;; list:

(apply subby (flatten1 {:rate 2 :amp 0.5}))

;; Armed with this, let's improve our sequencer yet again:

(defn live-sequencer
  ([curr-t sep-t live-patterns] (live-sequencer curr-t sep-t live-patterns 0))
  ([curr-t sep-t live-patterns beat]
     (doseq [[sound pattern] @live-patterns
             :let [v (nth pattern (mod beat (count pattern)))
                   v (cond
                      (= 1 v)
                      []

                      (map? v)
                      (flatten1 v)

                      :else
                      nil)]
             :when v]
       (at curr-t (apply sound v)))
     (let [new-t (+ curr-t sep-t)]
       (apply-by new-t #'live-sequencer [new-t sep-t live-patterns (inc beat)]))))

(def a {:rate 0.5})
(def b {:rate 3})
(def c {:rate 10})

(live-sequencer (+ 200 (now)) 200 live-pats)

(swap! live-pats assoc subby [1 1 0 b 0 1 a c])
(swap! live-pats assoc snare [1 1 c c 1 a b c])
(swap! live-pats assoc wop   [c c 1 0 0 0 a c])

(stop)

;; This creates a much richer and interesting rhythm and is already a lot
;; more fun to play with. Let's control one more dimension: time.

;; So far, each sequencer implementation has maintained a constant timed
;; delay between each beat. What if the time for a whole pattern was
;; constant, and the time between each beat a division of that time over
;; the number of beats in the pattern. For example, we could represent a
;; pattern with three beats per bar with:

(def three-beats-per-bar [1 1 1])

;; and a pattern with 9 beats per bar with:

(def nine-beats-per-bar [1 1 1 1 1 1 1 1 1])

;; Therefore, an alternative yet semantically identical version of
;; `three-beats-per-bar` could be:

(def three-beats-per-bar-alt [1 0 0 1 0 0 1 0 0])

;; Let's modify our live-sequencer function to support this new
;; behaviour. First, we need to move to passing the time the full
;; pattern should take to play rather than the separation time between
;; beats. This separation time can them be calculated by dividing the
;; full pattern time by the number of beats within it. We also no longer
;; need to thread a beat count through the temporal recursion as we'll
;; now schedule a whole pattern at once.

(defn normalise-beat-info
  [beat]
  (cond
   (= 1 beat)         {}
   (map? beat)        beat
   (sequential? beat) beat
   :else              {}))

(defn schedule-pattern
  [curr-t pat-dur sound pattern]
  {:pre [(sequential? pattern)]}
  (let [beat-sep-t (/ pat-dur (count pattern))]
    (doseq [[beat-info idx] (partition 2 (interleave pattern (range)))]
      (let [beat-t    (+ curr-t (* idx beat-sep-t))
            beat-info (normalise-beat-info beat-info)]
        (if (sequential? beat-info)
          (schedule-pattern beat-t beat-sep-t sound beat-info)
          (at beat-t (apply sound (flatten1 beat-info))))))))

(defn live-sequencer
  [curr-t pat-dur live-patterns]
  (doseq [[sound pattern] @live-patterns]
    (schedule-pattern curr-t pat-dur sound pattern))
  (let [new-t (+ curr-t pat-dur)]
    (apply-by new-t #'live-sequencer [new-t pat-dur live-patterns])))


(live-sequencer (now) 2000 live-pats)
(swap! live-pats assoc subby [1 1 0 b 0 1 [1 1 1] [1 1 1 1 1 1 1]])
(swap! live-pats assoc snare [1 1 c c 1 a [1 a c 1] c])
(swap! live-pats assoc wop   [c a 0 0 a c c c])

(stop)

;; Finally we need a wobbly bass sound:

(defsynth wobble-bass [amp 1 note 52 wobble 1 detune 1.01 wob-lo 200 wob-hi 20000 pan 0]
  (let [saws          (mix (saw [note (* note detune)]))
        wob-freq      (lin-exp (lf-saw wobble) -1 1 wob-lo wob-hi)
        wob-freq      (lag wob-freq 0.05)
        filtered-saws (lpf saws wob-freq)
        normalized    (normalizer filtered-saws)
        amplified     (* amp normalized)]
    (out 0 (pan2 amplified pan))))

;; Before you freak out too much, we don't expect you to understand how
;; this works any any detail. Suffice to say that `defsynth` is a macro
;; which represents a synthesiser design. If you're interested in
;; further details, you can genrate a more traditional visual
;; representation of this design:

(show-graphviz-synth wobble-bass)

;; The first detail about the `defsynth` macro that is useful to know
;; here is that it creates a function in the current namespace with the
;; same name as the synth - in this case `wobble-bass`. We can use this
;; function to create new running (and therefore audible) instances of
;; the synth:

(wobble-bass)

;; To stop this (and all other running synths) you can use the `stop`
;; function:

(stop)

;; The second useful detail is the vector of symbol value pairs
;; immediately after the synth name represents the controllable
;; parameters. Our `wobble-bass` function allows us to specify these
;; using a named-argument style:

(wobble-bass :amp 0.5 :note 30 :wob-hi 2000)
(stop)

;; The final handy piece of knowledge is that the return value of the
;; `wobble-bass` function is a record which represents the running synth
;; created via the call. This record can be used to directly maniulate
;; the synth live whilst it is running using the `ctl` function which is
;; short for control:

(def wb (wobble-bass))
(ctl wb :amp 0.5 :note 50 :wobble 2)
(ctl wb :amp 0.5 :note 62 :wobble 1)
(ctl wb :note 40)
(ctl wb :wobble 0.1)
(ctl wb :amp 1)
(ctl wb :wob-hi 5000)
(ctl wb :wob-lo 100)

;; bring back the beats!

(live-sequencer (now) 2000 live-pats)
(swap! live-pats assoc subby [1 1 0 b 0 1 [1 1 1] [1 1 1 0 1 1 1]])
(swap! live-pats assoc snare [1 1 c c 1 a [1 a c 1] c])
(swap! live-pats assoc wop   [c a 0 0 a c c c])

(stop) ;; stop the insanity!

;; So, there you have it - we just coded from scratch a mini
;; live-modifiable drum patten DSL. How fun is that! This was clearly
;; just a small taster of the fantastic power that the heady combination
;; of Clojure and SuperCollider can offer you. Try playing with
;; different rhythms, different samples (any wav file from Freesound is
;; just but a call to `freesound` away) and let your imagination run
;; riot.

;; If you stick at it, perhaps you'll find yourself programming in a
;; nightclub too...
#+END_SRC
** 
** (nsovertone.examples.getting-started.rhythm
#+BEGIN_SRC clojure
(nsovertone.examples.getting-started.rhythm
  (:use [overtone.live]
        [overtone.inst.drum :only [quick-kick haziti-clap soft-hat open-hat]]))
#+END_SRC

#+BEGIN_SRC clojure

(def m (metronome 128))

(defn player
  [beat]
  (let [next-beat (inc beat)]
    (at (m beat)
        (quick-kick :amp 0.5)
        (if (zero? (mod beat 2))
          (open-hat :amp 0.1)))
    (at (m (+ 0.5 beat))
        (haziti-clap :decay 0.05 :amp 0.3))

    (when (zero? (mod beat 3))
      (at (m (+ 0.75 beat))
          (soft-hat :decay 0.03 :amp 0.2)))

    (when (zero? (mod beat 8))
      (at (m (+ 1.25 beat))
          (soft-hat :decay 0.03)))

    (apply-by (m next-beat) #'player [next-beat])))

;;(player (m))
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.getting-started.tutorial
#+BEGIN_SRC clojure
(nsovertone.examples.getting-started.tutorial
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

; Welcome to Overtone

; For starters lets just make some noise and get the basics of working with
; Overtone figured out.  Overtone is implemented in Clojure, and it uses the
; SuperCollider synthesis server for the back-end audio engine.  (So if you are
; already familiar with SC then much of this will be familiar to you.)  You
; should be reading this file in an editor that lets you interactively evaluate
; Clojure code.

; In Overtone you create synthesizers to generate audio.  You can think of a
; synthesizer definition as the design or blueprint for a signal processor.
; (In Max/MSP or PureData they call this a patch.)

; The synth macro takes a synth design, compiles it, loads it into the
; audio server, and returns a function that can be used to trigger the synth.
; Here is a 440 hz sin wave:
(def foo (synth (out 0 (pan2 (sin-osc 440)))))

; Trigger the synth by calling it like a regular function.  When called synth
; functions return an ID number representing an instance ID, which can be used
; to kill the synth or modify its parameters.
(def id (foo))  ; trigger the synth, saving its ID
(kill id)       ; kill the instance

; Use defsynth to create synthesizers and assign the player function to a symbol
; in the current namespace, just like fn and defn in clojure.core.  Note that
; synthesizer parameters must always have a default value.
(defsynth my-sin [freq 440]
  (out 0 (pan2 (sin-osc freq))))

; play the sin wave at different frequencies
(my-sin)     ; uses the default
(my-sin 220) ; an octave lower
(my-sin 447)

; If you lose a synth ID or things are going crazy and you just need to kill
; all the current synths, call stop to clear all the live synths.
(stop)

; The classic saw wave, creates even and odd harmonics with a bright sound
(definst sawzall [freq 440]
  (* (env-gen (perc 0.1 0.8) :action FREE)
     (saw freq)))

(sawzall)

; Triangle wave
(definst triangular [freq 120]
   (* (env-gen (perc 0.1 4.8) :action FREE)
     (lf-tri freq)))
(triangular 320)

; Square wave
(definst sq [freq 120]
   (* (env-gen (perc 0.1 4.8) :action FREE)
     (square freq)))
(sq 320)

; White noise
(definst noisey []
     (* (env-gen (perc 0.1 1.8) :action FREE)
     (white-noise)))
(noisey)

; Pink noise
(definst pink-noisey []
     (* (env-gen (perc 0.1 1.8) :action FREE)
     (pink-noise)))
(pink-noisey)

; A shortcut for doing the same thing, just like def and defn.
(definst foo [] (sin-osc 440))

; Now if we trigger the synth, it will return the ID of the instance of
; the synth that was created.  Turn your volume down, because this is
; going to make some noise.
(def id (foo))

;; Now you can kill this instance like so
(kill id)

; For future reference, if you want to stop all sound immediately you can
; call (reset).

; Often times in audio synthesis you want to generate multiple channels
; of audio, whether it be for stereo, or for creating multiple signals that will
; eventually get mixed back down to one or two channels.  To help with this,
; you can do something called multi-channel expansion.  It's simple.  Anywhere
; you can pass a value as an argument to a synthesis function, you can also
; pass a seq of values.
(definst bar [] (sin-osc [440 442]))
(bar)
(stop)

; As you might have noticed, the synths can take parameters too, so that you can
; control their input values both when you instantiate a synth, and later while
; they are running.  It works almost like a regular function definition, except
; you need to include default values.  Here is our sin wave oscillator that now
; has a controllable frequency.

(definst baz [freq 440]
  (sin-osc freq))

(baz 200)
(baz 800)
(baz 400)
(stop)
#+END_SRC
** 
** (nsovertone.examples.getting-started.video
#+BEGIN_SRC clojure
(nsovertone.examples.getting-started.video
  "Examples used in the video 'Quick Intro to Live Programming in Overtone'
   http://vimeo.com/22798433"
    (:use [overtone.live]
          [overtone.inst.sampled-piano]))
#+END_SRC

#+BEGIN_SRC clojure

;; use the sampled piano
;; note: The piano samples take a long time to download, but
;; it will only happen once.
(def piano sampled-piano)

; play some notes on our piano
(piano)
(piano 72)

;; this is one possible implementation of play-chord,
;; it was not shown in the video
(defn play-chord [a-chord]
  (doseq [note a-chord] (piano note)))

;; play a chord progression on our piano
(let [time (now)]
  (at time (play-chord (chord :D3 :major7)))
  (at (+ 2000 time) (play-chord (chord :A3 :major)))
  (at (+ 3000 time) (play-chord (chord :A3 :major7)))
  (at (+ 4300 time) (play-chord (chord :F3 :major7))))

;; here's a different function that encapsulates the above
(defn play-progression [chords]
  (if (empty? chords) nil
    (doseq []
      (play-chord (first chords))
      (Thread/sleep 2000)
      (play-progression (rest chords)))))

;; define a simple instrument. in the video, sam uses :action :free,
;; but this is now :action FREE
(definst beep [note 60]
  (let [sound-src (sin-osc (midicps note))
        env       (env-gen (perc 0.01 1.0) :action FREE)] ; sam uses :free
    (* sound-src env)))

;; admire our beep :-)
(beep)

;; beep across a wide range of sounds
(for [i (range 110)] (at (+ (now) (* i 20)) (beep i)))

;; model a plucked string. this is really cool!
(definst plucked-string [note 60 amp 0.8 dur 2 decay 30 coef 0.3 gate 1]
  (let [freq   (midicps note)
        noize  (* 0.8 (white-noise))
        dly    (/ 1.0 freq)
        plk    (pluck noize gate dly dly decay coef)
        dist   (distort plk)
        filt   (rlpf dist (* 12 freq) 0.6)
        clp    (clip2 filt 0.8)
        reverb (free-verb clp 0.4 0.8 0.2)]
    (* amp (env-gen (perc 0.0001 dur)) reverb)))

;; ___|)_______________|\________________|\______________|\_______________|\________
;;|___/___||___________|_________________|_______________|________________|_________||
;;|__/|___||.________,-.___( )___o-;___,-.___o-;__( )__,-.________o-; __,-.___o-;__.||
;;|_/(|,\_||.___(_)__`-'___|______/____`-'____/___|____`-'___(_)___/____`-'____/___.||
;;|_\_|_/_||____|__________|______________________|__________|______________________||
;;    |         |          |/                     |/         |
;;  (_|         |/                                           |/

;; note: the underscores are rests
(def reich-degrees [:vi :vii :i+ :_ :vii :_ :i+ :vii :vi :_ :vii :_])
(def pitches (degrees->pitches reich-degrees :diatonic :C4))

;; temporal recursion: create a function that takes:
;; 1) time to play a note
;; 2) list of notes to play
;; 3) seperation of notes
;;
;; Armed with these parameters, we check if the note is a rest,
;; if it isn't, schedule it to be played. then, we schedule
;; a recursive call to be made to our function again at the new time,
;; calculated by adding the current time plus the separation.
(defn play
  [time notes sep]
  (let [note (first notes)]
    (when note
      (at time (plucked-string note)))
    (let [next-time (+ time sep)]
      (apply-by next-time play [next-time (rest notes) sep]))))

;; play some pitches
(play (now) pitches 200)

;; cycle through some pitches
;; this will loop indefinitely.
(let [t (+ 500 (now))]
  (play t (cycle pitches) 100)
  (play t (cycle pitches) 102))

(stop)
#+END_SRC
** 
* Instruments
** (nsovertone.examples.instruments.dubstep
#+BEGIN_SRC clojure
(nsovertone.examples.instruments.dubstep
  (:use [overtone.core]))
#+END_SRC

#+BEGIN_SRC clojure

(defsynth dubstep [bpm 120 wobble 1 note 50 snare-vol 1 kick-vol 1 v 1 out-bus 0]
 (let [trig (impulse:kr (/ bpm 120))
       freq (midicps note)
       swr (demand trig 0 (dseq [wobble] INF))
       sweep (lin-exp (lf-tri swr) -1 1 40 3000)
       wob (apply + (saw (* freq [0.99 1.01])))
       wob (lpf wob sweep)
       wob (* 0.8 (normalizer wob))
       wob (+ wob (bpf wob 1500 2))
       wob (+ wob (* 0.2 (g-verb wob 9 0.7 0.7)))

       kickenv (decay (t2a (demand (impulse:kr (/ bpm 30)) 0 (dseq [1 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0] INF))) 0.7)
       kick (* (* kickenv 7) (sin-osc (+ 40 (* kickenv kickenv kickenv 200))))
       kick (clip2 kick 1)

       snare (* 3 (pink-noise) (apply + (* (decay (impulse (/ bpm 240) 0.5) [0.4 2]) [1 0.05])))
       snare (+ snare (bpf (* 4 snare) 2000))
       snare (clip2 snare 1)]

   (out out-bus    (* v (clip2 (+ wob (* kick-vol kick) (* snare-vol snare)) 1)))))

(comment
  ;;Control the dubstep synth with the following:
  (def d (dubstep))
  (ctl d :wobble 8)
  (ctl d :note 40)
  (ctl d :bpm 250)
  (stop)
  )


(comment
  ;;For connecting with a monome to control the wobble and note
  (require '(polynome [core :as poly]))
  (def m (poly/init "/dev/tty.usbserial-m64-0790"))
  (def notes (reverse [25 27 28 35 40 41 50 78]))
  (poly/on-press m (fn [x y s]
                   (do
                     (let [wobble (inc y)
                           note (nth notes x)]
                       (println "wobble:" wobble)
                       (println "note:" note)
                       (poly/clear m)
                       (poly/led-on m x y)
                       (ctl dubstep :wobble wobble)
                       (ctl dubstep :note note)))))
  (poly/disconnect m))

(comment
  ;;For connecting with a monome to drive two separate dubstep bass synths
  (do
    (require '(polynome [core :as poly]))
    (def m (poly/init "/dev/tty.usbserial-m64-0790"))
    (def curr-vals (atom {:b1 [0 0]
                          :b2 [5 0]}))
    (def curr-vol-b1 (atom 1))
    (def curr-vol-b2 (atom 1))

    (at (+ 1000 (now))
        (def b1 (dubstep))
        (def b2 (dubstep)))

    (defn swap-vol
      [v]
      (mod (inc v) 2))

    (defn fetch-note
      [base idx]
      (+ base (nth-interval :minor-pentatonic idx)))

    (defn relight
      []
      (poly/clear m)
      (apply poly/led-on m (:b1 @curr-vals))
      (apply poly/led-on m (:b2 @curr-vals)))

    (defn low-bass
      [x y]
      (println "low" [x y])
      (if (= [x y]
             (:b1 @curr-vals))
        (ctl b1 :v (swap! curr-vol-b1 swap-vol))
        (do
          (ctl b1 :wobble (inc x) :note (fetch-note 20 y))
          (swap! curr-vals assoc :b1 [x y])))
      (relight))

    (defn hi-bass
      [x y]
      (println "hi" [x y])
      (if (= [x y]
             (:b2 @curr-vals))
        (ctl b2 :v (swap! curr-vol-b2 swap-vol))
        (do
          (ctl b2 :wobble (- x 3) :note (fetch-note 40 y))
          (swap! curr-vals assoc :b2 [x y])))
      (relight))

    (poly/on-press m (fn [x y s]
                       (if (< x 4)
                         (apply #'low-bass [x y])
                         (apply #'hi-bass [x y]))))

    (poly/on-press m (fn [x y s]
                       (poly/toggle-led m x y))))
)

;;(stop)
#+END_SRC
** 
** (nsovertone.examples.instruments.external
:PROPERTIES:
:ID:       60552745-D635-4A59-859B-4B12D784EBE1
:END:
#+BEGIN_SRC clojure
(nsovertone.examples.instruments.external
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

; Depending on your audio setup (external interfaces, etc...) you might need
; to try a couple different buses before finding what you are looking for.
; Start at index zero and go upward.

(definst external
  []
  (sound-in 0))

; Start routing the external input to the mixer
(external)

; Checkout the built-in fx in overtone/studio/fx.clj

; add fx to an instrument chain with inst-fx
(inst-fx! external fx-distortion2)
(inst-fx! external fx-reverb)

; keep an fx instance id if you want to control it later
(def lowpass (inst-fx! external fx-rlpf))

; adjust the cutoff frequency by sending ctl messages to the fx synth
;(ctl lowpass :cutoff 10000)
;(ctl lowpass :cutoff 1000)
;(ctl lowpass :cutoff 100)

; remove all the fx
(clear-fx external)

; you can't remove or insert fx currently, so you have to clear and add them again
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.instruments.guitar-synth
#+BEGIN_SRC clojure
(nsovertone.examples.instruments.guitar-synth
  ^{:doc "Guitar from overtone.synth.stringed usage examples"
    :author "Roger Allen"}
  (:use [overtone.live]
        [overtone.synth.stringed]))
#+END_SRC

#+BEGIN_SRC clojure

;; ======================================================================
;; make a guitar
(def g (guitar))
;; strum it on your own
(guitar-strum g :E :down 0.25)
(guitar-strum g :E :up 0.75)
(guitar-strum g :B :down 0.25)
(guitar-strum g :A :up 0.5)
;; bow down to the power chord!
(ctl g :pre-amp 4.0 :distort 0.99)
(guitar-strum g [0 2 2 -1 -1 -1])
(guitar-strum g [3 5 5 -1 -1 -1])
;; mute all strings
(guitar-strum g [-1 -1 -1 -1 -1 -1])

;; ======================================================================
;; try out a bit of rhythmic accompanyment
;; http://www.youtube.com/watch?v=DV1ANPOYuH8
;; http://www.guitar.gg/strumming.html
(defn pattern-to-beat-strum-seq
  "given a string describing a one-measure up/down strum pattern like
  'ud-udu-', return a sequence of vector [beats :up/:down] pairs"
  [cur-pattern]
  (let [strums-per-measure (count cur-pattern)
        beats-per-measure 4.0
        beats-per-strum (/ beats-per-measure strums-per-measure)
        ud-keywords {\u :up, \d :down}]
    (for [[i s] (map-indexed vector cur-pattern)]
      (when (contains? ud-keywords s)
        [(* i beats-per-strum) (ud-keywords s)]))))
(defn strum-pattern [the-guitar metro cur-measure cur-chord cur-pattern]
  (let [cur-beat (* 4 cur-measure)]
    (doall
     (doseq [[b d] (pattern-to-beat-strum-seq cur-pattern)]
       (when-not (= b nil)
         (guitar-strum the-guitar cur-chord d 0.07 (metro (+ b cur-beat))))))))

;; play a variety of different rhythm patterns.
(ctl g :pre-amp 10.0 :amp 1.0 :distort 0.0)
(do ;; strumming practice
  (let [metro (metronome 100)]
    (doall
     (doseq [[i c] (map-indexed vector [:Gadd5 :Gadd5 :Cadd9 :Cadd9
                                        :Dsus4 :Dsus4 :Gadd5 :Cadd9
                                        :Gadd5 :Cadd9])]
       (strum-pattern g metro i c "d-du-ud-")))))
(do ;; knocking on heaven's door
  (let [metro (metronome 100)]
    (doall
     (doseq [[i c] (map-indexed vector [:Gadd5 :Dsus4 :Am :Am
                                        :Gadd5 :Dsus4 :Am :Am
                                        :Gadd5 :Dsus4 :Cadd9 :Cadd9])]
       (strum-pattern g metro i c "d-du-udu")))))
(do ;; 16th notes.
  (let [metro (metronome 90)]
    (doall
     (doseq [[i c] (map-indexed vector [:Gadd5 :Cadd9 :Gadd5 :Cadd9])]
       (strum-pattern g metro i c "d---d---dudu-ud-")))))

;; ======================================================================
;; ac/dc's highway to hell intro.  turn it up!
(defn ddd0 []
  (let [t (now) dt 250]
    (guitar-strum g [-1  0  2  2  2 -1] :down 0.01 (+ t (* 0 dt)))
    (guitar-strum g [-1  0  2  2  2 -1] :up   0.01 (+ t (* 1 dt)))
    (guitar-strum g [-1  0  2  2  2 -1] :down 0.01 (+ t (* 2 dt) 50))
    (guitar-strum g [-1 -1 -1 -1 -1 -1] :down 0.01 (+ t (* 3.5 dt)))))
(defn ddd1 []
  (let [t (now) dt 250]
    (guitar-strum g [ 2 -1  0  2  3 -1] :down 0.01 (+ t (* 0 dt)))
    (guitar-strum g [ 2 -1  0  2  3 -1] :up   0.01 (+ t (* 1 dt)))
    (guitar-strum g [ 3 -1  0  0  3 -1] :down 0.01 (+ t (* 2 dt) 50))
    (guitar-strum g [-1 -1 -1 -1 -1 -1] :down 0.01 (+ t (* 3.5 dt)))))
(defn ddd2 []
  (let [t (now) dt 250]
    (guitar-strum g [ 2 -1  0  2  3 -1] :down 0.01 (+ t (* 0 dt)))
    (guitar-strum g [-1 -1 -1 -1 -1 -1] :down 0.01 (+ t (* 1.5 dt)))
    (guitar-strum g [-1  0  2  2  2 -1] :down 0.01 (+ t (* 2 dt)))
    (guitar-strum g [-1  0  2  2  2 -1] :up   0.01 (+ t (* 3 dt)))
    (guitar-strum g [-1 -1 -1 -1 -1 -1] :down 0.01 (+ t (* 4.5 dt)))))
;; give us a good, crunchy sound
(ctl g :pre-amp 5.0 :distort 0.96
     :lp-freq 5000 :lp-rq 0.25
     :rvb-mix 0.5 :rvb-room 0.7 :rvb-damp 0.4)
(ddd0) ;; play once
(ddd1) ;; repeat 3 times
(ddd2) ;; play once

;; ======================================================================
;; play with the one chord progression to rule them all
;; The I - V - vi - IV
;; (or C - G - Am - F)
(ctl g :pre-amp 4.0 :distort 0.5 :noise-amp 1.0
     :lp-freq 4000 :lp-rq 2.0
     :rvb-mix 0.45 :rvb-room 0.4 :rvb-damp 0.9)
(defn play1 [metro k N chord-list]
   (dotimes [n N]
     (doseq [[i cur-chord] (map-indexed vector chord-list)]
       (let [cur-dir (choose [:up :down])
             cur-pattern (choose ["d-du-ud-"
                                  "d-du-udu"
                                  "d-d--udu"])]
         (strum-pattern g metro (+ k (* 4 n) i) cur-chord cur-pattern)))))
;; every pop song ever written.  :^)
(doall
 (let [metro (metronome 100)]
   (play1 metro 0 4 [:C :G :Am :F])))
;; okay, change it up a bit
(doall
 (let [metro (metronome 132)]
   (play1 metro 0 1 [:C :G :Am :F])
   (play1 metro 4 1 [:Am :F :C :G])
   (play1 metro 8 1 [:C :G :Am :F])
   (play1 metro 12 1 [:C :G :Em :C])
   ))
#+END_SRC
** 
** [#A] (nsovertone.examples.instruments.monotron
#+BEGIN_SRC clojure
(nsovertone.examples.instruments.monotron
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

;; (use 'overtone.live)

;; ======================================================================
;; Monotron Clone by Roger Allen.
;;   via some code in https://github.com/rogerallen/explore_overtone
;;
;; Source
;; http://korg.com/monotrons
;; http://korg.com/services/products/monotron/monotron_Block_diagram.jpg
;;
;; Following patterns from
;; https://github.com/overtone/overtone/blob/master/src/overtone/inst/synth.clj
;;
;; Inspiration
;; http://www.soundonsound.com/sos/aug10/articles/korg-monotron.htm
;; http://www.timstinchcombe.co.uk/index.php?pge=mono
(defsynth monotron
  "Korg Monotron from website diagram:
   http://korg.com/services/products/monotron/monotron_Block_diagram.jpg."
  [note     60            ; midi note value
   volume   0.7           ; gain of the output
   mod_pitch_not_cutoff 1 ; use 0 or 1 only to select LFO pitch or cutoff modification
   pitch    0.0           ; frequency of the VCO
   rate     4.0           ; frequency of the LFO
   int      1.0           ; intensity of the LFO
   cutoff   1000.0        ; cutoff frequency of the VCF
   peak     0.5           ; VCF peak control (resonance)
   pan      0             ; stereo panning
   ]
  (let [note_freq       (midicps note)
        pitch_mod_coef  mod_pitch_not_cutoff
        cutoff_mod_coef (- 1 mod_pitch_not_cutoff)
        LFO             (* int (saw rate))
        VCO             (saw (+ note_freq pitch (* pitch_mod_coef LFO)))
        vcf_freq        (+ cutoff (* cutoff_mod_coef LFO) note_freq)
        VCF             (moog-ff VCO vcf_freq peak)
        ]
    (out 0 (pan2 (* volume VCF) pan))))

;; ======================================================================
;; create an instance of the synth
(def N0 (monotron 40 0.8 1 0.0 2.5 350.0 800.0 3.0))

;; edit & C-x C-e on any these to play around
(ctl N0 :note   80)               ;; midi note value: 0 to 127
(ctl N0 :volume 0.7)              ;; gain of the output: 0.0 to 1.0
(ctl N0 :mod_pitch_not_cutoff 0)  ;; use 0 or 1 only to select LFO pitch or cutoff modification
(ctl N0 :pitch  10.0)             ;; this + note is frequency of the VCO
(ctl N0 :rate   1.5)              ;; frequency of the LFO
(ctl N0 :int    800.0)           ;; intensity of the LFO
(ctl N0 :cutoff 600.0)           ;; cutoff frequency of the VCF
(ctl N0 :peak   0.5)              ;; VCF peak control (resonance) 0.0 to 4.0

;; for when you're done.  kill all or just some of the notes
(kill N0)
#+END_SRC
** 
** (nsovertone.examples.instruments.pitch-controller
#+BEGIN_SRC clojure
(nsovertone.examples.instruments.pitch-controller
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

;; Fire off this synth and connect an instrument/mic.
;; The pitch will be detected and used to control the saw waves

(defsynth pitch-controlled-saws
  [out-bus 0]
  (let [p   (pitch (sound-in))
        p   (/ p 4)
        p   (lag p 1)]
    (out out-bus (saw [p (+ p (* p 0.01))]))))

;;(pitch-controlled-saws)
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.instruments.space
#+BEGIN_SRC clojure
(nsovertone.examples.instruments.space
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

;; Recipe from Mitchell Sigman (2011) Steal this Sound. Milwaukee, WI: Hal Leonard Books
;; Adapted from a translated version by Nick Collins

(defsynth space-theremin
  [out-bus 0
   freq 440
   amp 0.1
   gate 1
   lfo-rate 6
   lfo-width 0.5
   cutoff 4000
   rq 0.25
   lag-time 0.1
   pan 0]
  (let [lfo    (lf-tri:kr (+ lfo-rate (mul-add (lf-noise1:kr 5) 0.3 0.3)) (rand 2))
        osc    (* 0.5 (saw (midicps (+ (cpsmidi (lag freq lag-time))
                                       (* lfo lfo-width)))))
        filter (b-low-pass4 osc (lag cutoff (* lag-time 4)) rq)
        env    (env-gen:ar (adsr 0.6 0 1 0.05) gate FREE)]
    (out out-bus (pan2 (* filter env (lag amp (* 4 lag-time))) pan))))



(defsynth space-reverb
  [out-bus 0
   in-bus 0
   gate 1
   threshold 0.1
   amp 0.1]
  (let [env             (linen gate 0.1 1 0.1 FREE)
        num-combs       6
        num-allpass     4
        src             (in in-bus 2)
        reverb-predelay (delay-n src 0.048 0.048)
        y               (mix (repeat num-combs (comb-l reverb-predelay 0.1 (ranged-rand 0.01 0.1) 5)))
        y               (loop [cnt num-allpass
                               res y]
                          (if (<= cnt 0)
                            res
                            (recur (dec cnt)
                                   (allpass-n res
                                              0.051
                                              [(ranged-rand 0.01 0.05)
                                               (ranged-rand 0.01 0.05)]
                                              1))))]
    (out out-bus (* env amp (pan2 y)))))

;;(def st (space-theremin :out-bus 10 :amp 0.8 :cutoff 1000))
;;(space-reverb [:after st] :in-bus 10)
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.instruments.thx
#+BEGIN_SRC clojure
(nsovertone.examples.instruments.thx
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

;;Original THX sound simulation by Geirmund Simonsen:
;;{
;;        var randomFreq, ampEnv, riseCurve, doAdder, doArray;
;;        doAdder = 0;
;;        doArray = [77, 74, 72, 70, 65, 62, 60, 58, 53, 50, 46, 34].midicps;
;;        randomFreq = EnvGen.kr(Env([1,1,0.007], [8, 6], [0, -4]), 1);
;;        ampEnv = EnvGen.kr(Env([0.07,0.07,0.21], [8, 6], [0, 1]), 1);
;;        doArray.do({ |item| doAdder = Pan2.ar(Saw.ar((LFNoise2.kr(1.3, 100, 230)*randomFreq) +
;;              EnvGen.kr(Env([0,0,item],[8, 6], [0, -3]), 1)), LFNoise2.kr(1.3)) + doAdder; });
;;        Out.ar(0, doAdder*ampEnv);
;;}.play

(defsynth thx [gate 1 amp 1 out-bus 0]
  (let [target-pitches (map midi->hz [77 74 72 70 65 62 60 58 53 50 46 34 26 22 14 10])
        r-freq         (env-gen:kr (envelope [1 1 0.007 10] [8 4 2] [0 -4 1] 2) gate)
        amp-env        (env-gen:kr (envelope [0 0.07 0.21 0] [8 4 2] [0 1 1] 2) gate :action FREE)
        mk-noise       (fn [ug-osc]
                         (mix (map #(pan2 (ug-osc (+ (* r-freq (+ 230 (* 100 (lf-noise2:kr 1.3))))
                                                     (env-gen:kr (envelope [0 0 %] [8 6] [0 -3]))))
                                          (lf-noise2:kr 5))
                                   target-pitches)))
        saws           (mk-noise saw)
        sins           (mk-noise sin-osc)
        snd            (+ (* saws amp-env) (* sins amp-env))]
    (out out-bus
         (* amp (g-verb snd 9 0.7 0)))))

;; play the instrument:
;; (def t (thx :amp 2))
;; kill it off when you're ready
;; (ctl t :gate 0)
#+END_SRC
** 
** (nsovertone.examples.instruments.vocoder
#+BEGIN_SRC clojure
(nsovertone.examples.instruments.vocoder
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

(def a (buffer 2048))
(def b (buffer 2048))

(demo 10
      (let [input  (sound-in) ; mic
            src    (white-noise) ; synth - try replacing this with other sound sources
            formed (pv-mul (fft a input) (fft b src))
            audio  (ifft formed)]
        (pan2 (* 0.1 audio))))
#+END_SRC
** 
* MIDI
** (nsovertone.examples.midi.basic
#+BEGIN_SRC clojure
(nsovertone.examples.midi.basic
  (:use [overtone.live]
        [overtone.synth.sts :only [prophet]]))
#+END_SRC

#+BEGIN_SRC clojure

;; Now, we know we can trigger synths manually with code:

(prophet :freq 110 :decay 5 :rq 0.6 :cutoff-freq 2000)
(prophet :freq 130 :decay 5 :rq 0.6 :cutoff-freq 2000)

;; It's super easy to trigger synths with attached MIDI devices using
;; Overtone's event system. By default all note-making MIDI devices will
;; emit a [:midi :note-on] event. Make sure you attach a MIDI piano-like
;; device *before* booting Overtone and the following will work:

(on-event [:midi :note-on]
          (fn [m]
            (let [note (:note m)]
              (prophet :freq (midi->hz note)
                       :decay 5
                       :rq 0.6
                       :cutoff-freq 1000)))
          ::prophet-midi)

;; You also have access to velocity information:

(on-event [:midi :note-on]
          (fn [m]
            (let [note (:note m)]
              (prophet :freq (midi->hz note)
                       :decay 5
                       :rq 0.6
                       :cutoff-freq 1000
                       :amp (:velocity-f m))))
          ::prophet-midi)

;; To see all the information passed to the event system:

(on-event [:midi :note-on]
          (fn [m]
            (println (type (:velocity-f m))))
          ::midi-debug)

;; We can remove our event handlers with:

(remove-event-handler ::prophet-midi)
(remove-event-handler ::midi-debug)

;; Useful keys are:
;;
;; * :note (MIDI note)
;; * :timestamp
;; * :velocity (MIDI value i.e. 0->127)
;; * :velocity-f (float 0->1)

;; We can also easily receive note off events with the event key [:midi
;; :note-off]. So, if we have a gated synth that we want to sustain
;; whilst we hold the MIDI key down, this is pretty easy to build.
;; First, let's define a suitable synth:

(defsynth pad1 [freq 110 amp 1 gate 1 out-bus 0]
  (out out-bus
       (* (saw [freq (* freq 1.01)])
          (env-gen (adsr 0.01 0.1 0.7 0.5) :gate gate :action FREE))))


;; Of course, we could also build a more sophisticated synth with the
;; same properties:

(defsynth pad2 [freq 440 amp 0.4 amt 0.3 gate 1.0 out-bus 0]
  (let [vel        (+ 0.5 (* 0.5 amp))
        env        (env-gen (adsr 0.01 0.1 0.7 0.5) gate 1 0 1 FREE)
        f-env      (env-gen (perc 1 3))
        src        (saw [freq (* freq 1.01)])
        signal     (rlpf (* 0.3 src)
                         (+ (* 0.6 freq) (* f-env 2 freq)) 0.2)
        k          (/ (* 2 amt) (- 1 amt))
        distort    (/ (* (+ 1 k) signal) (+ 1 (* k (abs signal))))
        gate       (pulse (* 2 (+ 1 (sin-osc:kr 0.05))))
        compressor (compander distort gate 0.01 1 0.5 0.01 0.01)
        dampener   (+ 1 (* 0.5 (sin-osc:kr 0.5)))
        reverb     (free-verb compressor 0.5 0.5 dampener)
        echo       (comb-n reverb 0.4 0.3 0.5)]
    (out out-bus
         (* vel env echo))))

;; We can trigger our synth like this:

(def pad-s (pad2))

;; and kill it by cutting off the gate (thus completing the envelope):

(ctl pad-s :gate 0)

;; We can easily trigger this with our Keyboard

;; Create a map to store the note/proc-number tuples so we can
;; switch off the correct note when a note-off is recieved

(defonce memory (agent {}))

(on-event [:midi :note-on]
          (fn [m]
            (send memory
                  (fn [mem]
                    (let [n (:note m)
                          s (pad2 :freq (midi->hz n))]
                      (assoc mem n s)))))
          ::play-note)

(on-event [:midi :note-off]
          (fn [m]
            (send memory
                  (fn [mem]
                    (let [n (:note m)]
                      (when-let [s (get mem n)]
                        (ctl s :gate 0))
                      (dissoc mem n))))
)
          ::release-note)


;; And again for tidiness:

(remove-event-handler ::play-note)
(remove-event-handler ::release-note)

;; See overtone.examples.midi.keyboard for a built-in way of achieving
;; exactly this behaviour.


;; So, what if you have multiple MIDI devices capable of generating note
;; on and off events? Clearly the approach above won't work. Luckily,
;; we've got you covered.

;; All attached MIDI devices are registered when Overtone booted.
;; You can look at the list of attached devices with:

(midi-connected-devices)

;; The MIDI devices are not guaranteed to be registered in the same
;; order every time you boot Overtone, so you can't rely on the index of
;; the device you want to be consistent. However, you can search for
;; your device usign a string or regexp. For example, the following
;; finds my Korg nanoKEY2 keyboard:

(def nk (midi-find-connected-device "nanoKEY2"))

;; If I happen to have more than one Kort nanoKEY2 keyboard, I can
;; search for them all with:

(def nks (midi-find-connected-devices "nanoKEY2"))

;; Once I have my device, I can find the unique key that Overtone's
;; event system uses to manage events from the MIDI device:

(midi-mk-full-device-key nk)
;;=> [:midi-device "KORG INC." "KEYBOARD" "nanoKEY2 KEYBOARD" 0]

;; our note on and off events are also sent with this unique device
;; id. All you need to do is append either :note-on or :note-off. The
;; following code will only work with a connected nanoKEY2 device:

(on-event (conj (midi-mk-full-device-key nk) :note-on)
          (fn [m]
            (let [note (:note m)]
              (prophet :freq (midi->hz note)
                       :decay 5
                       :rq 0.6
                       :cutoff-freq 1000)))
          ::prophet-midi)

(remove-event-handler ::prophet-midi)

;; In addition to :note-on and :note-off, other available midi events
;; are:
;; * :channel-pressure
;; * :control-change
;; * :pitch-bend
;; * :poly-pressure
;; * :program-change

;; Enjoy playing notes with your MIDI devices!
#+END_SRC
** 
** (nsovertone.examples.midi.keyboard
#+BEGIN_SRC clojure
(nsovertone.examples.midi.keyboard
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

(definst ding
  [note 60 velocity 100]
  (let [freq (midicps note)
        snd  (sin-osc freq)
        env  (env-gen (perc 0.1 0.8) :action FREE)]
    (* velocity env snd)))

(defn midi-player [event]
  (ding (:note event) (/ (:velocity event) 127.0)))

; Calling midi-in without any arguments will bring up a swing dialog to choose
; from available midi devices.  Note that Java does not seem to detect midi devices
; after JVM startup (at least on OSX), so you USB midi device will need to be connected
; before starting Overtone.

; (def keyboard (midi-in))

; The low level midi handler mechanism from midi-clj uses midi-handle-events,
; which takes a device ; and a midi player function that will receive midi
; event maps.

;(midi-handle-events keyboard #'midi-player)

; overtone.studio.midi now includes the beginnings of a higher level midi interface
; that helps improve on this.  By default Overtone will detect and listen to all
; midi input devices.  These midi messages are then sent as events, which can be received
; with the Overtone event system.

; For example, print out all incoming note-on messages:

;(on-event [:midi :note-on] (fn [{note :note velocity :velocity}]
;                             (println "Note: " note ", Velocity: " velocity))
;          ::note-printer)

;(remove-event-handler ::note-printer)

; Other available midi events are:
; * :channel-pressure
; * :control-change
; * :note-off
; * :note-on
; * :pitch-bend
; * :poly-pressure
; * :program-change

; In order to play instruments that continue playing until a key is released,
; we need to keep track of each active synth instance once triggered by :note-on,
; and then send a control message to either kill it or close the gate on an
; envelope so the release starts.  This is what overtone.studio.midi/midi-poly-player
; does for you.  All it requires is that you have exposed an envelope gate as a synth
; parameter called "gate".

(definst poly-ding
  [note 60 amp 1 gate 1]
  (let [freq (midicps note)
        snd  (sin-osc freq)
        env  (env-gen (adsr 0.001 0.1 0.6 0.3) gate :action FREE)]
    (* amp env snd)))

; Create a polyphonic midi player:
;(def ding-player (midi-poly-player poly-ding))

; and stop it:
;(midi-player-stop ding-player)
#+END_SRC
** 
* Monome
** (ns^:hw overtone.examples.monome.monomestep
#+BEGIN_SRC clojure
(ns^:hw overtone.examples.monome.monomestep
  (:use [overtone.live]
        [clojure.core.match :only [match]]
        [polynome.core :as poly]))
#+END_SRC

#+BEGIN_SRC clojure

(defonce dub-vol (atom 1))

(definst dubstep [note 40 wob 2 hi-man 0 lo-man 0 sweep-man 0 deci-man 0 tan-man 0 shape 0 sweep-max-freq 3000 hi-man-max 1000 lo-man-max 500 beat-vol 0 amp 1]
  (let [bpm 300
        shape (select shape [(lf-tri wob) (lf-saw wob)])
        sweep (lin-exp shape -1 1 40 sweep-max-freq)
        snd   (mix (saw (* (midicps note) [0.99 1.01])))
        snd   (lpf snd sweep)
        snd   (normalizer snd)

        snd   (+ snd (bpf snd 1500 2))
        ;;special flavours
        ;;hi manster
        snd   (select (> hi-man 0.05) [snd (* 4 (hpf snd hi-man-max))])

        ;;sweep manster
        snd   (select (> sweep-man 0.05) [snd (* 4 (hpf snd sweep))])

        ;;lo manster
        snd   (select (> lo-man 0.05) [snd (lpf snd lo-man-max)])

        ;;decimate
        snd   (select (> deci-man 0.05) [snd (round snd 0.1)])

        ;;crunch
        snd   (select (> tan-man 0.05) [snd (tanh (* snd 5))])

        snd   (* 0.5 (+ (* 0.8 snd) (* 0.3 (g-verb snd 100 0.7 0.7))))

               kickenv (decay (t2a (demand (impulse:kr (/ bpm 30)) 0 (dseq [1 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0] INF))) 0.7)
       kick (* (* kickenv 7) (sin-osc (+ 40 (* kickenv kickenv kickenv 200))))
       kick (clip2 kick 1)

       snare (* 3 (pink-noise) (apply + (* (decay (impulse (/ bpm 240) 0.5) [0.4 2]) [1 0.05])))
       snare (+ snare (bpf (* 4 snare) 2000))
        snare (clip2 snare 1)
       beat (* beat-vol (+ kick snare))
        ]
    (* amp (+ (pan2 snd shape) beat))))

(def m (poly/init "/dev/tty.usbserial-m64-0790"))
;;(def m beatbox.core/m)
;;(poly/disconnect m)
(poly/remove-all-callbacks m)

(def id->dub-ctl {0 :hi-man
                  1 :lo-man
                  2 :deci-man
                  3 :tan-man
                  4 :beat-vol})

(defn toggle-vol
  []
  (ctl dubstep :amp (swap! dub-vol #(mod (inc %) 2))))

(defn toggle-fx
  [x y]
  (when-let [ctl-name (get id->dub-ctl y)]
    (poly/toggle-led m x y)
    (let [val (poly/led-activation m x y)]
      (ctl dubstep ctl-name val))))

(defn modulate-pitch-wob
  [x y]
  (let [wob x
        note (nth (scale :g1 :minor-pentatonic) y)]
    (ctl dubstep :note note)
    (ctl dubstep  :wob wob)))

(poly/on-press m ::foo (fn [x y s]
                         (match [x y]
                           [0 7] (toggle-vol)
                           [0 _] (toggle-fx x y)
                           [_ _] (modulate-pitch-wob x y))))

(dubstep)
;;(stop)
(comment

  (ctl dubstep :lo-man-max 1000)
  (ctl dubstep :hi-man-max 400)
  (ctl dubstep :sweep-max-freq 3000)
  (ctl dubstep :note 30)
  (stop)
  )
;;(poly/disconnect m)
#+END_SRC
** 
** (ns^:hw overtone.examples.monome.sample-looper
#+BEGIN_SRC clojure
(ns^:hw overtone.examples.monome.sample-looper
  (:use [overtone.live])
  (:require [polynome.core :as poly]))
#+END_SRC

#+BEGIN_SRC clojure

;;design a sc synth to play the samples
(definst loop-synth [buf 0 amp 1 rate 1]
  (let [src (play-buf 1 buf rate 1.0 0.0 1.0 1)]
    (* src amp)))

;;change m to point to your monome (use dummy if you don't have one...)
(defonce m (poly/init "/dev/tty.usbserial-m64-0790"))
;;(def m (poly/init "/dev/tty.usbserial-m128-115"))
;;(def m (poly/init "dummy"))

;;(defonce samples (load-samples "assets/*.{aif,AIF,wav,WAV}"))
(def samples (load-samples "~/Desktop/tech/*.wav"))

(defn start-samples
  "Starts all samples playing at init-vol. Returns a seq containing info
  regarding all running samples. Samples start playing 1s after the this
  fn is called to ensure that they're all started in sync"
  []
  (at (+ 1000 (now))
      (doall
       (reduce (fn [res samp]
                 (let [id (loop-synth samp 0)]
                   (conj res  {:ampl 0
                               :id id
                               :samp samp})))
               []
               samples))))

(def playing-samples* (agent (start-samples)))

(defn reset-samples!
  []
  (send playing-samples*
        (fn [playing-samples]
          (doall (map #(kill (:id %)) playing-samples))
          (poly/clear m)
          (start-samples))))

(defn toggle
  "Invert the vol from 1 to 0 or 0 to 1"
  [amp]
  (mod (inc amp) 2))

(defn toggle-sample
  [n]
  (if (< n (count @playing-samples*))
      (send playing-samples* (fn [playing-samples]
                           (let [samp     (nth playing-samples n)
                                 id       (:id samp)
                                 new-vol  (toggle (:amp samp))
                                 new-samp (assoc samp :amp new-vol)]
                             (ctl id :amp new-vol)
                             (assoc playing-samples n new-samp))))
      false))

(defn trigger
  "Invert the volume for the loop corresponding to the given x y coords. Also
   update the associated agent's state and monome LED state."
  [x y]
  (when (toggle-sample (poly/button-id m x y))
    (poly/toggle-led m x y)))


(poly/on-press m (fn [x y s] (trigger x y)))

(def rate* (atom 1))

(defn tempo-slide [to]
  (let [from @rate*
        step (if (< from to) 0.01 -0.01)
        vals (range from to step)]
    (dorun (map #(do (ctl loop-synth :rate (reset! rate* %)) (Thread/sleep 35)) vals))))

;;(tempo-slide  2)
;;(volume 1.5)
;;(reset-samples!)
;;(trigger 1 1)
;;(poly/remove-all-callbacks m)
;;(poly/disconnect m)
#+END_SRC
** 
** (ns^:hw overtone.examples.monome.satie
#+BEGIN_SRC clojure
(ns^:hw overtone.examples.monome.satie
  (:use [clojure.core.match :only [match]]
        [overtone.live]
        [overtone.inst sampled-piano])
  (:require [polynome.core :as poly]))
#+END_SRC

#+BEGIN_SRC clojure

;;Erik Satie Gnossienne No. 1
(def phrase1a [:iii :v :iv# :iii :iii :ii# :iii :ii#])
(def phrase1b [:iii :v :iv# :iii :v# :vi :v# :vi])
(def phrase1c [:iii :v :iv# :iii :iii :ii# :i :vii- :vi- :vii- :vi- :vii- :i :vii- :vii- :vi-])

(def phrase2 [:i :ii :i :vii- :i :ii :i :vii- :i :vii- :vii- :vi-])

(def phrase3 [:iii :iv# :v# :vi :vii :ii#+ :vii :vi :vii :vi :vii :vi :vi :v# :iv :iii :iii :ii# :i :vii- :vii- :vi-])

(def phrase1a-reprise [:iii :v :iv# :iii :iii :ii#])
(def phrase1b-reprise [:iii :v :iv# :iii :v# :vi])

(def phrase1-bass [:vi--- [:vi- :iii- :i-] [:vi- :iii- :i-]])
(def phrase2-bass [:iii-- [:iii- :vii-- :v--] [:iii- :vii-- :v--]])

(def phrase3-bass [:ii--- [:vi-- :ii- :iv-] [:vi-- :ii- :iv-]])


(def right-hand-degrees (concat phrase1a phrase1b phrase1c
                                phrase1a phrase1b phrase1c
                                phrase2
                                phrase2
                                phrase3
                                phrase3
                                phrase2
                                phrase2
                                phrase1a-reprise
                                phrase1b-reprise
                                phrase1a-reprise
                                phrase1b-reprise
                                phrase2
                                phrase2
                                phrase3
                                phrase3
                                phrase2
                                phrase2))


(def left-hand-degrees (concat (apply concat (repeat 6 phrase1-bass))  ;;A
                               phrase2-bass                            ;;B
                               (apply concat (repeat 8 phrase1-bass))  ;;C
                               phrase2-bass                            ;;D
                               (apply concat (repeat 2 phrase1-bass))  ;;E
                               (apply concat (repeat 2 phrase3-bass))  ;;F
                               (apply concat (repeat 2 phrase1-bass))  ;;G
                               (apply concat (repeat 2 phrase3-bass))  ;;H
                               (apply concat (repeat 14 phrase1-bass)) ;;I
                               (apply concat (repeat 2 phrase3-bass))  ;;J
                               (apply concat (repeat 2 phrase1-bass))  ;;K
                               (apply concat (repeat 2 phrase3-bass))  ;;L
                               (apply concat (repeat 10 phrase1-bass)) ;;M
                               (apply concat (repeat 2 phrase3-bass))  ;;N
                               (apply concat (repeat 2 phrase1-bass))  ;;O
                               (apply concat (repeat 2 phrase3-bass))  ;;P
                               (apply concat (repeat 14 phrase1-bass)) ;;Q
                               (apply concat (repeat 2 phrase3-bass))  ;;R
                               (apply concat (repeat 2 phrase1-bass))  ;;S
                               (apply concat (repeat 2 phrase3-bass))  ;;T
                               phrase1-bass                            ;;U
                               ))

(def lh-pitches (degrees->pitches left-hand-degrees :major :Ab4))
(def rh-pitches (degrees->pitches right-hand-degrees :major :Ab4))

(def cur-pitch-rh (atom -1))
(def cur-pitch-lh (atom -1))

(defn reset-pos
  []
  (reset! cur-pitch-rh -1)
  (reset! cur-pitch-lh -1))

(defn vol-mul
  [amp]
  (* amp 0.002))

(defn play-next-rh
  [amp]
  (let [idx (swap! cur-pitch-rh inc)
        pitch (nth (cycle rh-pitches) idx)]
    (sampled-piano pitch (vol-mul amp))))

(defn play-next-lh
  [amp]
  (let [idx (swap! cur-pitch-lh inc)
        pitch (nth (cycle lh-pitches) idx)]
    (if (sequential? pitch)
      (doseq [p pitch]
        (sampled-piano p (vol-mul amp)))
      (sampled-piano pitch (vol-mul amp)))))

(defonce m (poly/init "/dev/tty.usbserial-m64-0790"))

(poly/on-press m (fn [x y s]
                   (match [x y]
                          [7 _] (reset-pos)
                          [_ 0] (play-next-lh (+ (rand-int 5) (* 12 (+ x 4))))
                          [_ 7] (play-next-rh (+ (rand-int 5) (* 12 (+ x 4)))))))

;;(poly/remove-all-callbacks m)
;;(poly/disconnect m)
#+END_SRC
** 
* Notation
** (nsovertone.examples.notation.mad
#+BEGIN_SRC clojure
(nsovertone.examples.notation.mad
  (:use overtone.live
        overtone.inst.synth))
#+END_SRC

#+BEGIN_SRC clojure

; Adapted from the music as data project, cool stuff!
; http://mad.emotionull.com/

(definst tone [note 60 amp 0.3 dur 0.4]
  (let [snd (sin-osc (midicps note))
        env (env-gen (perc 0.01 dur) :action FREE)]
    (* env snd amp)))

(defn p
  ([elements]
   (p elements (now)))
  ([[{:keys [synth amp pitch dur data]} & elements] t]
   (let [next-t (+ t (int (* 1000 dur)))]
     (at t
         (synth pitch amp dur))
     (when elements
       (apply-by next-t #'p elements [next-t])))))

(declare calc-duration)

(defn pattern
  ([m-element] (pattern m-element 1))
  ([m-element duration]
   (if (= (type []) (type m-element))
     (flatten
       (calc-duration m-element duration (count m-element)))
     (assoc m-element :dur (float duration)))))

(defn calc-duration
  [elements duration count]
  (map #(pattern % (/ duration count))
       elements))

(defn defnote
  [n-sym pitch]
  (intern *ns* n-sym
          {:synth tone
           :amp 0.2
           :pitch pitch
           :dur 0.1
           :data []}))

(defn def-notes
  "Define vars for all notes."
  []
  (doseq [octave (range 8)]
    (doseq [n (range 7)]
      (let [n-char (char (+ 65 n))
            n-sym (symbol (str n-char octave))
            note (octave-note octave (get NOTES (keyword (str n-char))))]
        (defnote n-sym note)
        (when-let [sharp (get NOTES (keyword (str n-char "#")))]
          (defnote (symbol (str n-char "#" octave))
                   (octave-note octave sharp)))
        (when-let [flat (get NOTES (keyword (str n-char "b")))]
          (defnote (symbol (str n-char "b" octave))
                   (octave-note octave flat)))))))

(def-notes)

(def derezzed [[E4 G4 E4] [E5 B4 G4 D4 A4 E4 G4 A4]])

;; run this to play the pattern
;; (p (pattern derezzed 2))

;; or this to play it forever
;; (p (cycle (pattern derezzed 2)))

;; before you stop, add some reverb
;; (inst-fx! tone fx-reverb)

;; call stop to kill the loop
;; (stop)

;; try it slow with an echo effect
;; (inst-fx! tone fx-echo)
;;( p (cycle (pattern derezzed 6)))

;; clear the fx for this instrument like so
;;(clear-fx tone)

;;(stop)


;; uncomment this one and move the mouse around
(comment (p (cycle (map
            #(assoc % :synth ks1-demo)
            (pattern derezzed 2))))
         )

;; throw some distortion on there
;; (inst-fx! ks1-demo fx-distortion)

;; Clear fx
;; (clear-fx ks1-demo)

;; (stop)

;; Ok, now try this one slow, and add the echo effect
(comment
  (p (cycle (map
            #(assoc % :synth ks1-demo)
            (pattern derezzed 4)))))
;;(inst-fx! ks1-demo fx-echo)

(comment
  (p (cycle
     (map
       #(assoc % :pitch (- (:pitch %) 24))
     (map
       #(assoc % :synth grunge-bass)
       (pattern derezzed 2)))))
  )

;(stop)

; Bach - Minuet in G Major
; Go here for the sheet music:
;; http://www.sheetmusic1.com/new.great.music/bach.minuet.gmajor/bach.1.demo.gif
;; http://www.sheetmusic1.com/new.great.music/bach.minuet.gmajor/bach.2.demo.gif
(def g-minuet-right-hand [[D5 D5 D5]
                         [B4 [A4 B4] G4]
                         [A4 D5 C5]
                         [B4 B4 A4] ; NOTE: two B4's should be tied together
                         [D5 [C5 B4] [A4 G4]]
                         [E5 [C5 B4] [A4 G4]]
                         [F#4 [E4 D4] F#4]
                         [G4]
                         [B4 E5 E5]
                         [C#5 [B4 C5] A4]
                         [D5 E5 F5]
                         [[E5 D5] [C#5 B4] A4]

                         [A6 [G5 F#5 E5 D5]]
                         [B6 [G5 F#5 E5 D5]]
                         [C#5 A5 C#5]
                         [D5]
                         [D5 [C5 B5] A5]
                         [B5 [A5 B5] [G4]]
                         [C5 C5 [C5 B5]]
                         [A5]
                         [D5 [C5 B5 A5 G4]]
                         [E5 [C5 B5 A5 G4]]
                         [F#4 [E4 D4] F#4]
                         [G4]])

(def g-minuet-left-hand [[G3 F#3 D3]
                        [G3 D3 G2]
                        [G3 [F#3 E3] [F#3 D3]]
                        [G3 G2 [D3 C3]]
                        [B2]
                        [C3]
                        [D3]
                        [G2]
                        [G3 G3 E3]
                        [A3 E3 A2]
                        [F#3 E3 D3]
                        [A2 E3 [A4 G3]]

                        [F#3]
                        [G3]
                        [A4 A4 A3]
                        [D3 [D4 C4 B4 A4]]
                        [G3 G3 F#3]
                        [G3 D3 G2]
                        [A4 F#3 G3]
                        [D3 D2 [D3 C3]]
                        [B3]
                        [C3]
                        [D3 D3 D2]
                        [G3]])

(comment
  (do
  (p (map
       #(assoc % :synth ks1-demo)
       (pattern g-minuet-left-hand 25)))

  (p (map
       #(assoc % :synth ks1-demo)
       (pattern g-minuet-right-hand 25))))
  )


;; Grrrrrrr! ;-)
;;(inst-fx! ks1-demo fx-distortion)
;;(clear-fx ks1-demo)

(defn glp
  [t]
  (map
    #(assoc % :synth ks1-demo)
    (pattern g-minuet-left-hand t)))

(defn grp
  [t]
  (map
    #(assoc % :synth ks1-demo)
    (pattern g-minuet-right-hand t)))

(defn transpose
  [pat shift]
  (map #(assoc % :pitch (+ (:pitch %) shift)) pat))

; Bach would have had a blast :-)
(comment
(do
    (p (concat
        (glp 20)
        (reverse (glp 20))
        (transpose (glp 20) 4)
        (glp 20)
        ))
    (p (concat
        (grp 20)
        (transpose (reverse (grp 20)) -12)
        (grp 20)
        (grp 20)
        )))
  )
#+END_SRC
** 
** (nsovertone.examples.notation.mad2
#+BEGIN_SRC clojure
(nsovertone.examples.notation.mad2
  (:use overtone.live
        overtone.inst.synth))
#+END_SRC

#+BEGIN_SRC clojure

(definst tone [note 60 amp 0.3 dur 0.4]
  (let [snd (sin-osc (midicps note))
        env (env-gen (perc 0.01 dur) :action FREE)]
    (* env snd amp)))

(defn defpitch
  [p-sym pitch]
  (intern *ns* p-sym pitch))

(defn def-pitches
  "Define vars for all pitches."
  []
  (doseq [octave (range 8)]
    (doseq [n (range 7)]
      (let [n-char (char (+ 97 n))
            p-sym (symbol (str n-char octave))
            note (octave-note octave (get NOTES (keyword (str n-char))))]
        (defpitch p-sym note)
        (when-let [sharp (get NOTES (keyword (str n-char "#")))]
          (defpitch (symbol (str n-char "#" octave))
                    (octave-note octave sharp)))
        (when-let [flat (get NOTES (keyword (str n-char "b")))]
          (defpitch (symbol (str n-char "b" octave))
                    (octave-note octave flat)))))))

(def-pitches)

(defn i2p
  "Convert intervals to pitches.  Supports nested collections as well."
  [intervals scale root]
  (map (fn [i]
         (cond
           (coll? i) (i2p i scale root)
           (nil? i) nil
           :default (+ root (degree->interval i scale))))
       intervals))

(defn play-over
  "Play a sequence of notes starting at t over a fixed duration of time.
  Note: both t and dur are in milliseconds."
  [inst notes t dur]
  (let [interval (/ dur (count notes))]
    (doall
      (map-indexed
        (fn [idx pitch]
          (let [cur-t (+ t (* idx interval))]
            (cond
              (coll? pitch)
              (play-over inst pitch cur-t interval)

              (number? pitch)
              (at cur-t
                  (inst pitch 0.8 (/ interval 1000.0))))))
        notes))))

(defn play
  "Play bars of notes on an instrument with a metronome."
  [inst bars m & [t-sig]]
  (when bars
    (let [t-sig (or t-sig 4)
          beats-per-bar t-sig ; (numerator t-sig)
          ms-per-bar (- (m beats-per-bar) (m 0))
          bar (first bars)
          beat (m)
          bar-start (m beat)]
      (play-over inst bar bar-start ms-per-bar)
      (apply-by (m (+ beat beats-per-bar)) #'play [inst (next bars) m t-sig]))))

(def metro (metronome 120))

;[[e4 g4 e4] [e5 b4 g4 d4 a4 e4 g4 a4]], the derezzed example, could be:
;in an aeolian scale, starting on E4.
(def _ nil)
(def derez [[:i :iii :i] [:i* :v :iii :vii :iv. :i :iii :iv]])
(def pitches (i2p derez :aeolian e4))

;(play tone pitches metro)

(comment

  (play ks1-demo (i2p [[:i [:v _ :v] :i] [:i [:i :iv] :i _ :v _ :i]] :diatonic f4) metro)

  (do
    (play grunge-bass
          (cycle (i2p [[:i [:v _ :v] :i] [:i [:i :iv] :i _ :v _ :i]]
                      :diatonic f2))
          metro)

    (play pad
          (cycle (i2p [[:i [:v _ :v] :i] [:i [:i :iv] :i _ :v _ :i]]
                      :diatonic f3))
          metro))
)
;; (stop)
#+END_SRC
** 
* synthesis
** (nsovertone.examples.synthesis.cgen-example
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.cgen-example
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

(defcgen kick-drum
  "basic synthesised kick drum"
  [bpm {:default 120 :doc "tempo of kick in beats per minute"}
   pattern {:default [1 0] :doc "sequence pattern of beats"}]
  (:ar
   (let [kickenv (decay (t2a (demand (impulse:kr (/ bpm 30)) 0 (dseq pattern INF))) 0.7)
         kick (* (* kickenv 7) (sin-osc (+ 40 (* kickenv kickenv kickenv 200))))]
     (clip2 kick 1))))


(defcgen snare-drum
  "basic synthesised snare drum"
  [bpm {:default 120 :doc "tempo of snare in beats per minute"}]
  (:ar
   (let [snare (* 3 (pink-noise) (apply + (* (decay (impulse (/ bpm 240) 0.5) [0.4 2]) [1 0.05])))
         snare (+ snare (bpf (* 4 snare) 2000))]
     (clip2 snare 1))))


(defcgen wobble
  "wobble an input src"
  [src {:doc "input source"}
   wobble-factor {:doc "num wobbles per second"}]
  (:ar
   (let [sweep (lin-exp (lf-tri wobble-factor) -1 1 40 3000)
         wob   (lpf src sweep)
         wob   (* 0.8 (normalizer wob))
         wob   (+ wob (bpf wob 1500 2))]
     (+ wob (* 0.2 (g-verb wob 9 0.7 0.7))))))


(definst dubstep [bpm 120 wobble-factor 1 note 50]
 (let [freq (midicps (lag note 0.25))
       bass (apply + (saw (* freq [0.99 1.01])))
       bass (wobble bass wobble-factor)
       kick (kick-drum bpm :pattern [1 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0])
       snare (snare-drum bpm)]

   (clip2 (+ bass kick snare) 1)))

;;(dubstep)
;;(ctl dubstep :wobble-factor 3)
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.synthesis.deci-wobble
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.deci-wobble
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

;; Adapted from the Decimator Wobble Bass described here:
;; http://www.phrontist.org/2010/06/decimator-wobble-bass/

(defsynth deci-wobble []
  (let [temp-freq (/ 140 60 3)
        trig      (impulse temp-freq)
        note      (demand trig 0 (dseq [40 43 47 47 40 37 43 28] INF))
        note      (slew:kr note 300 20)
        num-smp   (/ (sample-rate) temp-freq)
        rate      (/ (* 2 Math/PI) num-smp)
        rate      (* rate 0.5 (demand:kr trig 0 (dseq [0.5 6 6 12 2 8 6 12] INF)))
        wobble    (lag (cos (phasor:ar trig rate Math/PI (* 2 Math/PI))) 0.01)
        sub       (* (lin-lin wobble -1 1 0 1)
                     (sin-osc (/ (midicps note) 2 )))
        sub       [sub sub]
        snd       (+ (var-saw (midicps note) :width (lin-lin wobble -1 1 0.45 0.55))
                     sub)
        snd       (decimator snd 20000 (lin-lin wobble -1 1 1.2 8))
        snd       (moog-ladder snd (lin-lin wobble -1 1 (midicps note) 25000) (lin-lin wobble -1 1 0.03 0.1))
        snd       (* 0.75 [snd snd])
        snd       [(delay-c snd 1 (lin-lin wobble -1 1 0 0.0012)) (delay-c snd 1 (lin-lin wobble -1 1 0.0012 0))]
        snd       (* snd (linen:kr trig 0.01 2 (/ 1.3 temp-freq) :action NO-ACTION))
        ]
    (out 0 snd)))

;; to play:
;; (deci-wobble)
;; (stop)
#+END_SRC
** 
** (nsovertone.examples.synthesis.demand
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.demand
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

; Unlike the audio and control rate ugens, which produce a constant
; stream of values, the demand rate ugens only produce a value
; when it is "demanded" of them.  This is normally done using the
; demand ugen, which will pull from its arguments when triggered.

; Play a sequence of notes, where the demand ugen pulls them
; each time it gets a trigger.
(demo 2
      (let [trig (impulse:kr 8)
            freqs (dseq [440 880 220] INF)
            note-gen (demand:kr trig 0 freqs)
            src (sin-osc note-gen)]
        (* [0.1 0.1] src)))


; Randomize the sequence of notes
(demo 2
      (let [trig (impulse:kr 8)
            freqs (drand [440 880 220] INF)
            note-gen (demand:kr trig 0 freqs)
            src (sin-osc note-gen)]
        (pan2 (* 0.1 src))))

; Shuffle the notes, but then repeat them in the same order
(demo 4
      (let [trig (impulse:kr 3)
            freqs (dseq (dshuf [440 880 220] 2) INF)
            note-gen (demand:kr trig 0 freqs)
            src (sin-osc [(* 1.01 note-gen) note-gen])]
        (* 0.2 src)))

; Randomize the sequence, but don't repeat already played notes until all
; the others have played.
(demo 2
      (let [trig (impulse:kr 8)
            freqs (dxrand [440 880 220] INF)
            note-gen (demand:kr trig 0 freqs)
            src (sin-osc note-gen)]
        (* [0.2 0.2] src)))

; generate n elements in total from a sequence, unlike dseq which takes
; a repeat number rather than the total number of values generated
(demo 10
      (let [trig (impulse:kr 2.5)
            n 15
            freqs (dser [440 880 660 1760] n)
            note-gen (demand:kr trig 0 freqs)
            src (sin-osc note-gen)]
        (pan2 (* 0.1 src))))

(def buf (buffer 8))
(buffer-write! buf 0 (map #(+ 12 %) [50 50 54 50 57 50 45 49]))

(demo 20
      (let [trig (impulse:kr 8)
            indexes (dseq (range 8) INF)
            freqs (dbufrd buf indexes)
            note-gen (demand:kr trig 0 freqs)
            src (sin-osc (midicps note-gen))]
        (* [0.1 0.1] src)))

; Now while it's playing you can set buffer elements to change the notes:
(buffer-set! buf 3 85)
(buffer-set! buf 3 80)
(buffer-set! buf 7 20)
(stop)

; This is an example of mapping a note generating synth (demand rate)
; outputting on a control bus onto the control of another synth.
(defsynth note-generator []
  (let [trig (impulse:kr 8)
        freqs (dseq [440 880 220] INF)
        note-gen (demand:kr trig 0 freqs)]
    (out:kr 0 note-gen)))

(defsynth beep [note 660]
  (let [src (sin-osc note)]
    (out 0 (* [0.2 0.2] src))))

;(def generator-node (note-generator))
;(def beep-node (beep))
;(node-map-controls beep-node 0 0)
;(stop)

(demo 4
      (let [freq (duty  (drand [0.2 0.4 0.8 0.6] INF)
                        0
                        (dseq [440 880 1200 600] 2))
            src (saw freq)]
        (* [0.2 0.2] src)))


;;play a little rhythm
(demo 5
      (t-duty (dseq [0.1 0.2 0.4 0.3] INF)))


; Generate a series of values, incrementing linearly.

(demo 8
      (let [trig (impulse:kr 10)
            freqs (dseries 150 2 200)
            note-gen (demand:kr trig 0 freqs)
            src (sin-osc note-gen)]
        src))

(demo 5
      (let [notes (dseries 0 1 15)
            trig (impulse:kr (mouse-x 1 40 1))
            freq (+ 340 (* 30 (demand:kr trig 0 notes)))]
        (* 0.3 (sin-osc freq))))


; Generate a geometric sequence
(demo 2
      (let [trig (impulse:kr 8)
            freqs (dgeom 1 1.2 10)
            note-gen (+ 340 (* 30 (demand:kr trig 0 freqs)))
            src (sin-osc note-gen)]
        (pan2 (* 0.1 src))))

; Demanding noise...
(demo 2
      (let [trig (impulse:kr 2)
            freqs (dwhite 0 20 INF)
            note-gen (+ 340 (* 30 (demand:kr trig 0 freqs)))
            src (sin-osc note-gen)]
        (pan2 (* 0.1 src))))

;;diwhite example
(demo 10
      (let [vals (dwhite 0 15 INF)
            trig (impulse:kr (mouse-x 1 40 1))
            val (demand:kr trig 0 vals)
            poll (poll trig val "diwhite val:")
            freq (+ 340 (* 30 val))]
        (* 0.1 (sin-osc freq))))




;; write demand sequence into a buffer
;;create and fill the buffer:
(def b (buffer 24 1))
(buffer-write! b 0 (repeat 24 210))
;;play this and click around the screen. y is freq, x is buf pos
(demo 60
      (let [val (mouse-y 1000 200 1)
            pos (mouse-x 0 (- (buf-frames:kr b) 1))
            write (mouse-button)]
        (demand:kr write 0 (dbufwr val b pos 1))
        (* 0.1 (sin-osc (duty:kr (* 0.2 (dseq [0.5 0.75 0.5 1] INF)) 0 (dbufrd b (dseries 0 1 INF)))))))
#+END_SRC
** 
** (nsovertone.examples.synthesis.feedback
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.feedback
  (:use overtone.core))
#+END_SRC

#+BEGIN_SRC clojure

;; The local-out and local-in ugens can be used to pipe signal data back
;; into the same synth each time processes a buffer of audio.  This is
;; how you implement feedback loops and custom delays.

;; A basic feedback loop going through a delay line
;; * move the mouse left/right to adjust the delay
;; * leak-dc removes any DC offset (waveform isn't centered at zero)
(defsynth feedback-loop []
  (let [input (crackle 1.5)
        fb-in (local-in 1)
        snd (+ input (leak-dc (delay-n fb-in 2.0 (* 0.8 (mouse-x 0.001 1.05)))))
        fb-out (local-out snd)
        snd (limiter snd 0.8)]
    (out 0 (pan2 snd))))

;;(feedback-loop)
;;(stop)

(defsynth distorted-feedback []
  (let [noiz (mul-add (lf-noise0:kr 0.5) 2 2.05)
        input (* 0.15 (crackle  1.5))
        fb-in (local-in 1)
        snd (+ input (leak-dc (* 1.1 (delay-n fb-in 3.5 noiz))))
        snd (rlpf snd (mul-add (lf-noise0:kr noiz) 400 800) 0.5)
        snd (clip:ar snd 0 0.9)
        fb-out (local-out snd)]
    (out 0 (pan2 snd))))

;;(distorted-feedback)
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.synthesis.filters
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.filters
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

; Filter examples, mostly ported from SC docs

; You might want to bring up the scope while trying the filters out,
; because in at least some instances it can help to understand what
; effect the filter is having.
; (scope)

; Lowpass
(demo 10
  (lpf (* 0.5 (saw [339 440]))
       (mouse-x 10 10000))) ; cutoff frequency

; Resonant Lowpass
(demo 10
  (rlpf (* 0.5 (saw [338 440]))
       (mouse-x 10 10000)
       (mouse-y 0.0001 0.9999))) ; cutoff frequency

; Highpass
(demo 10
  (hpf (* 0.5 (saw [203 200]))
       (mouse-x 100 10000))) ; cutoff frequency

; Bandpass
; - only let a band of frequencies pass through
(demo 10
  (bpf (* 0.5 (saw 200))
       (mouse-x 100 10000) ; center frequency
       (mouse-y 0 1)))     ; rq => bandwidth/cutoff

; Band reject
; - the inverse of the bandpass
(demo 10
  (brf (* 0.5 (saw 200))
       (mouse-x 100 10000) ; center frequency
       (mouse-y 0 1)))     ; rq => bandwidth/cutoff

; Limiter
; - limit the amplitude
(demo 10
  (limiter (* 0.5 (saw 440))
           (mouse-y 0.01 0.5)))


; Clip
; - limit the amplitude with hi and low thresholds
(demo 10
  (clip:ar (* (sin-osc 440) 0.4)
        -0.01
        0.01))

; Linear to linear
; - converte from one range to another
(demo 10
  (let [freq (lin-lin:kr (mouse-x 0.1 1)
                   0 1                ; source range
                   110 880)]          ; destination range
  (* 0.3 (saw freq))))

; Linear to exponential
; - convert from a linear range to an exponential range
(demo 10
  (let [freq (lin-exp:kr (mouse-x 0.1 1)
                   0 1                ; linear range
                   10 10000)]         ; exponential range
  (* 0.3 (saw freq))))


; Lag
; - smooths a transition by adjusting input value exponentially
;   over the specified lag time
; - used to smooth out control signals
(demo 10
  (* 0.2 (saw (lag:kr
                     (mouse-x 80 10000) ; frequency value
                     3))))             ; lag time

; Lag Up Down
; - allows for different up and down lag times
(demo 10
  (* 0.2 (saw (lag-ud:kr
                     (mouse-x 80 10000) ; frequency value
                     4 2))))             ; lag time


; Ramp
; - like lag, but transitions linearly
(demo 10
  (* 0.2 (saw (ramp:kr
                     (mouse-x 80 10000) ; frequency value
                     3))))             ; lag time

;; FIXME
;; (demo 10
;;   (klank [(repeatedly 12 #(+ 200.0 (rand 4000)))
;;           (repeat 12 0.8)
;;           (repeatedly 12 #(+ 0.1 (rand 2)))]
;;          (* (clip-noise) 0.01 (decay (impulse 4) 0.03))))

; Amplitude compensation
; - to account for higher pitches seeming louder
; - move the mouse up and down
;
; First a normal saw wave.  Careful, the high pitches can be painful
; at high volume so turn your headphones down!
(demo 10
  (let [f (mouse-y 300 15000)]
    (* (saw f) 0.1)))

; notice how with the compensation the higher pitches are less piercing
(demo 10
  (let [f (mouse-y 300 15000)]
    (* (saw f) 0.1 (amp-comp f 300))))
#+END_SRC
** 
** (nsovertone.examples.synthesis.fm
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.fm
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

(defsynth fm [carrier 440 divisor 2.0 depth 1.0 out-bus 0]
  (let [modulator (/ carrier divisor)
        mod-env   (env-gen (lin 1 0 6))
        amp-env   (env-gen (lin 1 1 5) :action FREE)]
    (out out-bus (pan2 (* 0.5 amp-env
                          (sin-osc (+ carrier
                                      (* mod-env  (* carrier depth) (sin-osc modulator)))))))))

; Some of these are more or less interesting
(fm)
(fm 220)
(fm 220 3)
(fm 220 10)
(fm 440)
(fm 440 2 4)
(fm 440 2 8)
(fm 440 4 4)
(fm 220 4 8)
(fm 880 4 4)
(fm 110 4 4)
(fm 220 2 4)
(fm 220 2 8)
(fm 440 8 8)
(fm 440 8 2)
(fm 440 (/ 4 3) 2)
(fm 440 (/ 5 3) 2)
(fm 440 (/ 7 3) 2)
(fm 440 (/ 4 3) 4)
(fm 440 (/ 5 3) 4)
(fm 440 (/ 7 3) 4)
(fm 220 (/ 7 5) 2)
(fm 220 (/ 7 5) 4)
(fm 110 4 2)
(fm 110 4 4)
(fm 110 4 8)
#+END_SRC
** 
** (nsovertone.examples.synthesis.fourier
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.fourier
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

(def buf (buffer 2048))

; Bounce around cutting a single band out of white noise.
(demo 10
  (let [rate 10
        src (* 0.8 (white-noise))
        freqs (fft buf src)
            filtered (pv-rand-comb freqs 0.95 (impulse:kr rate))]
    (pan2 (ifft filtered))))

; Cut off noise at a wall
(demo 15
    (let [src (* 0.2 (white-noise))
          freqs (fft (:id buf) src)
              filtered (pv-brick-wall buf (sin-osc:kr 0.1))]
    (out 0 (pan2 (ifft filtered)))))

;;saw-tips
(demo 5
  (let [freq     440
        thresh    0.5
        src      (* 0.8 (saw freq))
        freqs    (fft buf src)
        filtered (pv-local-max (:id buf) thresh)]
      (ifft filtered)))

(demo
  (let [in (* [0.1 0.1] (white-noise))
        chain (fft (local-buf 2048 2) in)
        chain (pv-brick-wall chain (sin-osc:kr [0.1 0.11]))]
    (ifft chain)))
#+END_SRC
** 
** (nsovertone.examples.synthesis.fx
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.fx
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

; All of these are based off the compander ugen.  Of course you can just use it
; directly in your synths, but it's nice to be able to stick on

;; This file has some demos to show you what the fx in overtone.studio.fx do.  These
;; are setup so you can experiment with the parameters by moving the mouse around.

;; First a fat synth to use as our source sound

(defsynth bizzle [out-bus 10 amp 0.5]
  (out out-bus
       (* amp
          (+ (* (decay2 (* (impulse 10 0)
                           (+ (* (lf-saw:kr 0.3 0) -0.3) 0.3))
                        0.001)
                0.3)
             (apply + (pulse [80 81]))))))

;; Give it a try
(def biz (bizzle 0))
(kill biz)

;; Next, create a bus to connect the source synth with the fx synth:
(def b (audio-bus))

; All of these are based off the compander ugen.  Of course you can just use it
; directly in your synths, but it's nice to be able to stick on
(defsynth compressor-demo [in-bus 10]
  (let [source (in in-bus)]
    (out 0 (pan2 (compander source source (mouse-y:kr 0.0 1) 1 0.5 0.01 0.01)))))

;; (def b-s (bizzle b))
;; (compressor-demo [:after b-s] b)
;; (stop)

(defsynth limiter-demo [in-bus 10]
  (let [source (in in-bus)]
    (out 0 (pan2 (compander source source (mouse-y:kr 0.0 1) 1 0.1 0.01 0.01)))))

(defsynth sustainer-demo [in-bus 10]
  (let [source (in in-bus)]
    (out 0 (pan2 (compander source source (mouse-y:kr 0.0 1) 0.1 1 0.01 0.01)))))
;; (def b-s (bizzle b))
;; (limiter-demo [:after b-s] b)
;; (stop)

;; (def b-s (bizzle b))
;; (sustainer-demo [:after b-s] b)
;; (stop)

;; Here is a different sample synth to try out the reverb and echo effects
(defsynth pling [out-bus 0
                 rate 0.3 amp 0.5]
  (out out-bus
       (* (decay (impulse rate) 0.25)
          (* amp (lf-cub 1200 0)))))

;; (def p (pling 0))
;; (kill p)

(defsynth reverb-demo [in-bus 10]
  (out 0 (pan2 (free-verb (in in-bus) 0.5 (mouse-y:kr 0.0 1) (mouse-x:kr 0.0 1)))))
;; (def p (pling b))
;; (reverb-demo [:after p] b)
;; (stop)

(defsynth echo-demo [in-bus 10]
  (let [source (in in-bus)
        echo (comb-n source 0.5 (mouse-x:kr 0 1) (mouse-y:kr 0 1))]
    (out 0 (pan2 (+ echo (in in-bus) 0)))))

;;(def p (pling b))
;;(echo-demo [:after p] b)

;;(stop)


;; If you have a microphone or some other source of external input, you can read it in
;; and then run it through fx like this.
(defsynth ext-source [out-bus 0]
  (out out-bus (in (num-output-buses:ir))))

;; (ext-source)
;; (stop)

;; Fetch a spoken countdown from freesound.org
(def count-down (sample (freesound-path 71128)))

;; Play it unmodified:
;;(def cd-s (count-down b))

;; From Designing Sound in SuperCollider
(defsynth schroeder-reverb-countdown
  [rate 1]
  (let [input    (pan2 (play-buf 1 count-down rate :action FREE) -0.5)
        delrd    (local-in 4)
        output   (+ input [(first delrd) (second delrd)])
        sig      [(+ (first output) (second output)) (- (first output) (second output))
                  (+ (nth delrd 2) (nth delrd 3)) (- (nth delrd 2) (nth delrd 3))]
        sig      [(+ (nth sig 0) (nth sig 2)) (+ (nth sig 1) (nth sig 3))
                  (- (nth sig 0) (nth sig 2)) (- (nth sig 0) (nth sig 2))]
        sig      (* sig [0.4 0.37 0.333 0.3])
        deltimes (- (* [101 143 165 177] 0.001) (control-dur))
        lout     (local-out (delay-c sig deltimes deltimes))
        ]
    (out 0 output)))


(defsynth schroeder-reverb-mic
  [rate 1 dec 1 del 10 out-bus 0]
  (let [input    (pan2 (allpass-c (sound-in) 10  dec del))
        delrd    (local-in 4)
        output   (+ input [(first delrd) (second delrd)])
        sig      [(+ (first output) (second output)) (- (first output) (second output))
                  (+ (nth delrd 2) (nth delrd 3)) (- (nth delrd 2) (nth delrd 3))]
        sig      [(+ (nth sig 0) (nth sig 2)) (+ (nth sig 1) (nth sig 3))
                  (- (nth sig 0) (nth sig 2)) (- (nth sig 0) (nth sig 2))]
        sig      (* sig [0.4 0.37 0.333 0.3])
        deltimes (- (* [101 143 165 177] 0.001) (control-dur))
        lout     (local-out (delay-c sig deltimes deltimes))
        ]
    (out out-bus output)))

;; Spooky!
;; (schroeder-reverb-countdown :rate 0.8 :dec 0.8 :del 10)
;; (schroeder-reverb-mic :rate 0.8 :dec 0.8 :del 10)
;; (stop)
#+END_SRC
** 
** (nsovertone.examples.synthesis.local-buffer
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.local-buffer
  (:use overtone.live))
#+END_SRC

#+BEGIN_SRC clojure

;;original sc lang:
;;(
;;{
;;var z = Decay.ar(Dust.ar(1.dup, 0.1), 0.3, WhiteNoise.ar);
;;BufCombC.ar(LocalBuf(SampleRate.ir, 2), z, XLine.kr(0.0001, 0.01, 20), 0.2);
;;}.play
;;)

(defsynth blips []
  (let [z (* (white-noise:ar) (decay:ar (* 0.1 (dust:ar [1 1])) 0.3))]
    (out 0 (buf-comb-c:ar (local-buf (sample-rate) 2) z (x-line:kr 0.0001 0.01 20) 0.2))))

;(blips)
;(stop)
#+END_SRC
** 
** (nsovertone.examples.synthesis.poll
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.poll
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

;;With poll you can get scsynth to output debug messages containing the contents of a given stream to stdout.

;;Here we're polling the value of the line ugen at the rate
;;specified by the impulse ugen - 10 times per second.
;;We also specify a string to be prepended to the log message:
(run (poll:kr (impulse:kr 10) (line:kr 0 1 1) "polled-val:"))


;;It's also possible to poll demand ugens with dpoll:
(run (duty:kr 0.5 0 (dpoll (dseries 0 1 INF) -1 "dpolled-val")))


;;Poll only when the mouse is on the left hand side of the screen
(run 10 (duty:kr 0.5 0 (dpoll (dseries 0 1 INF) 0 "dpolled-val" (> 0.5 (mouse-x)))))
#+END_SRC
** 
** (nsovertone.examples.synthesis.samples
#+BEGIN_SRC clojure
(nsovertone.examples.synthesis.samples
  (:use overtone.live
        [overtone.studio.scope :only [pscope]]))
#+END_SRC

#+BEGIN_SRC clojure

;;; Read me, and evaluate line by line as you go.  To evaluate a form
;;; highlight it with the mouse and type <control-e>, using the "e" for
;;; evaluate.  The repl window below will show the output of everything
;;; you evaluate.  This is helpful for documentation too.  All ugen
;;; functions have doc strings.  Try evaluating these:

(odoc buf-rd)
(odoc buf-frames)
(odoc sin-osc)
(odoc lf-tri)
(odoc phasor)

;; In order to play samples instantly they have to be in memory.  (You
;; use memory buffers for other synths too, for example in an echo
;; effect.)

;; Load a sample into a buffer. If this is the first time you're using
;; sample 35809 from freesound, then it'll take a few seconds to
;; download...

(def flute (freesound 35809))

;; Now the audio data for the sample is loaded into a buffer.  You can
;; view the buffer in the scope window too.  Click in the scope tab on
;; the right, and evaluate this.
(pscope flute)

;; You can play the sample by calling it like a function:

(flute)

;; Try layering these looped versions, eval each line
;; [buf 0 rate 1.0 start-pos 0.0 loop? 0 amp 1]
(flute :rate 1 :loop? true)
(flute :rate 0.5 :loop? true)
(flute :rate 1.5 :loop? true)
(flute :rate 0.25 :loop? true)
(flute :rate 2 :loop? true)

;; When you've had enough, then stop them:
(stop)

;; You can load arbirary wav and aiff files from your computer by
;; passing a path to the sample function:

(def foo (sample "~/Desktop/foo.wav"))

;; This can also triggered y calling it as a function:

(foo)

;;The freesound and sample player play-buf ugen behind the scenes to
;;play the buffer. This plays the sample linearly with options such as
;;rate and loop? However, we're not just limited to playing back buffers
;;linearly, we can do all sorts of crazy stuff...


;; buf-rd takes an oscillator as the index into the buffer its reading.
;; This lets you sweep back and forth across a buffer in any direction
;; and at any rate.

;; zip back and forth across the buffer with a sin wave
(demo 10 (buf-rd 2 flute (* (sin-osc 0.1) (buf-frames flute))))

;; randomly scrub around the buffer
(demo 10 (buf-rd 2 flute (* (lf-noise1 1) (buf-frames flute))))
(demo 10 (buf-rd 2 flute (* (lf-noise1 10) (buf-frames flute))))

;; the triangle waves give a sense of building
(demo 10 (buf-rd 2 flute (+ (lf-tri 1.1) (*  (lin-lin (lf-tri 0.23) -1 1 0 1) (buf-frames flute)))))

;; experiment with different ways of modulating the rate
(demo 10 (buf-rd 2 flute (* (lin-lin (sin-osc 0.02) -1 1 0 1 ) (buf-frames:ir flute))))
#+END_SRC
** 
* timing
** (nsovertone.examples.timing.internal-metro
#+BEGIN_SRC clojure
(nsovertone.examples.timing.internal-metro
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

;; A basic demo of how you can use internal impulses to drive the rhythm of a synth

(demo 5
     (let [src1      (sin-osc 440)
           src2      (sin-osc 880)
           root-trig (impulse:kr 100)
           t1        (pulse-divider:kr root-trig 20)
           t2        (pulse-divider:kr root-trig 10)]
       (* 0.2
          (+ (* (decay t1 0.1) src1)
             (* (decay t2 0.1) src2)))))


;; Here's how you can separate the impulses out across synths and connect them
;; together with a control bus

(def c-bus (control-bus))

(defsynth root-trig [rate 100]
 (out:kr c-bus (impulse:kr rate)))

(definst pingr [freq 440 div 20]
 (let [src1 (sin-osc freq)
       t1 (pulse-divider:kr (in:kr c-bus) div)]
   (* (decay t1 0.1) src1)))

(def r-trig (root-trig))
(pingr)
(pingr 440 50)
(pingr 990 40)
(ctl r-trig :rate 50)
(stop)

;; Creating an internal metro synth to send trig messages back
;; to Overtone to use for whatever purpose you need.
;;
;; Here, we create a synth called metro-synth which has two control params:
;; c-bus and rate. c-bus represents the bus to output trigger information to
;; and rate is the beats-per-second. We then pass the rate to an impulse ugen
;; running at control rate - we bind this to the var trigger. This trigger is
;; pthen used for three things:
;;
;; 1) it's passed through a stepper which wraps a count between min and max which we bind to count
;; 2) we send the current value of count out as an osc message when the trigger fires
;; 3) we output the trigger to the control bus with id c-bus
;;
;; Next we register an osc handler which will be called when the osc message
;; with path "/tr" is received. We give this handler the id :metro-synth so we
;; can refer to it in the future. Finally we pass an anonymous fn which simply
;; prints out the osc msg received. Clearly this fn could do a lot more
;; interesting things ;-)


(defsynth metro-synth [c-bus 0 rate 1]
  (let [trigger (impulse:kr rate)
        count (stepper:kr trigger :min 1 :max 4)]
    (send-trig:kr trigger count)
    (out:kr c-bus trigger)))

(on-event "/tr" #(println "trigger: " %) ::metro-synth)

(metro-synth)


;; Here's a simple little melody-playing synth which reads a series of
;; notes from a buffer (which you can change in real-time) and which
;; also allows you to modulate the rates and rate ratios of the
;; arpeggiator and cymbal sound:

;; create a buffer for the notes
(def notes-b (buffer 5))

;; fill the buffer with a nice chord
(buffer-write! notes-b (take 5 (cycle (chord :Cb2 :minor))) )

;; here's our swanky synth:

(defsynth arpeg-click [rate 10 buf 0 arp-div 2 beat-div 1]
  (let [tik   (impulse rate)
        a-tik (pulse-divider tik arp-div)
        b-tik (pulse-divider tik beat-div)
        cnt   (mod (pulse-count a-tik) (buf-frames buf))
        note  (buf-rd:kr 1 notes-b cnt)
        freq  (midicps note)
        snd   (white-noise)
        snd   (rhpf snd 2000 0.4)
        snd   (normalizer snd)
        b-env (env-gen (perc 0.01 0.1) b-tik)
        a-env (env-gen (perc 0.01 0.4) a-tik)]
    (out 0 (pan2 (+ (* 0.5 snd b-env)
                    (* (sin-osc freq) a-env)
                    (* (sin-osc (* 2 freq)) a-env))))))

;; have fun!
;; (def s (arpeg-click))
;; (ctl s :rate 20)
;; (ctl s :rate 5)
;; (buffer-write! notes-b (take 5 (cycle (chord :Eb3 :minor))))
;; (buffer-write! notes-b (take 5 (cycle (chord :F#2 :minor))) )
;; (stop)
#+END_SRC
** 
** (nsovertone.examples.timing.internal-sequencer
#+BEGIN_SRC clojure
(nsovertone.examples.timing.internal-sequencer
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

;; A fully server-side sample sequencer.
;; =====================================

;; This example demonstrates some of the benefits of moving all synth
;; triggers inside the server itself. For example, it allows you to
;; modify the synthesis with *immediate* effect (rather than waiting for
;; the next bar/chunk to be scheduled) and you can use a global pulse to
;; drive both the timing and to also modulate aspects of the synthesis
;; so that the modulations are sympathetic to the rhythms being played.


;; First, let's create some sequencer buffers for specifying which beat
;; to trigger a sample. This will be our core data structure for a basic
;; emulation of an 8-step sequencer. A buffer is like a Clojure vector,
;; except it lives on the server and may only contain floats. Buffers
;; are initialised to have all values be 0.0
(defonce buf-0 (buffer 8))
(defonce buf-1 (buffer 8))
(defonce buf-2 (buffer 8))
(defonce buf-3 (buffer 8))

;; Next let's create some timing buses. These can be visualised as
;; 'patch cables' - wires that carry pulse signals that may be
;; arbitrarily forked and fed into any synth that wants to be aware of
;; the pulses. We have two types of information being conveyed here -
;; firstly the trg buses contain a stream of 0s with an intermittant 1
;; every time there is a tick. Secondly we have the cnt buses which
;; contain a stream of the current tick count. We then have two of each
;; type of bus - one for a high resolution global metronome, and another
;; for a division of the global metronome for our beats.
(defonce root-trg-bus (control-bus)) ;; global metronome pulse
(defonce root-cnt-bus (control-bus)) ;; global metronome count
(defonce beat-trg-bus (control-bus)) ;; beat pulse (fraction of root)
(defonce beat-cnt-bus (control-bus)) ;; beat count

(def BEAT-FRACTION "Number of global pulses per beat" 30)

;; Here we design synths that will drive our pulse buses.
(defsynth root-trg [rate 100]
  (out:kr root-trg-bus (impulse:kr rate)))

(defsynth root-cnt []
  (out:kr root-cnt-bus (pulse-count:kr (in:kr root-trg-bus))))

(defsynth beat-trg [div BEAT-FRACTION]
  (out:kr beat-trg-bus (pulse-divider (in:kr root-trg-bus) div))  )

(defsynth beat-cnt []
  (out:kr beat-cnt-bus (pulse-count (in:kr beat-trg-bus))))

;; Now we get a little close to the sounds. Here's four nice sounding
;; samples from Freesound.org
(def kick-s (freesound 777))
(def click-s (freesound 406))
(def boom-s (freesound 33637))
(def subby-s (freesound 25649))

;; Here's a synth for playing back the samples with a bit of modulation
;; to keep things interesting.
(defsynth mono-sequencer
  "Plays a single channel audio buffer."
  [buf 0 rate 1 out-bus 0 beat-num 0 sequencer 0 amp 1]
  (let [cnt      (in:kr beat-cnt-bus)
        beat-trg (in:kr beat-trg-bus)
        bar-trg  (and (buf-rd:kr 1 sequencer cnt)
                      (= beat-num (mod cnt 8))
                      beat-trg)
        vol      (set-reset-ff bar-trg)]
    (out
     out-bus (* vol
                amp
                (pan2
                 (rlpf
                  (scaled-play-buf 1 buf rate bar-trg)
                  (demand bar-trg 0 (dbrown 200 20000 50 INF))
                  (lin-lin:kr (lf-tri:kr 0.01) -1 1 0.1 0.9)))))))

;; Here's Dan Stowell's dubstep synth modified to work with the global
;; pulses
(definst dubstep [note 40 wobble BEAT-FRACTION hi-man 0 lo-man 0 sweep-man 0 deci-man 0 tan-man 0 shape 0 sweep-max-freq 3000 hi-man-max 1000 lo-man-max 500 beat-vol 0 lag-delay 0.5]
  (let [bpm     300
        wob     (pulse-divider (in:kr root-trg-bus) wobble)
        sweep   (lin-lin:kr (lag-ud wob 0.01 lag-delay) 0 1 400 sweep-max-freq)
        snd     (mix (saw (* (midicps note) [0.99 1.01])))
        snd     (lpf snd sweep)
        snd     (normalizer snd)

        snd     (bpf snd 1500 2)
        ;;special flavours
        ;;hi manster
        snd     (select (> hi-man 0.05) [snd (* 4 (hpf snd hi-man-max))])

        ;;sweep manster
        snd     (select (> sweep-man 0.05) [snd (* 4 (hpf snd sweep))])

        ;;lo manster
        snd     (select (> lo-man 0.05) [snd (lpf snd lo-man-max)])

        ;;decimate
        snd     (select (> deci-man 0.05) [snd (round snd 0.1)])

        ;;crunch
        snd     (select (> tan-man 0.05) [snd (tanh (* snd 5))])

        snd     (* 0.5 (+ (* 0.8 snd) (* 0.3 (g-verb snd 100 0.7 0.7))))
        ]
    (normalizer snd)))

;; Here's a nice supersaw synth
(definst supersaw2 [freq 440 amp 1 fil-mul 2 rq 0.3]
  (let [input  (lf-saw freq)
        shift1 (lf-saw 4)
        shift2 (lf-saw 7)
        shift3 (lf-saw 5)
        shift4 (lf-saw 2)
        comp1  (> input shift1)
        comp2  (> input shift2)
        comp3  (> input shift3)
        comp4  (> input shift4)
        output (+ (- input comp1)
                  (- input comp2)
                  (- input comp3)
                  (- input comp4))
        output (- output input)
        output (leak-dc:ar (* output 0.25))
        output (normalizer (rlpf output (* freq fil-mul) rq))]

    (* amp output (line 1 0 10 FREE))))


;; OK, let's make some noise!

;; Now, let's start up all the synths:
(do
  (def r-trg (root-trg))
  (def r-cnt (root-cnt [:after r-trg]))
  (def b-trg (beat-trg [:after r-trg]))
  (def b-cnt (beat-cnt [:after b-trg]))


  (def kicks (doall
              (for [x (range 8)]
                (mono-sequencer :buf kick-s :beat-num x :sequencer buf-0))))

  (def clicks (doall
               (for [x (range 8)]
                 (mono-sequencer :buf click-s :beat-num x :sequencer buf-1))))

  (def booms (doall
              (for [x (range 8)]
                (mono-sequencer :buf boom-s :beat-num x :sequencer buf-2))))

  (def subbies (doall
                (for [x (range 8)]
                  (mono-sequencer :buf subby-s :beat-num x :sequencer buf-3)))))

;; An empty palatte to play with:
(do
  (buffer-write! buf-0 [1 0 1 1 0 0 1 0])  ;; kick
  (buffer-write! buf-1 [0 0 0 0 1 0 0 0])  ;; click
  (buffer-write! buf-2 [0 0 0 0 0 0 1 0])  ;; boom
  (buffer-write! buf-3 [0 0 0 0 0 0 0 0])) ;; subby

;; try mixing up the sequences. Evaluate this a few times:
(do
  (buffer-write! buf-0 (repeatedly 8 #(choose [0 1])))
  (buffer-write! buf-1 (repeatedly 8 #(choose [0 1])))
  (buffer-write! buf-2 (repeatedly 8 #(choose [0 1])))
  (buffer-write! buf-3 (repeatedly 8 #(choose [0 1]))))

;; and then to something interesting
(do
  (buffer-write! buf-0 [1 1 1 1 1 1 1 1])
  (buffer-write! buf-1 [1 0 1 0 0 1 1 0])
  (buffer-write! buf-2 [1 1 0 1 0 1 1 0])
  (buffer-write! buf-3 [1 0 0 0 0 0 1 0]))

;; try changing the rate of the global pulse (everything else will
;; follow suit):
(ctl r-trg :rate 75)
(ctl r-trg :rate 300)
(ctl r-trg :rate 150)

;; get the dubstep bass involved:
(dubstep :note 28
         :wobble (* BEAT-FRACTION 1)
         :lo-man 1)

;; go crazy - especially with the deci-man
(ctl dubstep
     :note 40
     :wobble (* BEAT-FRACTION 0.1)
     :lag-delay 0.05
     :hi-man 0
     :lo-man 0
     :deci-man 0)


;; Bring in the supersaws!

(def ssaw-rq 0.9)
(def ssaw-fil-mul 2)

;; Fire at will...
(supersaw2 (midi->hz 28) :amp 3 :fil-mul ssaw-fil-mul :rq ssaw-rq)
(supersaw2 (midi->hz 40) :amp 3 :fil-mul ssaw-fil-mul :rq ssaw-rq)
(supersaw2 (midi->hz 45) :amp 2 :fil-mul ssaw-fil-mul :rq ssaw-rq)
(supersaw2 (midi->hz 48) :amp 2 :fil-mul ssaw-fil-mul :rq ssaw-rq)
(supersaw2 (midi->hz 52) :amp 2 :fil-mul ssaw-fil-mul :rq ssaw-rq)
(supersaw2 (midi->hz 55) :amp 2 :fil-mul ssaw-fil-mul :rq ssaw-rq)
(supersaw2 (midi->hz 57) :amp 2 :fil-mul ssaw-fil-mul :rq ssaw-rq)
(supersaw2 (midi->hz 64) :amp 1 :fil-mul ssaw-fil-mul :rq ssaw-rq)
(supersaw2 (midi->hz 67) :amp 1 :fil-mul ssaw-fil-mul :rq ssaw-rq)
(supersaw2 (midi->hz 69) :amp 1 :fil-mul ssaw-fil-mul :rq ssaw-rq)

;; modify saw params on the fly too...
;;(ctl supersaw2 :fil-mul 4 :rq 0.2)
;;(stop)
#+END_SRC
** 
** (nsovertone.examples.timing.one-bar-sequencer
#+BEGIN_SRC clojure
(nsovertone.examples.timing.one-bar-sequencer
  (:use [overtone.live]
        [overtone.inst drum]))
#+END_SRC

#+BEGIN_SRC clojure

(def metro (metronome 128))

; Our bar is a map of beat to instruments to play

(def bar {0   [kick]
          0.5 [closed-hat]
          1   [kick snare]
          1.5 [closed-hat]
          2   [kick]
          2.5 [closed-hat]
          3   [kick snare]
          3.5 [closed-hat]})

; For every tick of the metronome, we loop through all our beats
; and find the apropriate one my taking the metronome tick mod 4.
; Then we play all the instruments for that beat.

(defn player
  [tick]
  (dorun
    (for [k (keys bar)]
      (let [beat (Math/floor k)
            offset (- k beat)]
           (if (== 0 (mod (- tick beat) 4))
               (let [instruments (bar k)]
                    (dorun
                      (for [instrument instruments]
                        (at (metro (+ offset tick)) (instrument))))))))))

;; define a run fn which will call our player fn for each beat and will schedule
;; itself to be called just before the next beat

(defn run-sequencer
  [m]
  (let [beat (m)]
    (player beat)
    (apply-by (m (inc beat))  #'run-sequencer [m])))

;; make beats! Edit bar whilst the beat is playing to make live changes.
(run-sequencer metro)

;; stop
(stop)
#+END_SRC
** 
* ugens
** (nsovertone.examples.ugens.blowpass4
#+BEGIN_SRC clojure
(nsovertone.examples.ugens.blowpass4
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

(demo 10
      (b-low-pass4
       (sound-in [0 1])
       (mouse-x 10 20000 EXPONENTIAL)
       (mouse-y 0.1 1 LINEAR)
       0.5))
#+END_SRC
** 
** (nsovertone.examples.ugens.wobble
#+BEGIN_SRC clojure
(nsovertone.examples.ugens.wobble
  (:use [overtone.live]))
#+END_SRC

#+BEGIN_SRC clojure

(defcgen wobble
  "wobble an input source to a specified wobble val (which is designed
  to be remotely modulated"
  [src {:doc "input source"}
   wobble-amount {:doc "Amount of wobble to apply (-1 to 1)" :default 0}
   min {:doc "minimum freq to always let through" :default 40}
   max {:doc "maximum freq to let through the wobble" :default 3000}]
  (:ar
   (let [scaled-wob (lin-exp (lf-tri wobble-amount) -1 1 min max)
         wob        (lpf src scaled-wob)
         wob        (* 0.8 (normalizer wob))
         wob        (+ wob (bpf wob 1500 2))]
     (+ wob (* 0.2 (g-verb wob 9 0.7 0.7))))))

(defcgen auto-wobble
  "wobble an input src with a specified number of wobbles per second"
  [src {:doc "input source"}
   wobble-factor {:doc "num wobbles per second"}]
  (:ar
   (let [sweep (lin-exp (lf-tri wobble-factor) -1 1 40 3000)
         wob   (lpf src sweep)
         wob   (* 0.8 (normalizer wob))
         wob   (+ wob (bpf wob 1500 2))]
     (+ wob (* 0.2 (g-verb wob 9 0.7 0.7))))))


(demo 3 (wobble (saw (* 50 [0.99 1.01])) 3))

(demo 3
      (auto-wobble
       (apply + (saw (* 50 [1.01 0.99]))) 5))
(stop)
#+END_SRC
* workshops
**   overtone.examples.workshops.resonate2013.ex01_phrasestudy
#+BEGIN_SRC clojure

(ns
  ^{:doc "Workshop exercises in musical pattern creation with Overtone."
    :author "Karsten Schmidt"}
  overtone.examples.workshops.resonate2013.ex01_phrasestudy
  (:use
   [overtone.live]
   [overtone.inst.piano]))

;; All examples are wrapped in (comment) to stop them from
;; executing all at once when the file is loaded...
;; To execute an example in the REPL, select a single form,
;; e.g. "(piano 60)" below and press Command+Enter
;; Selection of a whole form (in Eclipse) can be done easily by clicking in
;; front of the opening bracket and then pressing Command+Shift+right...
(comment
  (piano 60)
  (piano (note :c4)) ; 60
  (piano (note :d4)) ; 62
  (piano (note :g4)) ; 67
  (piano (note :c5)) ; 72

  ;; play a note 2 secs in the future
  ;; the `now` fn returns the current timestamp
  (at (+ (now) 2000) (piano 72))

  ;; play progression C4 D4 G4 C5
  ;; notes will be played every 200 milliseconds
  ;; the fn passed to `map-indexed` takes two arguments: index & note
  (dorun (map-indexed (fn [i n] (at (+ (now) (* i 200)) (piano n))) [60 62 67 72]))
  ;; same, but using fn reader macro w/ anonymous arguments (% = 1st argument, %2 = 2nd arg, etc.)
  (dorun (map-indexed #(at (+ (now) (* % 200)) (piano %2)) [60 62 67 72]))
  ;; play progression relative to C4 (MIDI note offset = 60)
  (dorun (map-indexed #(at (+ (now) (* % 200)) (piano (+ 60 %2))) [0 2 7 12 24 19 14 12]))
  ;; play one octave higher (60 + 12 = 72)
  (dorun (map-indexed #(at (+ (now) (* % 200)) (piano (+ 72 %2))) [0 2 7 12]))
  ;; play minor variation (7 -> 6)
  (dorun (map-indexed #(at (+ (now) (* % 200)) (piano (+ 72 %2))) [0 2 6 12]))
  )

;; the examples in this namespace are all about thinking of music as sequences
;; and getting to know essential Clojure functions which allow us to construct
;; and manipulate sequences efficiently

;; first off, we define some arpeggio patterns used as
;; basic musical building blocks
(def a [0 2 7 12]) ; major
(def b [0 2 6 12]) ; diminished
(def c [0 2 7 12 24 19 14 12]) ; up & down

(comment
  ;; play a phrase of concatenated patterns: 2x A, 2x B
  (dorun (map-indexed #(at (+ (now) (* % 200)) (piano (+ 72 %2))) (concat a a b b)))

  ;; repeat the constructed phrase twice
  ;; (flatten) removes any nesting from a given sequence
  (dorun (map-indexed #(at (+ (now) (* % 200)) (piano (+ 72 %2))) (flatten (repeat 2 (concat a a b b)))))

  ;; the `->>` is a so called threading-macro, which weaves the result of each form
  ;; as last argument into the next form and so allows us to think about the code as
  ;; a data transformation pipeline (it produces the same effect as the previous example):
  ;; 1) we use the vector [a a b b]
  ;;    => [[0 2 7 12] [0 2 7 12] [0 2 6 12] [0 2 6 12]]
  ;; 2) weave it as last argument into (repeat 2)
  ;;    => (repeat 2 [[0 2 7 12] [0 2 7 12] [0 2 6 12] [0 2 6 12]]),
  ;;    which produces this sequence:
  ;;    ([[0 2 7 12] [0 2 7 12] [0 2 6 12] [0 2 6 12]]
  ;;     [[0 2 7 12] [0 2 7 12] [0 2 6 12] [0 2 6 12]])
  ;; 3) take the result of step 2 and weave it as last arg into (flatten)
  ;;    => (flatten ([[0 2 7 12] [0 2 7 12] [0 2 6 12] [0 2 6 12]]
  ;;                 [[0 2 7 12] [0 2 7 12] [0 2 6 12] [0 2 6 12]]))
  ;;    which produces (0 2 7 12 0 2 7 12 0 2 6 12 0 2 6 12
  ;;                    0 2 7 12 0 2 7 12 0 2 6 12 0 2 6 12) (no more nesting)
  ;;
  ;; This final flat collection is then used as input for the `map-indexed` fn for playback
  (dorun (map-indexed #(at (+ (now) (* % 200)) (piano (+ 72 %2))) (->> [a a b b] (repeat 2) (flatten))))
  )

;; define counter running at 120 bpm
;; this counter keeps running automatically in the background
(def metro (metronome 120))

(comment
  ;; play phrase using metronome
  (dorun (map-indexed #(at (metro (+ (metro) (/ % 2))) (piano (+ 72 %2))) (->> [a a b b] (repeat 2) (flatten))))
  )

;; now let's start separating concerns: note playback vs. phrase playback

(defn play-note-at
  "Plays note with `inst` at relative beat `index` from `start`,
  based on tempo of `metronome` and given note `duration`."
  [metro start index dur inst note]
  (at (metro (+ start (* 4 index dur))) (inst note)))

;; This next function uses a few new concepts:
;; 1) It makes use of partial function application to hardcode a number of parameters.
;;    In this case we use `partial` to produce a version of the play-note-at fn,
;;    which has the first 2 arguments (the metronome itself and the metronome's current beat count) hardcoded.
;;    This pre-configured play fn is then used to play the notes
;; 2) It uses so called let-bindings, local symbol definitions which are only existing within
;;    the scope of let's body (in this case, the constructed `play` fn)
;; 3) The play-phrases-1 fn uses variable argument counts, allowing us to specify any number of phrases
;;    to be played sequentially. This is achieved with the `&` separator in the function's argument list
;;    The given phrases to be played are all collected into a single sequence automatically
(defn play-phrases-1
  "Plays the given phrases `n` times with `inst` and transposed by `offset`.
  Tempo is based on metronome and given note `duration`."
  [metro inst dur offset n & phrases]
  (let [play (partial play-note-at metro (metro))]
    (->> phrases
         (repeat n)
         (flatten)
         (map-indexed #(play % dur inst (+ (note offset) %2)))
         (dorun))))

(comment
  ;; play the same combined pattern as earlier, but also allows us to
  ;; specify note durations (1/16th), root note (:c4) and number of repetitions (2)
  (play-phrases-1 metro piano 1/16 :c4 2 a a b b))

;; continue separating concerns: pattern repetition vs. pattern playback...

;; So far, play-phrases still is doing more than one thing and we can
;; refactor it further by splitting out and increasing the flexibility of
;; the pattern/phrase generation. More flexibility can be obtained by
;; allowing us to specify the root note as absolute value, e.g. :c4 or
;; use a number which is then applied as relative offset to transpose patterns
;; This is what the `if` does below...
(defn repeat-phrases
  "Returns a lazyseq of the given patterns relative to `offset` (a note or int) and repeated `n` times."
  [n offset & phrases]
  (->> phrases
       (repeat n)
       (flatten)
       (map (partial + (if (keyword? offset) (note offset) offset)))))

;; To ease the combination of shorter phrases into longer ones,
;; we could also define a custom data format and use this helper function:
(defn specs->phrases
  "Takes a number of specs in the form of `[count root-note phrases]` and calls
  repeat-phrases on each. Concatenates all into a single flat seq."
  [& phrases]
  (mapcat #(apply repeat-phrases %) phrases))

;; This then allows us to constuct a longer pattern like this:
;; 2x AABB at C4, 1x AABB at G4 and 2x pattern C at D4
(def pattern
  "Defines a more complex pattern using different keys
  and a longer pattern for more variation"
  (specs->phrases [2 :c4 a a b b] [1 :g4 a a b b] [2 :d4 c]))

(comment
  ;; Since all our patterns are made of sequences of 4 notes, we can use the
  ;; (partition) fn to re-create that grouping (e.g. for debug purposes)
  ;; So the partitioned pattern looks again like that:
  ;; => ((60 62 67 72) (60 62 67 72) (60 62 66 72) ...)
  (partition 4 pattern)

  ;; This can be of course applied recursively to create ever more
  ;; deeply nested sequences
  (partition 4 (partition 4 pattern))
  )

;; With these new changes done, we can limit the responsibility of the play-phrases fn
;; to simply play notes... Here's version 2:
(defn play-phrases-2
  [metro inst dur phrases]
  (let [play (partial play-note-at metro (metro))]
    (dorun (map-indexed #(play % dur inst %2) phrases))))

(comment
  (play-phrases-2 metro piano 1/16 pattern)
  (play-phrases-2 metro piano 1/16 (repeat-phrases 2 0 pattern))
  (play-phrases-2 metro piano 1/16 (repeat-phrases 2 0 pattern (reverse pattern))))

;; Let's create some more pattern variations
(def mirror-pattern
  "The original pattern inverted in time."
  (reverse pattern))

(def long-pattern
  "The original pattern followed by mirror-pattern."
  (concat pattern mirror-pattern))

(comment
  ;; Here we also make use of the relative transposing feature of `specs->phrases` creating
  ;; a new long phrase which goes down to G3 (-5) and D3 (-10) towards the end
  (play-phrases-2 metro piano 1/16 (specs->phrases [1 0 long-pattern] [1 -5 pattern] [1 -10 (reverse pattern)])))

;; And to show even more possibilities, an even longer progression
;; Here we also use `take` & `drop` to only use parts of existing phrases
(def progression
  (->> [[1 0 long-pattern]                         ; c4
        [1 -5 pattern]                             ; g3
        [1 -8 (take 32 mirror-pattern)]            ; e3
        [1 -10 (take 16 mirror-pattern)]           ; d3
        [1 -5 (take 16 (drop 16 mirror-pattern))]] ; g3
       (apply specs->phrases)
       (apply repeat-phrases 2 0)))

(comment
  (play-phrases-2 metro piano 1/16 progression))

;; Until now all notes have been played with the same duration, but it's now time
;; to start thinking about imposing a certain rhythm onto our phrase(s)

;; Example rhythm using syncopation to emphasize every 4th note (longer)
(def rhythm [3/8 5/24 5/24 5/24])

;; The note durations of the rhythm all add up to 1 bar...
(comment (apply + rhythm)) ; => 1

;; Since our note phrases are just sequences of numbers, we can apply the same
;; functions we've built on our rhythmic phrases too. Below we construct a more
;; complex rhythmic pattern (using 0 as an offset to keep the original values)
;; The generated rhythm is: (3/8 1/8 3/8 1/8 1/8 1/8 1/8 1/8 1/8 1/8 1/8 1/8)
(def alt-rhythm (specs->phrases [2 0 [3/8 1/8]] [8 0 [1/8]]))

;; The the total duration of this rhythm is 2 bars
(comment (apply + alt-rhythm)) ; => 2

;; The next function is used to compute start times for all notes in a phrase
;; based on a given rhythmic pattern...
;; Notable things:
;; 1) We use the ->> threading syntax again to describe the transformation of
;;    how the rhythm is applied to our melody
;; 2) The (cycle) fn produces an infinite repetition of the given sequence:
;;    E.g. (cycle [1 2]) => (1 2 1 2 1 2 ...)
;; 3) Since we are only interested in a finite amount of notes, we use (take)
;;    to only take the first x items from that infinite sequence (without it
;;    the machine would freeze :)
;; 4) We also use (reductions) again to build up a sequence of increasing timestamps.
;;    The last argument (0) is the time offset for the first note
;;    This timing sequence is then combined with the notes in the (map) fn
(defn rhythmic-phrase
  "Takes a rhythm sequence, a speed factor and phrase, returns a lazyseq
  of vector pairs [note time] with the time values being the start times of each
  note in the phrase based on the rhythm. The start times are in bar measures."
  [rhythm factor phrase]
  (->> rhythm
       (cycle)
       (take (count phrase))
       (reductions (fn[t d] (+ t (* d factor 4))) 0)
       (map (fn [n t] [n t]) phrase)))

;; Now that the musical phrases include timing, we also need to
;; create a new playback fn which uses this timing information...
(defn play-rhythmic-phrase-1
  [metro inst rhythm factor phrase]
  (let [t0 (metro)
        play (fn [[n t]] (at (metro (+ t0 t)) (inst n)))]
    (dorun (map play (rhythmic-phrase rhythm factor phrase)))))

(comment
  ;; Let's testdrive the rhythms...
  (play-rhythmic-phrase-1 metro piano rhythm 1/2 progression)
  (play-rhythmic-phrase-1 metro piano alt-rhythm 1 progression)
  )

;; Maybe it's also a good time to introduce a couple of custom synths
;; Both instruments below are almost identical and only differ in their
;; oscillator waveform used...

(definst fatso-saw
  "Defines a simple synth using a slightly detuned stereo sawtooth oscillator
  with a percussive envelope. Accepts a MIDI note, duration (in secs) and volume."
  [note 60 dur 1.0 amp 1.0]
  (let [freq (midicps note)
        src (saw [freq (* freq 0.51)])
        env (env-gen (perc (* 0.1 dur) dur amp) :action FREE)]
    (* src env)))

(definst fatso-pwm
  "Defines a simple synth using a slightly detuned stereo squarewave oscillator
  with a percussive envelope. Accepts a MIDI note, duration (in secs) and volume."
  [note 60 dur 1.0 amp 1.0]
  (let [freq (midicps note)
        src (pulse [freq (* freq 0.51)])
        env (env-gen (perc (* 0.1 dur) dur amp) :action FREE)]
    (* src env)))

(comment
  ;; Testing 1,2,3...
  (fatso-saw)
  (fatso-pwm)
  ;; Testing the synth with different pitches & durations
  (fatso-saw 60 0.25)
  (fatso-saw 55 0.5)
  (fatso-saw 52 1.0)
  (fatso-saw 50 2.0)
  (fatso-saw 48 4.0)
  )

;; Let's build a preset for fatso with a very short duration (0.15 secs)...
(def knightrider #(fatso-saw % 0.15))

(comment
  ;; ...and play the whole thing pitched down by 1 octave (-12 semitones)
  (play-rhythmic-phrase-1 metro knightrider alt-rhythm 1/2 (map #(- % 12) progression))
  )

;; Now let's do some more rhythm related refactoring...
;; We tried to make it easy for ourselves and have play-rhythmic-phrase-1
;; applying the given rhythm to our melody during playback...
;;
;; However, now we'd like to do something more interesting and build a
;; simple arpeggiator, which plays each note twice (at double speed & different pitches)
;; and therefore also needs access to our rhythm (and manipulates it).
(defn arpeggiate
  "Takes a rhythm pattern and note sequence, applies the rhythm as template,
  but plays each note twice at double speed (once the original, followed by
  original one octave higher). Returns lazyseq of vector pairs [note duration]."
  [rhythm melody]
  (mapcat
   (fn [note dur] [[note (/ dur 2)] [(+ note 12) (/ dur 2)]])
   melody (cycle rhythm)))

;; Now (arpeggiate alt-rhythm pattern) produces this sequence of note/duration pairs:
;; => ([60 3/16] [72 3/16] [62 1/16] [74 1/16] [67 3/16] [79 3/16] ...)
;; Our play-rhythmic-phrase-1 function can't handle this data, so we need to rewrite it.
;; And we should also use this as an opportunity to create another fn with its sole
;; role of computing timestamps (in bar measure) for each of the notes in such a sequence
(defn rhythm-timings
  "Take a sequence of [note duration] pairs and computes timestamp (in bar measure)
  for each note. Returns another sequence [note time]."
  [factor phrase]
  (let [notes (map first phrase)
        durations (map second phrase)
        timings (reductions (fn[t d] (+ t (* d factor 4))) 0 durations)]
    (map (fn [n t] [n t]) notes timings)))

;; Finally, we remove any rhythm application from our playback fn and
;; have it deal only with scheduling of notes based on the rhythm
;; already present in the phrase.
(defn play-rhythmic-phrase-2
  [metro inst rhythm-phrase]
  (let [t0 (metro)
        play (fn [[n t]] (at (metro (+ t0 t)) (inst n)))]
    (dorun (map play rhythm-phrase))))

;; All together now:
;; Take the whole long phrase, pitch it -12, then arpeggiate with rhythm at double speed...
(def rhythmic-progression
  (->> progression
    (map #(- % 12))
    (arpeggiate rhythm)
    (rhythm-timings 1/2)))

(comment
  ;; Play it again, Sam (Aaron)! :)
  (play-rhythmic-phrase-2 metro knightrider rhythmic-progression)
  )

(defn inc-duration
  "Note timestamp transformation function to slowly increase note
  duration the further into the sequence a note is. Enforces min/max
  durations: 0.15 - 3.5 secs"
  [t]
  (min (max (* t 0.01) 0.15) 3.5))

(defn play-rhythmic-phrase-3
  "Like play-rhythmic-phrase-2 fn, but manipulates note durations by passing their
  timestamp through given transform fn."
  [metro inst transform rhythm-phrase]
  (let [t0 (metro)
        play (fn [[n t]] (at (metro (+ t0 t)) (inst n (transform t))))]
    (dorun (map play rhythm-phrase))))

(comment
  ;; https://soundcloud.com/toxi/res13-seq-2
  (play-rhythmic-phrase-3 metro fatso-saw inc-duration rhythmic-progression)
  ;; https://soundcloud.com/toxi/res13-seq1
  (play-rhythmic-phrase-3 metro fatso-pwm inc-duration rhythmic-progression)
  )
#+END_SRC
**   overtone.examples.workshops.resonate2013.ex02_bday
#+BEGIN_SRC clojure
(ns
  ^{:doc "Exploration of musical degrees & scales."
    :author "Karsten Schmidt"}
  overtone.examples.workshops.resonate2013.ex02_bday
  (:use
   [overtone.live]
   [overtone.inst.piano]))

(defn bpm
  "Higher order function. Returns another fn to compute the
  time offset in milliseconds for a beat at given `tempo`."
  [tempo]
  (fn [beat] (* (/ beat tempo) 60000)))

;; Next we encode a well know melody in an abstract manner
;; using musical degrees. Read this if you're unfamiliar with the concept:
;; http://en.wikipedia.org/wiki/Degree_(music)
;; Also highly recommended is this book for further contextualization:
;; http://www.amazon.co.uk/Quadrivium-Number-Geometry-Music-Heaven/dp/190715504X

(def melody
  "The Happy Birthday melody in scale-less musical degrees.
  The keyword :_ identifies a pause.
  Note durations are in bar measure (i.e. 1/4 = quarter note)."
  [;; Hap    py        birth      day        to        you
   [:v- 1/8] [:v- 1/8] [:vi- 1/4] [:v- 1/4]  [:i 1/4]  [:vii- 1/2]
   ;; Hap    py        birth      day        to        you
   [:v- 1/8] [:v- 1/8] [:vi- 1/4] [:v- 1/4]  [:ii 1/4] [:i 1/2]
   ;; Hap    py        birth      day        dear      Ri       car         do
   [:v- 1/8] [:v- 1/8] [:v 1/4]   [:iii 1/4] [:i 1/8]  [:i 1/8] [:vii- 1/4] [:vi- 1/4] [:_ 1/4]
   ;; Hap    py        birth      day        to        you
   [:iv 1/8] [:iv 1/8] [:iii 1/4] [:i 1/4]   [:ii 1/4] [:i 1/2]])

(defn play-tune
  "Takes an instrument, a sequence of notes and tempo (in bpm).
  Plays notes in separate thread."
  [inst bpm# root scale melody]
  (let [tempo (bpm bpm#)
        timings (reductions (fn[t [_ d]] (+ t (tempo (* d 4)))) (now) melody)
        root (note root)
        play-note (fn [timing [degree dur]]
                    (when-not (= :_ degree)
                      (at timing (inst (+ root (degree->interval degree scale))))))]
    (dorun (map play-note timings melody))))

(defn repeat-notes
  "Takes a melody sequence and repeats each note `n` times,
  with 1/n of its original duration. Returns new melody sequence."
  [n melody]
  (mapcat (fn [[deg dur]] (repeat n [deg (/ dur n)])) melody))

(defn arpeggiate
  "Similar to arpeggiate fn in the ex01_phrasestudy ns, but working with degrees
  instead of absolute notes and also supporting pauses. Since degrees are expressed
  as Roman numeral keywords (and not as number), we append `+` as suffix to indicate
  a note of the same degree only one octave higher."
  [n melody]
  (mapcat
   (fn [[deg dur]]
     (if-not (= :_ deg)
       (take n (cycle [[deg (/ dur n)] [(keyword (str (name deg) "+")) (/ dur n)]]))
       [[deg dur]]))
   melody))

(comment
  ;; Play the original Happy Birthday tune in F4 major
  (play-tune piano 120 :f4 :major melody)
  ;; The following experiments go ever further away from the original melody...
  ;; All this is only achieved through manipulating the original sequence
  ;; and/or choosing unusual scales. Since we only specified the melody in
  ;; degrees it will always be "in tune", regardless of scale changes
  (play-tune piano 120 :f4 :minor melody)
  (play-tune piano 120 :c4 :major (repeat-notes 2 melody))
  (play-tune piano 120 :c4 :major (arpeggiate 2 melody))
  (play-tune piano  60 :c4 :egyptian (arpeggiate 3 melody)) ; my favourite!
  (play-tune piano  60 :c4 :diminished (arpeggiate 4 (reverse melody)))
  )
#+END_SRC
**   overtone.examples.workshops.resonate2013.ex03_graph
#+BEGIN_SRC clojure
(ns
  ^{:doc "Brief intro to Incanter and concept of overtones/harmonics.
          Displays some graphs of how harmonics are used to
          generate different wave forms."
    :author "Karsten Schmidt"}
  overtone.examples.workshops.resonate2013.ex03_graph
  (:use [incanter core charts]))

(defn simple-plot
  "Creates a graph of `f` in the interval `x1` .. `x2`.
  Accepts an optional title."
  ([f x1 x2] (simple-plot f x1 x2 ""))
  ([f x1 x2 title]
    (view (function-plot f x1 x2 :title title))))

(defn plot-harmonics
  "Creates a graph of summing oscillator fn `f` over `n` octaves,
  in the interval `x1` .. `x2`."
  ([f n title]
    (plot-harmonics f n -10 10 title))
  ([f n x1 x2 title]
    (simple-plot
      (fn [x] (apply + (map-indexed f (repeat n x))))
      x1 x2 title)))

(defn saw-wave
  "Sawtooth uses overtones in each octave with exponentially
  decreasing impact."
  [i x] (let [i (inc i)] (* (Math/sin (* i x)) (/ 1.0 i))))

(defn sq-wave
  "Sawtooth uses overtones in only every 2nd octave with
  exponentially decreasing impact."
  [i x] (let [i (inc (* i 2))] (* (Math/sin (* i x)) (/ 1.0 i))))

(defn comb-wave
  "Like sq-wave, but flips sign for every 2nd harmonic."
  [i x]
  (let [ii (inc (* i 2))]
    (* (Math/sin (* ii x)) (/ (if (odd? i) 1.0 -1.0) ii))))

;; draw pretty pictures
(plot-harmonics saw-wave 20 "sawtooth")
(plot-harmonics sq-wave 20 "square")
(plot-harmonics comb-wave 20 "comb")

;; this graph shows the amplitude of overtones in each octave
(simple-plot #(/ 1.0 %) 1 10 "harmonic falloff")
#+END_SRC
**   overtone.examples.workshops.resonate2013.ex04_midi
#+BEGIN_SRC clojure
(ns
  ^{:doc "Mini example of using MIDI events to construct
          a baby drum machine using samples from freesound.org"
    :author "Karsten Schmidt"}
  overtone.examples.workshops.resonate2013.ex04_midi
  (:use [overtone.live]))

;; Here we define a map of MIDI notes to samples
;; You can use any freesound.org sample you wish, just change
;; the sample IDs found on the website
;; Samples will be downloaded automatically and cached in
;; the .overtone directory in your user/home folder
(def drum-kit
  ;; c4 = kick, d4 = snare, d#4 = clap, e4 = closed hh, f4 = open hh, g4 = cowbell
  (->> {:c4 2086 :d4 26903 :d#4 147597 :e4 802 :f4 26657 :g4 9780}
       (map (fn [[n sample-id]] [(note n) (freesound sample-id)]))
    (into {})))

;; First let's see which MIDI devices are connected...
(midi-connected-devices)

;; MIDI is event based...
;; For drums we only are interested in :note-on events
;; emitted when a key on any connected device is pressed
(on-event
 [:midi :note-on]
  ;; look up MIDI note in drumkit and only play if there's sample for it
  (fn [e] (when-let [drum (drum-kit (:note e))] (drum)))
  ::drumkit)

;; execute the below to remove the event handler later on...
(comment
  (remove-event-handler ::drumkit))
#+END_SRC
**   overtone.examples.workshops.resonate2013.ex05_synthesis
#+BEGIN_SRC clojure
(ns
    ^{:doc "A few examples of more complex audio synthesis,
           ported from SuperCollider to Overtone"}
  overtone.examples.workshops.resonate2013.ex05_synthesis
  (:use [overtone.live]))

;; First let's use a tweet by Juan A. Romero
;; (http://soundcloud.com/rukano)
;; This code is written in Supercollider's Smalltalk dialect:
;;
;; play{d=Duty;f=d.kr(1/[1,2,4],0,Dseq([0,3,7,12,17]+24,inf));GVerb.ar(Blip.ar(f.midicps*[1,4,8],LFNoise1.kr(1/4,3,4)).sum,200,8)}

(comment
  ;; A port to Overtone is almost equally succinct, but still hard to
  ;; understand...
  ;; https://soundcloud.com/toxi/rukanos-space-organ
  (demo 60 (g-verb (sum (map #(blip (* (midicps (duty:kr % 0 (dseq [24 27 31 36 41] INF))) %2) (mul-add:kr (lf-noise1:kr 1/2) 3 4)) [1 1/2 1/4] [1 4 8])) 200 8))

  ;; A more easy-on-the-eyes version would look like this:
  (demo 60
        (let [;; First create 3 frequency generators at different
              ;; tempos/rates [1 1/2 1/4]
              ;; Each generator will cycle (at its own pace) through the sequence of
              ;; notes given to dseq and convert notes into actual frequencies
              f (map #(midicps (duty:kr % 0 (dseq [24 27 31 36 41] INF))) [1 1/2 1/4])
              ;; Next we transpose the frequencies over several octaves
              ;; and create a band limited impulse generator (blip) for
              ;; each of the freq gens. The blip allows us to configure the number
              ;; of overtones/harmonics used, which is constantly modulated by a
              ;; noise generator between 1 and 7 harmonics...
              tones (map #(blip (* % %2) (mul-add:kr (lf-noise1:kr 1/4) 3 4)) f [1 4 8])]
          ;; finally, all tones are summed into a single signal
          ;; and passed through a reverb with a large roomsize and decay time...
          (g-verb (sum tones) 200 8)))
  )

;; The following synth is taken from Overtone's bundled examples and
;; based on a Supercollider script by Dan Stowells (w/ comments added by toxi)
;; Creates a dubstep synth with random wobble bassline, kick & snare patterns
(comment
  (demo 60
        (let [bpm 160
              ;; create pool of notes as seed for random base line sequence
              notes (concat (repeat 8 40) [40 41 28 28 28 27 25 35 78])
              ;; create an impulse trigger firing once per bar
              trig (impulse:kr (/ bpm 160))
              ;; create frequency generator for a randomly picked note
              freq (midicps (lag (demand trig 0 (dxrand notes INF)) 0.25))
              ;; switch note durations
              swr (demand trig 0 (dseq [1 6 6 2 1 2 4 8 3 3] INF))
              ;; create a sweep curve for filter below
              sweep (lin-exp (lf-tri swr) -1 1 40 3000)
              ;; create a slightly detuned stereo sawtooth oscillator
              wob (apply + (saw (* freq [0.99 1.01])))
              ;; apply low pass filter using sweep curve to control cutoff freq
              wob (lpf wob sweep)
              ;; normalize to 80% volume
              wob (* 0.8 (normalizer wob))
              ;; apply band pass filter with resonance at 5kHz
              wob (+ wob (bpf wob 5000 20))
              ;; mix in 20% reverb
              wob (+ wob (* 0.2 (g-verb wob 9 5 0.7)))
              ;; create impulse generator from given drum pattern
              kickenv (decay (t2a (demand (impulse:kr (/ bpm 30)) 0
                                          (dseq [1 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0] INF))) 0.7)
              ;; use modulated sine wave oscillator
              kick (* (* kickenv 7) (sin-osc (+ 40 (* kickenv kickenv kickenv 200))))
              ;; clip at max volume to create distortion
              kick (clip2 kick 1)
              ;; snare is just using gated & over-amplified pink noise
              snare (* 3 (pink-noise) (apply + (* (decay (impulse (/ bpm 240) 0.5) [0.4 2]) [1 0.05])))
              ;; send through band pass filter with peak @ 1.5kHz
              snare (+ snare (bpf (* 8 snare) 1500))
              ;; also clip at max vol to distort
              snare (clip2 snare 1)]
          ;; mixdown & clip
          (clip2 (+ wob kick snare) 1)))
  )
#+END_SRC
**   overtone.examples.workshops.resonate2013.ex06_quilstep
#+BEGIN_SRC clojure
(ns
  ^{:doc "Building a simple Quil/Processing based GUI for controlling
          a running Overtone synth. The GUI supports buttons and
          sliders, but can be extended with other control types."
    :author "Karsten Schmidt"}
  overtone.examples.workshops.resonate2013.ex06_quilstep
  (:require [quil.core :as q :refer [defsketch]])
  (:use [overtone.live]))

;; This atom will hold the ID of the currently playing dubstep synth instance
(def synth-ref (atom 0))

;; The actual dubstep synth (taken from
;; overtone.examples.instruments.dubstep namespace)
;; Also see ex05_synthesis for detailed comments
(defsynth dubstep [bpm 120 wobble 1 note 50 snare-vol 1 kick-vol 1 v 1]
 (let [trig (impulse:kr (/ bpm 120))
       freq (midicps note)
       swr (demand trig 0 (dseq [wobble] INF))
       sweep (lin-exp (lf-tri swr) -1 1 40 3000)
       wob (apply + (saw (* freq [0.99 1.01])))
       wob (lpf wob sweep)
       wob (* 0.8 (normalizer wob))
       wob (+ wob (bpf wob 1500 2))
       wob (+ wob (* 0.2 (g-verb wob 9 0.7 0.7)))
       kickenv (decay (t2a (demand (impulse:kr (/ bpm 30)) 0 (dseq [1 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0] INF))) 0.7)
       kick (* (* kickenv 7) (sin-osc (+ 40 (* kickenv kickenv kickenv 200))))
       kick (clip2 kick 1)
       snare (* 3 (pink-noise) (apply + (* (decay (impulse (/ bpm 240) 0.5) [0.4 2]) [1 0.05])))
       snare (+ snare (bpf (* 4 snare) 2000))
       snare (clip2 snare 1)]
   (out 0 (* v (clip2 (+ wob (* kick-vol kick) (* snare-vol snare)) 1)))))

(defn map-interval
  "Maps `x` from interval `in1`..`in2` into interval `out1`..`out2`."
  [x in1 in2 out1 out2]
  (+ out1 (* (/ (- x in1) (- in2 in1)) (- out2 out1))))

(defn in-rect?
  "Returns true if point [x y] is in rectangle."
  [x y [rx ry rw rh]]
  (and (>= x rx) (< x (+ rx rw)) (>= y ry) (< y (+ ry rh))))

(defn make-slider
  "Returns a map definition of a slider GUI widget.
  `handler` is a function accepting the new slider value."
  [handler v minv maxv x y w h label]
  {:handler handler
   :val v :min minv :max maxv
   :bounds [x y w h]
   :label label})

(defn make-button
  "Returns a map definition of a button GUI widget.
  `handler` is a no-arg function called when the button was pressed."
  [handler x y w h bg label]
  {:handler handler :bounds [x y w h] :bg bg :label label})

(defn make-key
  "Take a note id (0..11) and key color (0 = black, 1 = white),
  calls `make-button` with predefined handler to switch pitch of wobble
  bass in currently playing syth instance."
  [[n col]]
  (let [col (* 255 col)]
    (make-button #(ctl @synth-ref :note (+ (note :c2) n)) (+ 140 (* n 25))
                 20 25 50 [col col col] nil)))

(defn button-handler
  "Helper fn/wrapper for button handlers. Accepts a button and mouse pos
  calls button's handler fn if mouse was inside button's screen rect."
  [{:keys [bounds handler]} click-x click-y]
  (when (in-rect? click-x click-y bounds) (handler)))

;; Clojure compiler only does a single-pass, so we need to forward
;; declare the presence of the `sliders` symbol defined below
(declare sliders)

(defn slider-handler
  "Helper fn/wrapper for slider handlers. Accepts a slifer and mouse pos,
  updates slider value and calls slider's handler fn if mouse was inside
  slider's screen rect."
  [id {:keys [val min max bounds handler]} click-x click-y]
  (when (in-rect? click-x click-y bounds)
    (let [[x _ w] bounds
          new-val (map-interval click-x x (+ x w) min max)]
      (swap! sliders assoc-in [id :val] new-val)
      (handler new-val))))

(def buttons
  "Defines a list of buttons: play & stop and 12 piano keys for changing pitch."
  (concat
    [(make-button #(reset! synth-ref (:id (dubstep))) 20 20 50 50 [0 0 0] "play")
     (make-button stop 80 20 50 50 [0 0 0] "stop")]
    (map make-key (zipmap (range) [1 0 1 0 1 1 0 1 0 1 0 1]))))

(def sliders
  "Defines a map of sliders and their handlers to control the synth, all wrapped
  in an atom to allow for interactive updates of slider values."
  (atom {:tempo (make-slider (fn [x] (ctl @synth-ref :bpm x)) 120 80 180 20 80 200 20 "tempo")
         :wobble (make-slider (fn [x] (ctl @synth-ref :wobble (int x))) 1 1 16 20 110 200 20 "wobble")
         :amp (make-slider (fn [x] (ctl @synth-ref :v x)) 1.0 0.0 1.0 20 140 200 20 "volume")}))

(defn draw-slider
  "Takes a single slider map and draws it with optional label."
  [{:keys [val min max label] [x y w h] :bounds}]
  (let [x2 (+ x w)
        ymid (+ y (/ h 2))]
    (q/stroke 0)
    (q/line x ymid x2 ymid)
    (q/fill 255 255 0)
    (q/rect (- (map-interval val min max x x2) 5) y 10 20)
    (when label
      (q/fill 0)
      (q/text label (+ x w 20) (+ ymid 4)))))

(defn draw-button
  "Takes a single button map and draws it with optional label.
  (I.e. Piano keys don't have labels."
  [{label :label [r g b] :bg [x y w h] :bounds}]
  (q/fill r g b)
  (q/rect x y w h)
  (when label
    (q/fill 255 255 0)
    (q/text label (+ x 10) (+ y h -10))))

(defn draw []
  "Main draw function of the Quil sketch."
  (q/background 192)
  (doseq [b buttons] (draw-button b))
  (doseq [s (vals @sliders)] (draw-slider s)))

(defn mouse-pressed []
  "Mouse event handler. Checks & updates all GUI elements."
  (let [x (q/mouse-x) y (q/mouse-y)]
    (doseq [b buttons] (button-handler b x y))
    (doseq [[id s] @sliders] (slider-handler id s x y))))

;; Define & launch the Quil sketch...
(defsketch Resonate
  :size [460 180]
  :title "Resonate 2013 Quilstep"
  :draw draw
  :mouse-pressed mouse-pressed)
#+END_SRC
* contents of source-docs
[[file:~/Github-repos/overtone-source/docs/][file:~/Github-repos/overtone-source/docs/]]
** from sc-book
*** sc-one.clj
#+BEGIN_SRC clojure 
(ns sc-one
  (:use [overtone.live]))

;;page 4
;;play({SinOsc.ar(LFNoise0.kr(12, mul: 600, add: 1000), 0.3)})

(demo 10 (sin-osc (+ 1000 (* 600 (lf-noise0:kr 12))) 0.3))

;;;;;;;;
;;page 5
;;play({RLPF.ar(Dust.ar([12, 15]), LFNoise1.ar(1/[3,4], 1500, 1600), 0.02)})

(demo 10 (rlpf (dust [12 15]) (+ 1600 (* 1500 (lf-noise1 [1/3, 1/4]))) 0.02 ))



;;Page 6
;;///////////// Figure 1.1 Example of additive synthesis
;;
;;play({
;;        var sines = 5, speed = 6;
;;        Mix.fill(sines,
;;        	{arg x;
;;        		Pan2.ar(
;;        			SinOsc.ar(x+1*100,
;;        				mul: max(0,
;;        					LFNoise1.kr(speed) +
;;        					Line.kr(1, -1, 30)
;;        				)
;;        			), rand2(1.0))})/sines})
;;
;;/////////////



(demo 2 (let [sines 5
              speed 6]
           (* (mix
               (map #(pan2 (* (sin-osc (* % 100))
                              (max 0 (+ (lf-noise1:kr speed) (line:kr 1 -1 30))))
                           (- (clojure.core/rand 2) 1))
                    (range sines)))
              (/ 1 sines))))



;;Page 10
;;///////////// Figure 1.3 Fortuitous futuristic nested music.
;;
;;(
;;play(
;;        {
;;        	CombN.ar(
;;        		SinOsc.ar(
;;        			midicps(
;;        				LFNoise1.ar(3, 24,
;;        					LFSaw.ar([5, 5.123], 0, 3, 80)
;;        				)
;;        			),
;;        			0, 0.4),
;;        		1, 0.3, 2)
;;        }
;;)
;;)
;;
;;/////////////

(demo 10 (let [noise (lf-noise1 3)
               saws  (mul-add (lf-saw [5 5.123]) 3 80)
               freq  (midicps (mul-add noise 24 saws))
               src   (* 0.4 (sin-osc freq))]

           (comb-n src 1 0.3 2)))



;;;;;;;;;
;;Pages 15-16
;;(PMOsc.ar(440, MouseY.kr(1, 550), MouseX.kr(1, 15))}.play
;;{PMOsc.ar(100, 500, 10, 0, 0.5)}.play
;;
;;PMOsc isn't an actual ugen, it's actually a pseudo ugen defined for backwards
;;compatibility with older scsynth implementations. Its definition is as follows:
;;PMOsc  {
;;
;;        *ar { arg carfreq,modfreq,pmindex=0.0,modphase=0.0,mul=1.0,add=0.0;
;;                ^SinOsc.ar(carfreq, SinOsc.ar(modfreq, modphase, pmindex),mul,add)
;;        }
;;
;;        *kr { arg carfreq,modfreq,pmindex=0.0,modphase=0.0,mul=1.0,add=0.0;
;;                ^SinOsc.kr(carfreq, SinOsc.kr(modfreq, modphase, pmindex),mul,add)
;;        }
;;
;;}

(demo (* 0.5 (sin-osc 100 (* 10 (sin-osc 500 0)))))

;;we can use the pm-osc cgen provided by overtone:

(demo (* 0.5 (pm-osc 100 500 10 0)))
(demo 10 (pm-osc 440 (mouse-y:kr 1 550) (mouse-x:kr 1 15)))


;;Page 17
;;///////////// Figure 1.4 VCO, VCF, VCA
;;
;;(
;;{
;;        Blip.ar(
;;        	TRand.kr( // frequency or VCO
;;        		100, 1000, // range
;;        		Impulse.kr(Line.kr(1, 20, 60))), // trigger
;;        	TRand.kr( // number of harmonics or VCF
;;        		1, 10, // range
;;        		Impulse.kr(Line.kr(1, 20, 60))), // trigger
;;        	Linen.kr( // mul, or amplitude, VCA
;;        		Impulse.kr(Line.kr(1, 20, 60)), // trigger
;;        		0, // attack
;;        		0.5, // sustain level
;;        		1/Line.kr(1, 20, 60)) // trigger
;;        	)
;;}.play
;;)
;;
;;/////////////

(demo 10
      (let [trigger       (line:kr :start 1, :end 20, :dur 60)
            freq          (t-rand:kr :lo 100, :hi 1000, :trig (impulse:kr trigger))
            num-harmonics (t-rand:kr :lo 1,   :hi 10,   :trig (impulse:kr trigger))
            amp           (linen:kr :gate (impulse:kr trigger) :attack-time 0, :sus-level 0.5, :release-time (/ 1 trigger))]
        (* amp (blip freq num-harmonics))))



;;;;;;;;;
;;page 19
;;
;;
;;(
;;{
;;r = MouseX.kr(1/3, 10);
;;SinOsc.ar(mul: Linen.kr(Impulse.kr(r), 0, 1, 1/r))
;;}.play
;;)

(demo 10 (let [rate (mouse-x (/ 1 3) 10)
               amp  (linen:kr :gate (impulse:kr rate), :attack-time 0, :sus-level 1, :release-time (/ 1 rate))]
           (* amp (sin-osc))))



;;///////////// Example 1.5 Synthesis example with variables and statements
;;
;;(
;;// run this first
;;p = { // make p equal to this function
;;r = Line.kr(1, 20, 60); // rate
;;// r = LFTri.kr(1/10) * 3 + 7;
;;t = Impulse.kr(r); // trigger
;;// t = Dust.kr(r);
;;e = Linen.kr(t, 0, 0.5, 1/r); // envelope uses r and t
;;f = TRand.kr(1, 10, t); // triggered random also uses t
;;// f = e + 1 * 4;
;;Blip.ar(f*100, f, e) // f, and e used in Blip
;;}.play
;;)
;;
;;p.free;  // run this to stop it
;;
;;///////////// Figure 1.6 Phase modulation with modulator as ratio

(demo 10 (let [r (line:kr :start 1, :end 20, :dur 60)
               ;;r (+ 7 (* 3 (lf-tri:kr 0.1)))
               t (impulse:kr r)
               ;;t (dust:kr r)
               e (linen:kr :gate t, :attack-time 0, :sus-level 0.5, :release-time (/ 1 r))
               f (t-rand:kr :lo 1, :hi 10, :trig t)
               ;;f (* 4 (+ 1 e))
               ]
           (* e (blip :freq (* f 100), :numharm f))))


;;Page 21
;;///////////// Figure 1.6 Phase modulation with modulator as ratio
;;
;;(
;;{ // carrier and modulator not linked
;;        r = Impulse.kr(10);
;;        c = TRand.kr(100, 5000, r);
;;        m = TRand.kr(100, 5000, r);
;;        PMOsc.ar(c, m, 12)*0.3
;;}.play
;;)
;;
;;(
;;{
;;        var rate = 4, carrier, modRatio; // declare variables
;;        carrier = LFNoise0.kr(rate) * 500 + 700;
;;        modRatio = MouseX.kr(1, 2.0);
;;        // modulator expressed as ratio, therefore timbre
;;        PMOsc.ar(carrier, carrier*modRatio, 12)*0.3
;;}.play
;;)
;;
;;/////////////



(demo 10 (let [r (impulse:kr 10)
               c (t-rand:kr :lo 100, :hi 5000, :trig r)
               m (t-rand:kr :lo 100, :hi 5000, :trig r)]
           (* [0.3 0.3] (pm-osc c m 12 0))))

(demo 10 (let [rate 4
               carrier (+ 700 (* 500 (lf-noise0:kr rate)))
               mod-ratio (mouse-x :min 1, :max 2)]
           (* 0.3 (pm-osc carrier (* carrier mod-ratio) 12 9))))



;;Page 22
;;
;;SynthDef("sine", {Out.ar(0, SinOsc.ar)}).play
;;
;;SynthDef("sine", {Out.ar(1, SinOsc.ar)}).play // right channel
;;
;;// or
;;
;;(
;;SynthDef("one_tone_only", {
;;        var out, freq = 440;
;;        out = SinOsc.ar(freq);
;;        Out.ar(0, out)
;;}).play
;;)

(defsynth left-sine [] (out 0 (sin-osc)))
(left-sine)
(stop)

(defsynth right-sine [] (out 1 (sin-osc)))
(right-sine)
(stop)

(defsynth one-tone-only [] (let [freq 440
                                 src  (sin-osc freq)]
                             (out 0 src)))
(one-tone-only)
(stop)



;;Page 23
;;/////////////
;;
;;(
;;SynthDef("different_tones", {
;;        arg freq = 440; // declare an argument and give it a default value
;;        var out;
;;        out = SinOsc.ar(freq)*0.3;
;;        Out.ar(0, out)
;;}).play
;;)
;;
;;/////////////

(defsynth different-tones [freq 440]
  (let [src (* 0.3 (sin-osc freq))]
    (out 0 src)))

;;run all four, then stop all
(different-tones 550)
(different-tones 660)
(different-tones :freq 880)
(different-tones)
(stop)


;;tracking and controlling synths independently
(def a (different-tones :freq (midi->hz 64)))
(def b (different-tones :freq (midi->hz 67)))
(def c (different-tones :freq (midi->hz 72)))
(ctl a :freq (midi->hz 65))
(ctl c :freq (midi->hz 71))
(do
  (ctl a :freq (midi->hz 64))
  (ctl c :freq (midi->hz 72)))
(do
  (kill a)
  (kill b)
  (kill c))




;;Page 24
;;
;;///////////// Figure 1.7 Synth definition
;;
;;(
;;//run this first
;;SynthDef("PMCrotale", {
;;arg midi = 60, tone = 3, art = 1, amp = 0.8, pan = 0;
;;var env, out, mod, freq;
;;
;;freq = midi.midicps;
;;env = Env.perc(0, art);
;;mod = 5 + (1/IRand(2, 6));
;;
;;out = PMOsc.ar(freq, mod*freq,
;;        pmindex: EnvGen.kr(env, timeScale: art, levelScale: tone),
;;        mul: EnvGen.kr(env, timeScale: art, levelScale: 0.3));
;;
;;out = Pan2.ar(out, pan);
;;
;;out = out * EnvGen.kr(env, timeScale: 1.3*art,
;;        levelScale: Rand(0.1, 0.5), doneAction:2);
;;Out.ar(0, out); //Out.ar(bus, out);
;;
;;}).add;
;;)



(defsynth pmc-rotale [midi 60 tone 3 art 1 amp 0.8 pan 0]
  (let [freq (midicps midi)
        env (perc 0 art)
        mod (+ 5 (/ 1 (i-rand 2 6)))
        src (* (pm-osc freq (* mod freq) (env-gen:kr env :time-scale art, :level-scale tone) 0)
               (env-gen:kr env :time-scale art, :level-scale 0.3))
        src (pan2 src pan)
        src (* src (env-gen:kr env :time-scale (* art 1.3) :level-scale (ranged-rand 0.1 0.5) :action FREE))]
    (out 0 src)))

;;Synth("PMCrotale", ["midi", rrand(48, 72).round(1), "tone", rrand(1, 6)])

(pmc-rotale :midi (ranged-rand 48 72) :tone (ranged-rand 1 6))

;;Page 25
;;
;;~houston = Buffer.read(s, "sounds/a11wlk01-44_1.aiff");
;;~chooston = Buffer.read(s, "sounds/a11wlk01.wav");
;;
;;{PlayBuf.ar(1, ~houston)}.play;
;;{PlayBuf.ar(1, ~chooston)}.play;

;;this assumes you have a separate install of SuperCollider and
;;you're running OS X. Feel free to change the following audio paths
;;to any other audio file on your disk...

(def houston (load-sample "/Applications/SuperCollider/sounds/a11wlk01-44_1.aiff"))
(def chooston (load-sample "/Applications/SuperCollider/sounds/a11wlk01.wav"))

(demo 4 (play-buf 1 houston))
(demo 5 (play-buf 1 chooston))


;;Page 26
;;
;;[~houston.bufnum, ~houston.numChannels, ~houston.path, ~houston.numFrames];
;;[~chooston.bufnum, ~chooston.numChannels, ~chooston.path, ~chooston.numFrames];

;;samples are represented as standard clojure maps
houston
chooston



;;(
;;{
;;        var rate, trigger, frames;
;;        frames = ~houston.numFrames;
;;
;;        rate = [1, 1.01];
;;        trigger = Impulse.kr(rate);
;;        PlayBuf.ar(1, ~houston, 1, trigger, frames * Line.kr(0, 1, 60)) *
;;        EnvGen.kr(Env.linen(0.01, 0.96, 0.01), trigger) * rate;
;;}.play
;;)

(demo 60 (let [frames (num-frames houston)
              rate   [1 1.01]
              trigger (impulse:kr rate)
              src (play-buf 1 houston 1 trigger (* frames (line:kr 0 1 60)))
              env (env-gen:kr (lin 0.01 0.96 0.01) trigger)]
          (* src env rate)))

;; note how the envelope is used to stop clicking between segments. Contrast with the following

(demo 5 (let [frames (num-frames houston)
              rate   [1 1.01]
              trigger (impulse:kr rate)
              src (play-buf 1 houston 1 trigger (* frames (line:kr 0 1 60)))]
          (* src rate)))

;;( // speed and direction change
;;{
;;        var speed, direction;
;;        speed = LFNoise0.kr(12) * 0.2 + 1;
;;        direction = ]LFClipNoise.kr(1/3);
;;        PlayBuf.ar(1, ~houston, (speed * direction), loop: 1);
;;}.play
;;)

(demo 5 (let [speed     (+ 1 (* 0.2 (lf-noise0:kr 12)))
              direction (lf-clip-noise:kr 1/3)]
          (play-buf 1 houston (* speed direction) :loop 1)))


;; Page 27

;;( // if these haven't been used they will hold 0
;;~kbus1 = Bus.control; // a control bus
;;~kbus2 = Bus.control; // a control bus
;;{
;;        var speed, direction;
;;        speed = In.kr(~kbus1, 1) * 0.2 + 1;
;;        direction = In.kr(~kbus2);
;;        PlayBuf.ar(1, ~chooston, (speed * direction), loop: 1);
;;}.play
;;)
;;
;;(
;;// now start the controls
;;{Out.kr(~kbus1, LFNoise0.kr(12))}.play;
;;{Out.kr(~kbus2, LFClipNoise.kr(1/4))}.play;
;;)
;;// Now start the second buffer with the same control input buses,
;;// but send it to the right channel using Out.ar(1 etc.
;;
;;(
;;{
;;        var speed, direction;
;;        speed = In.kr(~kbus1, 1) * 0.2 + 1;
;;        direction = In.kr(~kbus2);
;;        Out.ar(1, PlayBuf.ar(1, ~houston, (speed * direction), loop: 1));
;;}.play;
;;)

(def kbus1 (control-bus))
(def kbus2 (control-bus))

(defsynth src []
  (let [speed (+ 1 (* 0.2 (in:kr kbus1 1)))
        direction (in:kr kbus2)]
    (out 0 (play-buf 1 chooston (* speed direction) :loop 1))))

(defsynth control1 []
  (out:kr kbus1 (lf-noise0:kr 12)))

(defsynth control2 []
  (out:kr kbus2 (lf-clip-noise:kr 1/4)))

(defsynth player []
  (let [speed (+ 1 (* 0.2 (in:kr kbus1 1)))
        direction (in:kr kbus2)]
    (out 1 (play-buf 1 houston (* speed direction) :loop 1))))

(do
  (src)
  (control1)
  (control2)
  (player))

(stop)

;; Page 28

;;~kbus3 = Bus.control;
;;~kbus4 = Bus.control;
;;{Out.kr(~kbus3, SinOsc.kr(3).range(340, 540))}.play;
;;{Out.kr(~kbus4, LFPulse.kr(6).range(240, 640))}.play;
;;SynthDef("Switch", {arg freq = 440; Out.ar(0, SinOsc.ar(freq, 0, 0.3))}).add
;;x = Synth("Switch");
;;x.map(\freq, ~kbus3)
;;x.map(\freq, ~kbus4)

(do

  (def kbus3 (control-bus))
  (def kbus4 (control-bus))

  (defsynth wave-ctl [] (out:kr kbus3 (lin-lin (sin-osc:kr 1) -1 1 340 540)))
  (defsynth pulse-ctl [] (out:kr kbus4 (lin-lin (sin-osc:kr 1) -1 1 240 640)))

  (defsynth switch [freq 440]
    (out 0 (sin-osc:ar freq 0 0.3)))

  (def s (switch))
  (def w (wave-ctl))
  (def p (pulse-ctl)))

;;try evaling these
(map-ctl s :freq kbus3)
(map-ctl s :freq kbus4)

(stop)


;; Page 29

;;(
;;{
;;        Out.ar(0,
;;            Pan2.ar( PlayBuf.ar(1, ~houston, loop: 1) *
;;                SinOsc.ar(LFNoise0.kr(12, mul: 500, add: 600)),
;;            0.5)
;;        )
;;}.play
;;)

(demo 10 (pan2 (* (play-buf 1 houston :loop 1)
                  (sin-osc (+ 600 (* 500 (lf-noise0:kr 12)))))
               0.5))

;;
;;(
;;{
;;        var source, delay;
;;        source = PlayBuf.ar(1, ~chooston, loop: 1);
;;        delay = AllpassC.ar(source, 2, [0.65, 1.15], 10);
;;        Out.ar(0, Pan2.ar(source) + delay)
;;}.play
;;)

(demo 10 (let [source (play-buf 1 chooston :loop 1)
               delay (allpass-c source 2 [0.65 1.15] 10)]
           (+ delay (pan2 source))))


;;//Create and name buses
;;~delay = Bus.audio(s, 2);
;;~mod = Bus.audio(s, 2);
;;~gate = Bus.audio(s, 2);
;;~k5 = Bus.control;
;;
;;~controlSyn= {Out.kr(~k5, LFNoise0.kr(4))}.play //start the control
;;
;;// Start the last item in the chain, the delay
;;~delaySyn = {Out.ar(0, AllpassC.ar(In.ar(~delay, 2), 2, [0.65, 1.15], 10))}.play(~controlSyn, addAction: \addAfter);
;;
;;// Start the next to last item, the modulation
;;~modSyn = {Out.ar(~delay, In.ar(~mod, 2) * SinOsc.ar(In.kr(~k5) * 500 + 1100))}.play(~delaySyn, addAction: \addBefore);
;;
;;//Start the third to last item, the gate
;;~gateSyn = {Out.ar([0, ~mod], In.ar(~gate, 2) * max(0, In.kr(~k5)))}.play(~modSyn, addAction: \addBefore);
;;
;;//make a group for the PlayBuf synths at the head of the chain
;;~pbGroup = Group.before(~controlSyn);
;;
;;// Start one buffer. Since we add to the group, we know where it will go
;;{Out.ar(~gate, Pan2.ar(PlayBuf.ar(1, ~houston, loop: 1), 0.5))}.play(~pbGroup);
;;
;;// Start the other
;;{Out.ar(~gate, Pan2.ar(PlayBuf.ar(1, ~chooston, loop: 1), -0.5))}.play(~pbGroup);

(do
  (def delay-b (audio-bus 2))
  (def mod-b (audio-bus 2))
  (def gate-b (audio-bus 2))
  (def k5-b (control-bus))

  (defsynth control-syn [] (out:kr k5-b (lf-noise0:kr 4)))
  (def c-syn (control-syn))

  (defsynth delay-syn [] (out:ar 0 (allpass-c (in delay-b 2) 2 [0.65 1.15] 10)))
  (def d-syn (delay-syn [ :after c-syn]))

  (defsynth mod-syn [] (out delay-b (* (in mod-b 2) (sin-osc (+ 1100 (* 500 (in:kr k5-b)))))))
  (def m-syn (mod-syn [:before d-syn]))

  (defsynth gate-syn [] (out [0 mod-b] (* (in gate-b 2) (max 0 (in:kr k5-b)))))
  (def g-syn (gate-syn [:before m-syn]))

  (def pb-group (group :before c-syn))

  (defsynth hous [] (out gate-b (pan2 (play-buf 1 houston :loop 1) 0.5)))
  (defsynth choos [] (out gate-b (pan2 (play-buf 1 chooston :loop 1) -0.5))))

(hous [:tail pb-group])
(choos [:tail pb-group])

(stop)


;; Page 32

;;// This uses the PMCrotale synth definition
;;(
;;a = ["C", "C#", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
;;"event, midi, pitch, octave".postln;
;;r = Task({
;;        inf.do({ arg count;
;;        	var midi, oct, density;
;;        	density = 1.0;
;;        	// density = 0.7;
;;        	// density = 0.3;
;;        	midi = [0, 2, 4, 7, 9].choose;
;;        	// midi = [0, 2, 4, 5, 7, 9, 11].choose
;;        	// midi = [0, 2, 3, 5, 6, 8, 9, 11].choose;
;;        	// midi = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].choose;
;;        	oct = [48, 60, 72].choose;
;;        	if(density.coin,
;;        	    { // true action
;;        		    "".postln;
;;        		    [midi + oct, a.wrapAt(midi),
;;        		    (oct/12).round(1)].post;
;;        		    Synth("PMCrotale",
;;        		    ["midi", midi + oct, "tone", rrand(1, 7),
;;        		    "art", rrand(0.3, 2.0), "amp", rrand(0.3, 0.6), "pan", 1.0.rand2]);
;;        	    }, {["rest"].post}); // false action
;;        	0.2.wait;
;;        });
;;}).start
;; )

(def cont (atom true))

(do
  (def a [:C :C# :D :Eb :E :F :F# :G :Ab :A :Bb :B])

  (future
    (loop []
      (let [density 1
            midi (choose [0 2 4 7 9])
            oct (choose [48 60 72])]
        (if (weighted-coin density)
          (do
            (println "")
            (println [(+ midi oct) (nth (cycle a) midi) (round-to (/ oct 12) 1)])
            (pmc-rotale :midi (+ midi oct)
                        :tone (ranged-rand 1 7)
                        :art (ranged-rand 0.3 2.0)
                        :amp (ranged-rand 0.3 0.6)
                        :pan (ranged-rand -1 1)))
          (println "rest"))
        (Thread/sleep 200)
        (when @cont (recur))))))

;; to stop
(reset! cont false)

;; Page 36

;;// Mix down a few of them tuned to harmonics
;;
;;(
;;{
;;        var fund = 220;
;;        Mix.ar(
;;        	[
;;        	SinOsc.ar(220, mul: max(0, LFNoise1.kr(12))),
;;        	SinOsc.ar(440, mul: max(0, LFNoise1.kr(12))) * 1/2,
;;              SinOsc.ar(660, mul: max(0, LFNoise1.kr(12))) * 1/3,
;;        	SinOsc.ar(880, mul: max(0, LFNoise1.kr(12))) * 1/4,
;;        	SinOsc.ar(1110, mul: max(0, LFNoise1.kr(12))) * 1/5,
;;        	SinOsc.ar(1320, mul: max(0, LFNoise1.kr(12))) * 1/6
;;        	]
;;        	) * 0.3
;;}.play
;;)

(demo 15
      (* 0.3
         (+ (* (sin-osc 220)  (max 0 (lf-noise1:kr 12)) 1)
            (* (sin-osc 440)  (max 0 (lf-noise1:kr 12)) 1/2)
            (* (sin-osc 660)  (max 0 (lf-noise1:kr 12)) 1/3)
            (* (sin-osc 880)  (max 0 (lf-noise1:kr 12)) 1/4 )
            (* (sin-osc 1110) (max 0 (lf-noise1:kr 12)) 1/5)
            (* (sin-osc 1320) (max 0 (lf-noise1:kr 12)) 1/6))))

;; or the more compact but equivalent:

(demo 15
      (let [freqs [220 440 660 880 1110 1320]
            muls  [1   1/2 1/3 1/4 1/5  1/6]
            mk-sin #(* (sin-osc %1) (max 0 (lf-noise1 12)) %2)
            sins  (map mk-sin freqs muls)]
        (* (mix sins) 0.3)))


;; Page 37

;;// And a patch
;;(
;;{
;;        Mix.ar(
;;            Array.fill(12,
;;                {arg count;
;;        	        var harm;
;;        	        harm = count + 1 * 110; //remember precedence; count + 1, then * 110
;;        	        SinOsc.ar(harm, mul: max([0, 0], SinOsc.kr(count + 1/4))) * 1/(count + 1)
;;                })
;;    )*0.7}.play
;;)

(demo 15
      (* 0.7
         (mix
          (for [count (range 12)]
            (let [harm (* (inc count) 110)]
              (* (sin-osc harm)
                 (max [0 0] (sin-osc:kr (/ (inc count) 4)))
                 (/ 1 (inc count))))))))


;; Page 38

;;(
;;{
;;        var scale, specs, freqs, amps, rings,
;;         numRes = 5, bells = 20, pan;
;;     scale = [60, 62, 64, 67, 69].midicps;
;;         Mix.fill(bells, {
;;                 freqs = Array.fill(numRes, {rrand(1, 15)*(scale.choose)});
;;                 amps = Array.fill(numRes, {rrand(0.3, 0.9)});
;;                 rings = Array.fill(numRes, {rrand(1.0, 4.0)});
;;                 specs = [freqs, amps, rings].round(0.01);
;;                 specs.postln;
;;                 pan = (LFNoise1.kr(rrand(3,6))* 2).softclip;
;;                 Pan2.ar(
;;                     Klank.ar(`specs,
;;                         Dust.ar(1/6, 0.03)),
;;                         pan)
;;         })
;;}.play;
;;)

(demo 10
      (let [num-res 5
            bells   20
            scale   (map midi->hz [60 62 64 67 69])
            mk-bell (fn [] (let [freqs (repeatedly num-res #(* (ranged-rand 1 5) (choose scale)))
                                amps  (repeatedly num-res #(ranged-rand 0.3 0.9))
                                rings (repeatedly num-res #(ranged-rand 1 4))
                                specs [freqs amps rings]
                                pan (softclip (* 2 (lf-noise1:kr (ranged-rand 3 6))))]
                            (pan2 (klank specs (* 0.03 (dust (/ 1 6)) ))
                                  pan)))]
        (out 0 (mix (repeatedly bells mk-bell)))))

#+END_SRC
*** sc-three.clj
#+BEGIN_SRC clojure 
(ns sc-three
  (:use [overtone.live]))

;; Helpers

;; This is the default synth. Is it accessible from Overtone?
(comment
                SynthDef(\default, { arg out=0, freq=440, amp=0.1, pan=0, gate=1;
                                var z;
                                z = LPF.ar(
                                                Mix.new(VarSaw.ar(freq + [0, Rand(-0.4,0.0), Rand(0.0,0.4)], 0, 0.3, 0.3)),
                                                XLine.kr(Rand(4000,5000), Rand(2500,3200), 1)
                                        ) * Linen.kr(gate, 0.01, 0.7, 0.3, 2);
                                OffsetOut.ar(out, Pan2.ar(z, pan, amp));
                }, [\ir])
)

(defsynth s [out 0 freq 440 amp 0.1 pan 0 gate 1]
  (let [z (* (lpf (mix (var-saw [freq (+ freq (ranged-rand -0.4 0.0)) (+ freq (ranged-rand 0.0 0.4))] 0 0.3 0.3))
                  (x-line:kr (ranged-rand 4000 5000) (ranged-rand 2500 3200) 1))
             (linen:kr gate 0.01 0.7 0.3 2))]
    (offset-out out (pan2 z pan amp))))

(defn release
  ([x releaseTime] (ctl x :gate (- releaseTime)))
  ([x] (release x 0.0)))

(defn wait-release
  ([x releaseTime] (if @x (release @x releaseTime) (recur x releaseTime)))
  ([x] (wait-release x 0.0)))

(defn generator [& thunks]
  (let [r (agent thunks)]
    #(if (seq @r)
       (do
         (send-off r (fn [ts] (when (seq ts) ((first ts))) (rest ts)))
         'ok)
       'done)))

;; Page 83
;; "foo" repeats every second
;; SystemClock.sched(0, {"foo".postln; 1.0});
(periodic 1000 #(println "foo"))
;; "bar" repeats at a random delay
;; SystemClock.sched(0, {"bar".postln; 1.0.rand});
(defn bar []
  (println "bar")
  (after-delay (rand-int 1000) #'bar))
(bar)
;; clear all scheduled events
;; SystemClock.clear;
(stop)

;; Page 85
(comment
  // Fermata
  (
   r = Routine ({
                 x = Synth(\default, [freq: 76.midicps]);
                 1.wait;

                 x.release(0.1);
                 y = Synth(\default, [freq: 73.midicps]);
                 "Waiting...".postln;
                 nil.yield; // fermata

                 y.release(0.1);
                 z = Synth(\default, [freq: 69.midicps]);
                 2.wait;
                 z.release();
                 });
   // do this then wait for the fermata
   r.play;
   // feel the sweet tonic...
   r.play;
  )
)

(def go
  (let [y (atom nil)]
   (generator
    (fn []
      (let [x (s :freq (midi->hz 76))]
        (after-delay
         1000
         #(do
            (release x 0.1)
            (reset! y (s :freq (midi->hz 73)))))))
    (fn []
      (wait-release y 0.1)
      (let [z (s :freq (midi->hz 69))]
        (after-delay
         2000
         #(release z)))))))
(go)
(go)


;; Page 88
///////////////////////////////////////////////////////////////
// Figure 3.3 Nesting tasks inside routines
(comment
(
r = Routine({
        c = TempoClock.new; // make a TempoClock
        // start a 'wobbly' loop
        t = Task({
                loop({
                        x.release(0.1);
                        x = Synth(\default, [freq: 61.midicps, amp: 0.2]);
                        0.2.wait;
                        x.release(0.1);
                        x = Synth(\default, [freq: 67.midicps, amp: 0.2]);
                        rrand(0.075, 0.25).wait; // random wait from 0.1 to 0.25 seconds
                });
        }, c); // use the TempoClock to play this Task
        t.start;
        nil.yield;

        // now add some notes
        y = Synth(\default, [freq: 73.midicps, amp: 0.3]);
        nil.yield;
        y.release(0.1);
        y = Synth(\default, [freq: 79.midicps, amp: 0.3]);
        c.tempo = 2; // double time
        nil.yield;
        t.stop; y.release(1); x.release(0.1); // stop the Task and Synths
});
)

r.next; // start loop
r.next; // first note
r.next; // second note; loop goes 'double time'
r.next; // stop loop and fade
)

(do
  (def cont (atom true))
  (def x (atom nil))
  (def y (atom nil))
  (def t (atom 1))

  (defn go1 []
    (when @x (release @x 0.1))
    (when @cont
      (reset! x (s :freq (midi->hz 61) :amp 0.2))
      (after-delay
       (/ 200 @t)
       #(do
          (release @x 0.1)
          (reset! x (s :freq (midi->hz 67) :amp 0.2))
          (after-delay
           (/ (ranged-rand 75 250) @t)
           #'go1)))))

  (defn go2 []
    (reset! y (s :freq (midi->hz 73) :amp 0.3)))

  (defn go3 []
    (release @y 0.1)
    (reset! y (s :freq (midi->hz 79) :amp 0.3))
    (reset! t 2))

  (defn go4 []
    (release @y 0.1)
    (reset! cont false))

  (def go (generator go1 go2 go3 go4))
)
(go)
(go)
(go)
(go)

;; Page 89
///////////////////////////////////////////////////////////////
// Figure 3.4 Using patterns within a task
(comment
(// random notes from lydian b7 scale
p = Pxrand([64, 66, 68, 70, 71, 73, 74, 76], inf).asStream;
// ordered sequence of durations
q = Pseq([1, 2, 0.5], inf).asStream;
t = Task({
        loop({
                x.release(2);
                x = Synth(\default, [freq: p.value.midicps]);
                q.value.wait;
        });
});
t.start;
)
t.stop; x.release(2);
)

(defn no-twice-in-a-row [s]
  (filter identity (map (fn [a b] (and (not= a b) a)) s (rest s))))

(do
  (def p (no-twice-in-a-row (chosen-from [64 66 68 70 71 73 74 76])))
  (def q (cycle [1000 2000 500]))

  (def cont (atom true))
  (def x (atom nil))

  (defn task [p q]
    (when @x (release @x 2))
    (when @cont
      (reset! x (s :freq (midi->hz (first p))))
      (apply-at
       (+ (now) (first q))
       #'task (rest p) (rest q) [])))

  (defn start-task []
    (reset! cont true)
    (task p q))

  (defn stop-task []
    (reset! cont false))
)
(start-task)
(stop-task)

;; Page 90
///////////////////////////////////////////////////////////////
// Figure 3.5 Thanks to polymorphism we can substitute objects that understand the same message
(comment
(
p = 64; // a constant note
q = Pseq([1, 2, 0.5], inf).asStream; // ordered sequence of durations
t = Task({
        loop({
                x.release(2);
                x = Synth(\default, [freq: p.value.midicps]);
                q.value.wait;
        });
});
t.start;
)
// now change p
p = Pseq([64, 66, 68], inf).asStream; // to a Pattern: do re mi
p = { rrand(64, 76) }; // to a Function: random notes from a chromatic octave
t.stop; x.release(2);
)

(do
  (def p (atom (fn [] 64)))
  (def q (cycle [1000 2000 500]))

  (def cont (atom true))
  (def x (atom nil))

  (defn task [q]
    (when @x (release @x 2))
    (when @cont
      (reset! x (s :freq (midi->hz (@p))))
      (apply-at
       (+ (now) (first q))
       #'task (rest q) [])))

  (defn start-task []
    (reset! cont true)
    (task q))

  (defn stop-task []
    (reset! cont false))
)
(start-task)
(reset! p (let [s (atom (cycle [64 66 68]))]
            (fn [] (first (swap! s rest)))))
(reset! p (fn [] (ranged-rand 64 77)))
(stop-task)

#+END_SRC
** clojure synthdef example
*** kick
#+BEGIN_SRC clojure 
(ns doc.kick
  (:use [overtone.live])
  (:use [overtone.sc.machinery.synthdef])
  (:use [clojure.pprint]))

;;This is an annotated version of this synth definition to help in understanding
;; some basics about synths and the synthdef data structure used in Overtone.

;; Here is a basic kick drum.  An envelope generator is multiplied by a low frequency
;; sin wave, which is like turning the volume knob up and down really quick while playing
;; a low tone.
(defsynth kick [amp 0.5 decay 0.6 freq 65]
  (let [env (env-gen (perc 0 decay) 1 1 0 1 FREE)
        snd (sin-osc freq (* Math/PI 0.5))]
    (out 0 (pan2 (* snd env amp) 0))))

;; This can be triggered using the name as a function call:
(kick)

;; A shorter variation using definst which allows you to leave out the out and pan ugens,
;; which get added by default to synths that are rooted by an audio rate ugen that isn't out.
(definst kick [amp 0.5 decay 0.6 freq 65]
  (* (sin-osc freq (* Math/PI 0.5))
     (env-gen (perc 0 decay) 1 1 0 1 FREE)
     amp))

;; Similarly this is also triggered using the name as a function call:
(kick)

;; The defsynth function will create a synthesizer definition structure that mimics the
;; binary format sent to the SuperCollider server.  These could also be created in other
;; ways, for example if you have in idea for a synthesizer DSL...

;; The structure is stored in each synth you create in a key called :sdef. So to retrieve
;; the structure of our kick synth we need to issue:
(:sdef kick)

;; This might be improved by pretty printing the result:
(synthdef-print (:sdef kick))

;; Here is the annotated output of (:sdef kick)
(pprint (:sdef kick))

{
 :name "kick",
 :n-params 3,             ; The number of controllable parameters
 :params [0.5 0.6 65.0],  ; default parameter values

 ;; The name of each parameter with the index of its default value in the :params vector.
 :n-pnames 3,
 :pnames [{:index 0, :name "amp"} {:index 1, :name "decay"} {:index 2, :name "freq"}],

 ;; All constant values used in the synth definition
 :n-constants 7,
 :constants [1.0 0.0 2.0 -99.0 5.0 -4.0 1.5707964]

 ; All the ugens in the order that they should execute in the DSP engine.  For the synth
 ; tree created by typical synthdefs we do a depth first iteration to sort the ugens.
 :n-ugens 7,
 :ugens
 [
  ; One control ugen is created for each rate of input parameters.  In this case all of
  ; the inputs are standard control rate (:kr) so we just have a single control.  A control
  ; is always the first ugen executed, and its named parameters can be modified at
  ; runtime.
  {:outputs [{:rate 1} {:rate 1} {:rate 1}],
   :inputs [],
   :special 0,     ; a 'special' number used to parameterize some UGens
   :n-outputs 3,   ; number of outputs
   :n-inputs 0,    ; number of inputs
   :rate 1,        ; operating rate for this ugen
   :name "Control" ; The SuperCollider UGen name
   }

  ; An envelope generator is used to control the amplitude of audio data or a
  ; ugen parameter.
  {:name "EnvGen",
   :rate 2,
   :special 0,
   :n-inputs 17,
   :n-outputs 1,
   :outputs [{:rate 2}], ; A vector of output rates for this ugen

   ; A vector of input specs used to connect up with the outputs of other ugens or
   ; constant values.  The :src field points to another ugen in this :ugens vector, and
   ; the :index points to a specific output of that ugen.  Using a :src of -1 means that
   ; the index points to a value in the :constants vector.
   :inputs [{:index 0, :src -1}
            {:index 0, :src -1}
            {:index 1, :src -1}
            {:index 0, :src -1}
            {:index 2, :src -1}
            {:index 1, :src -1}
            {:index 2, :src -1}
            {:index 3, :src -1}
            {:index 3, :src -1}
            {:index 0, :src -1}
            {:index 1, :src -1}
            {:index 4, :src -1}
            {:index 5, :src -1}
            {:index 1, :src -1}
            {:index 1, :src 0}
            {:index 4, :src -1}
            {:index 5, :src -1}]
   }

  ; A sin wave oscillator connected to the freq output value of the Control ugen
  ; and a constant.
  {:name "SinOsc",
   :rate 2,
   :special 0,
   :n-outputs 1,
   :n-inputs 2,
   :outputs [{:rate 2}],
   :inputs [{:index 2, :src 0}
            {:index 6, :src -1}]
   }

  ; Multiplying the sin-osc with the amplitude control value with the catch all
  ; binary-op-ugen.  Depending on the value of :special it will compute +, -, *, /,
  ; and around 30 other binary operators.  This is created by overloading these
  ; operators in clojure, so any arithmetic done on a ugen is converted to use
  ; this ugen object.
  {:name "BinaryOpUGen",
   :rate 2,
   :special 2,
   :n-outputs 1,
   :n-inputs 2,
   :outputs [{:rate 2}],
   :inputs [{:index 0,
             :src 2}
            {:index 0,
             :src 0}]
   }

  ; Multiplying the env and snd components
  {:name "BinaryOpUGen",
   :rate 2,
   :special 2,
   :n-outputs 1,
   :n-inputs 2,
   :outputs [{:rate 2}],
   :inputs [{:index 0, :src 3}
            {:index 0, :src 1}]
   }

  ; Takes an input source and outputs it in 2 channels with an adjustable
  ; pan control.
  {:name "Pan2",
   :rate 2,
   :special 0,
   :n-outputs 2,
   :n-inputs 3,
   :outputs [{:rate 2}
             {:rate 2}],
   :inputs [{:index 0, :src 4}
            {:index 1, :src -1}
            {:index 0, :src -1}]
   }

  ; Outputs the audio data from this synth and puts it onto an audio bus, which
  ; by default is bus zero, representing the sound-card.  If a vector of two channels
  ; are passed to the out ugen it will output in stereo, or 4 channels for 4 channel
  ; output on an audio interface, etc...
  {:name "Out",
   :rate 2,
   :special 0,
   :n-outputs 0,
   :n-inputs 3,
   :outputs [],
   :inputs [{:index 1, :src -1}
            {:index 0, :src 5}
            {:index 1, :src 5}]
   }],

 :n-variants 0,
 :variants [],
}

#+END_SRC
