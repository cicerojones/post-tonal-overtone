* develop post-tonal contributions to getting started.org
** load namespace to use sampled piano
 #+BEGIN_SRC clojure :session getting-started
(ns post-tonal-overtone.core)
 #+END_SRC

or rather:
#+BEGIN_SRC clojure :session getting-started :tangle yes
(ns post-tonal-overtone.core
  (:use overtone.live
        overtone.inst.sampled-piano
	clojure.repl))
#+END_SRC

#+RESULTS:
: nil

** building the dissonant piano player
*** testing out the piano
**** build piano chord player
  #+BEGIN_SRC clojure :session getting-started :tangle yes
(defn play-piano-chord [a-chord]
        (doseq [note a-chord] (sampled-piano note)))

(play-piano-chord [60 64 67])
 #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/play-piano-chordnil
**** build quieter piano chord player with variable dynamics
  #+BEGIN_SRC clojure :session getting-started :tangle yes
(defn play-quieter-piano-chord [a-chord]
  (let [level (rand-nth [0.05 0.1 0.2])]
    (doseq [note a-chord] (sampled-piano note :level level))))

(play-quieter-piano-chord [60 64 67])
 #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/play-quieter-piano-chordnil

*** load chord data and chord selection+transposition functions
**** load set data in the ./src/ directory

 #+BEGIN_SRC clojure :session getting-started :tangle yes
(load "set-class-data")
 #+END_SRC

 #+RESULTS:
 : nil

  #+BEGIN_SRC clojure :session getting-started :tangle yes
(rand-nth tetrachords)
  #+END_SRC 

  #+RESULTS:
  | 0 | 1 | 2 | 3 |
**** begin voicing chords and printingout
  #+BEGIN_SRC clojure :session getting-started :tangle yes
(defn voice-rand-set [set-type]
  (let [set (rand-nth set-type)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
        set-voicing-pair (list set voiced-set)]
    (do
      (println set-voicing-pair)
      set-voicing-pair)))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/voice-rand-set


 #+BEGIN_SRC clojure :session getting-started :tangle yes
(voice-rand-set tetrachords)
 #+END_SRC

 #+RESULTS:
 |  0 |  2 |  4 |  6 |
 | 48 | 74 | 40 | 66 |
**** begin selecting chords according to probability distr
***** segment set-type space into 4 components
#+BEGIN_SRC clojure :session getting-started :tangle yes
(def zero12s (subvec (vec tetrachords) 0 6))

(def dia1 (subvec (vec tetrachords) 7 11))

(def tri-heavy (subvec (vec tetrachords) 11 17))

(def whole-tones (subvec (vec tetrachords) 17  25))
#+END_SRC

#+RESULTS:
: #'post-tonal-overtone.core/zero12s#'post-tonal-overtone.core/dia1#'post-tonal-overtone.core/tri-heavy#'post-tonal-overtone.core/whole-tones


destructuring not working correctly

#+COMMENT does not work! do not tangle
#+BEGIN_SRC clojure :session getting-started :tangle no
(defn tetra-probs1 [[z x y w] dist]
  (let [n (rand)]
    (cond
      (>= n z) (rand-nth whole-tones)
      (>= n x) (rand-nth tri-heavy)
      (>= n y) (rand-nth dia1)
      (>= n w) (rand-nth zero12s)
      :else (rand-nth hexachords ))))
#+END_SRC

#+RESULTS:
: #'post-tonal-overtone.core/tetra-probs

how to construct the argument list?
#+BEGIN_SRC clojure :session getting-started :tangle yes
(tetra-probs1 0.8 0.5 0.2 0.1)
#+END_SRC

#+RESULTS:
***** create logic for random selection according to prob distribution
#+BEGIN_SRC clojure :session getting-started :tangle yes
(defn tetra-probs2 [z x y w]
  (let [n (rand)]
    (cond
      (>= n z) (rand-nth whole-tones)
      (>= n x) (rand-nth tri-heavy)
      (>= n y) (rand-nth dia1)
      (>= n w) (rand-nth zero12s)
      :else (rand-nth hexachords ))))
#+END_SRC

#+RESULTS:
: #'post-tonal-overtone.core/tetra-probs2

#+BEGIN_SRC clojure :session getting-started :tangle yes
(tetra-probs2 0.8 0.5 0.2 0.1)
#+END_SRC

#+RESULTS:
| 0 | 2 | 3 | 5 |

**** add fully functional transpositions and printout info
***** choose set randomly according to old logic
 #+BEGIN_SRC clojure :session getting-started :tangle yes
(defn voice-and-transpose-rand-set [set-type tn-level]
  (let [set (rand-nth set-type)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
	visible-pairings (map #(list % (mod % 12)) voiced-set)
        transposed-set (map #(+ tn-level %) voiced-set)
	paired-transposed-set (map #(list (mod % 12) (+ tn-level %)) (sort voiced-set))
        set-voicing-group (list :set set
                                :tn-level tn-level
				:reg visible-pairings
                                :sorted-trans paired-transposed-set)]
    (do
      (println set-voicing-group)
      #_set-voicing-group transposed-set)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/voice-and-transpose-rand-set
 #+BEGIN_SRC clojure :session getting-started :tangle yes
(voice-and-transpose-rand-set tetrachords 0 #_(rand-int 12))
 #+END_SRC

 #+RESULTS:
 | 60 | 37 | 39 | 77 |

***** choose set using new logic w prob. distribution
 #+BEGIN_SRC clojure :session getting-started :tangle yes
(defn voice-and-transpose-tetra-probs [tn-level]
  (let [set (tetra-probs2 0.8 0.5 0.2 0.1)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
	visible-pairings (map #(list % (mod % 12)) voiced-set)
        transposed-set (map #(+ tn-level %) voiced-set)
	paired-transposed-set (map #(list (mod % 12) (+ tn-level %)) (sort voiced-set))
        set-voicing-group (list :set set
                                :tn-level tn-level
				:reg visible-pairings
                                :sorted-trans paired-transposed-set)]
    (do
      (println set-voicing-group)
      #_set-voicing-group transposed-set)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/voice-and-transpose-tetra-probs

*** use play piano as above to play dissonances
 play-piano-chord will appear to want a vector!
see 'testing out the piano' subtree above
*** choose the set type for dissonances
**** play chords according to selection with old logic
 #+BEGIN_SRC clojure :session getting-started :tangle yes
(defn piano-dissonances1 [set-type]
  (let [notes (vec (voice-and-transpose-rand-set ; voicing
                 set-type ;tetrachords set-type, for instance
                       (rand-int 12)))]
    (play-piano-chord notes)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/piano-dissonances1


#+BEGIN_SRC clojure :session getting-started :tangle yes
(piano-dissonances1 pentachords)
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC clojure :session getting-started :tangle yes
(piano-dissonances1 hexachords)
#+END_SRC

#+RESULTS:
: nil
**** play chords selected according to prob distribution; use quieter playing function
 #+BEGIN_SRC clojure :session getting-started :tangle yes
(defn piano-dissonances3 []
  (let [notes (vec (voice-and-transpose-tetra-probs  ; voicing
                    (rand-int 12)))]
    (play-quieter-piano-chord notes)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/piano-dissonances3

#+BEGIN_SRC clojure :session getting-started :tangle yes
(piano-dissonances3)
#+END_SRC

#+RESULTS:
: nil

*** tetrachord piano dissonances; hard-coded set-type
 #+BEGIN_SRC clojure :session getting-started :tangle yes
(defn tetrachord-piano-dissonances2 []
   (let [notes (voice-and-transpose-rand-set ; voicing
                 tetrachords ;set-type, for instance
                       (rand-int 12))]
    (play-piano-chord notes)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/tetrachord-piano-dissonances2

 #+BEGIN_SRC clojure :session getting-started :tangle yes
(tetrachord-piano-dissonances2 )
 #+END_SRC

 #+RESULTS:
 : nil

** dealing with timing
*** making the dissonant piano player play in time
 note, this will be writing out to the repl!!! Why and where?
 Because that is how chord-progression-time8 works? Which is defined where?

 #+BEGIN_SRC clojure :session getting-started :tangle yes
(def metro (metronome 10))

(defn play-piano-dissonances2 [nome]
  (let [beat (nome)]
    (at (nome beat) (tetrachord-piano-dissonances2))
    (apply-at (nome (inc beat)) play-piano-dissonances2 nome [])))

(defn play-piano-dissonances3 [nome]
  (let [beat (nome)]
    (at (nome beat) (piano-dissonances3))
    (apply-at (nome (inc beat)) play-piano-dissonances3 nome [])))


;(play-piano-dissonances2 metro)
(play-piano-dissonances3 metro)
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/metro#'post-tonal-overtone.core/play-piano-dissonances3#<ScheduledJob id: 1, created-at: Mon 12:31:29s, initial-delay: 11990, desc: "Overtone delayed fn", scheduled? true>

 #+BEGIN_SRC clojure :session getting-started :tangle yes
(do (println '(0 1 2)))
 #+END_SRC

 #+RESULTS:
 : nil
