* develop post-tonal contributions to getting started.org
** building the dissonant piano player
*** testing out the piano
namespace

 #+BEGIN_SRC clojure :session getting-started
(ns post-tonal-overtone.core)
 #+END_SRC

  #+BEGIN_SRC clojure :session getting-started
(defn play-piano-chord [a-chord]
        (doseq [note a-chord] (sampled-piano note)))

(play-piano-chord [60 64 67])
 #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/play-piano-chordnil

  #+BEGIN_SRC clojure :session getting-started
(defn play-quieter-piano-chord [a-chord]
  (let [level (rand-nth [0.05 0.1 0.2])]
    (doseq [note a-chord] (sampled-piano note :level level))))

(play-quieter-piano-chord [60 64 67])
 #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/play-quieter-piano-chordnil

*** load chord data and chord selection+transposition functions
**** find set data in the ./src/ directory
 #+BEGIN_SRC clojure :session getting-started
(load "set-class-data")
 #+END_SRC

 #+RESULTS:
 : nil

  #+BEGIN_SRC clojure :session getting-started
(rand-nth *tetrachords*)
  #+END_SRC 

  #+RESULTS:
  | 0 | 1 | 4 | 5 |
**** begin voicing chords and printingout
  #+BEGIN_SRC clojure :session getting-started
(defn voice-rand-set [set-type]
  (let [set (rand-nth set-type)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
        set-voicing-pair (list set voiced-set)]
    (do
      (println set-voicing-pair)
      set-voicing-pair)))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/voice-rand-set


 #+BEGIN_SRC clojure :session getting-started
(voice-rand-set *tetrachords*)
 #+END_SRC

 #+RESULTS:
 |  0 |  1 |  2 |  3 |
 | 48 | 73 | 62 | 39 |
**** begin selecting chords according to probability distr
#+BEGIN_SRC clojure :session getting-started
(defn tetra-probs [[z x y w] dist]
  (let [n (rand)]
    (cond
      (>= n z) (rand-nth whole-tones)
      (>= n x) (rand-nth tri-heavy)
      (>= n y) (rand-nth dia1)
      (>= n w) (rand-nth zero12s)
      :else (rand-nth *hexachords* ))))
#+END_SRC

#+RESULTS:
: #'post-tonal-overtone.core/tetra-probs


#+BEGIN_SRC clojure :session getting-started
(tetra-probs [0.8 0.5 0.2 0.1])
#+END_SRC

#+RESULTS:

#+BEGIN_SRC clojure :session getting-started
(def zero12s (subvec (vec *tetrachords*) 0 6))

(def dia1 (subvec (vec *tetrachords*) 7 11))

(def tri-heavy (subvec (vec *tetrachords*) 11 17))

(def whole-tones (subvec (vec *tetrachords*) 17  25))
#+END_SRC
**** add fully functional transpositions and printout info
 #+BEGIN_SRC clojure :session getting-started
(defn voice-and-transpose-rand-set [set-type tn-level]
  (let [set (rand-nth set-type)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
	visible-pairings (map #(list % (mod % 12)) voiced-set)
        transposed-set (map #(+ tn-level %) voiced-set)
	paired-transposed-set (map #(list (mod % 12) (+ tn-level %)) (sort voiced-set))
        set-voicing-group (list :set set
                                :tn-level tn-level
				:reg visible-pairings
                                :sorted-trans paired-transposed-set)]
    (do
      (println set-voicing-group)
      #_set-voicing-group transposed-set)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/voice-and-transpose-rand-set
 #+BEGIN_SRC clojure :session getting-started
(voice-and-transpose-rand-set *tetrachords* 0 #_(rand-int 12))
 #+END_SRC

 #+RESULTS:
 | (0 1 3 6) | 0 | ((72 0) (37 1) (75 3) (66 6)) | ((1 37) (6 66) (0 72) (3 75)) |


*** use play piano as above to play dissonances
 play-piano-chord will appear to want a vector!
 #+BEGIN_SRC clojure :session getting-started
(defn play-piano-chord [a-chord]
  (doseq [note a-chord] (sampled-piano note)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/play-piano-chord
*** choose the set type for dissonances
 #+BEGIN_SRC clojure :session getting-started
(defn piano-dissonances1 [set-type]
  (let [notes (vec (voice-and-transpose-rand-set ; voicing
                 set-type ;*tetrachords* set-type, for instance
                       (rand-int 12)))]
    (play-piano-chord notes)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/piano-dissonances1

#+BEGIN_SRC clojure :session getting-started
(piano-dissonances1 *pentachords*)
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC clojure :session getting-started
(piano-dissonances1 *hexachords*)
#+END_SRC

#+RESULTS:
: nil
*** tetrachord piano dissonances
 #+BEGIN_SRC clojure :session getting-started
(defn tetrachord-piano-dissonances2 []
   (let [notes (voice-and-transpose-rand-set ; voicing
                 *tetrachords* ;set-type, for instance
                       (rand-int 12))]
    (play-piano-chord notes)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/tetrachord-piano-dissonances2

 #+BEGIN_SRC clojure :session getting-started
(tetrachord-piano-dissonances2 )
 #+END_SRC

 #+RESULTS:
 : nil
** making the dissonant piano player play in time
note, this will be writing out to the repl!!! Why and where?
Because that is how chord-progression-time8 works? Which is defined where?

#+BEGIN_SRC clojure :session getting-started
(def metro (metronome 10))

(defn play-piano-dissonances2 [nome]
  (let [beat (nome)]
    (at (nome beat) (tetrachord-piano-dissonances2))
    (apply-at (nome (inc beat)) play-piano-dissonances2 nome [])))


(play-piano-dissonances2 metro)
#+END_SRC

#+RESULTS:
: #'post-tonal-overtone.core/metro#'post-tonal-overtone.core/play-piano-dissonances2#<ScheduledJob id: 1, created-at: Fri 03:31:13s, initial-delay: 11990, desc: "Overtone delayed fn", scheduled? true>

#+BEGIN_SRC clojure :session getting-started
(do (println '(0 1 2)))
#+END_SRC

#+RESULTS:
: nil
** vary up the time in which things happen
