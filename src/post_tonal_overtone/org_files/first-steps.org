#+COMMENT prefer the other post-tonal project org files
* starting-up--basics
When viewing this in emacs org-mode, you will see results for running
any block code; however, these results will not appear on the github wiki.
** namespaces
*** starting up from a .clj source file
The key here will be having an functioning cider-repl open and
evaluating the whole file.

But, even more significantly, you will want to develop a strong
concept of how to instantiate a namespace, and how to load in any code
you want to be working with from WITHIN the namespace declaration.

Here's one good example.
#+BEGIN_SRC clojure
(ns post_tonal_overtone.core
  (:use overtone.live)
  (:require [post_tonal_overtone.data.set_class_data :as set-class]))
#+END_SRC
Here's a slightly more messed up one
#+BEGIN_SRC clojure
(ns post-tonal-overtone.core
  (:use overtone.live
        overtone.inst.sampled-piano
;;	post-tonal-overtone.set-class-data
;;	post-tonal-overtone
;;	org.clojure/math.combinatorics "0.1.1"
	clojure.repl))
#+END_SRC
#+BEGIN_SRC clojure

#+END_SRC
*** simple
 You'll discover that it is good practice to define a namespace at the
 beginning of a file of related code.

 #+BEGIN_SRC clojure :session getting-started :tangle yes
(in-ns 'post_tonal_overtone.core)
 #+END_SRC

 #+RESULTS:
 : #<Namespace post_tonal_overtone.core>

You can either call this in the CIDER repl, or from within a org-babel block.

Now, you should check to see what went down (especially in a babel
block where it might not be obvious). If you have called code in the
REPL but not within a Babel block you may not always be in the right
place (note a discrepancy here).

 #+BEGIN_SRC clojure :session getting-started :tangle yes 
*ns*
 #+END_SRC

 #+RESULTS:
 : #<Namespace user>

 #+BEGIN_SRC clojure :session getting-started :tangle yes
(in-ns 'post_tonal_overtone.core)
 #+END_SRC

 #+RESULTS:
 : #<Namespace post_tonal_overtone.core>

 #+BEGIN_SRC clojure :session getting-started
*ns*
 #+END_SRC

 #+RESULTS:
 : #<Namespace post_tonal_overtone.core>

*** eventually more complex, as you realize what your work will require
note, that this is for the Babel session for the "getting-started"
program. Maybe don't evaluate this unless you are working with a
strong sense of what your namespace situation is.

Note, that as [2015-04-14 Tue] the use of hyphens vs. underscore is at issue.


#+BEGIN_SRC clojure :session getting-started
;; (ns post-tonal-overtone.core
;;   (:use overtone.live
;;         overtone.inst.sampled-piano
;; 	post-tonal-overtone.set-class-data
;; ;;	post-tonal-overtone
;; ;;	org.clojure/math.combinatorics "0.1.1"
;; 	clojure.repl))
#+END_SRC

#+RESULTS:
: nil




 #+RESULTS:
 : #<Namespace post-tonal-overtone.core>

Note you can also just call this requirement in directly to whatever
namespace you happen to be in. Does this code cause nREPL to time out
for some reason?

#+BEGIN_SRC clojure :session getting-started
post_tonal_overtone.data.set_class_data/cmajtriads
#+END_SRC

#+RESULTS:
| 48 | 52 | 55 |
| 48 | 52 | 67 |
| 48 | 52 | 79 |
| 48 | 64 | 55 |
| 48 | 64 | 67 |
| 48 | 64 | 79 |
| 48 | 76 | 55 |
| 48 | 76 | 67 |
| 48 | 76 | 79 |
| 60 | 52 | 55 |
| 60 | 52 | 67 |
| 60 | 52 | 79 |
| 60 | 64 | 55 |
| 60 | 64 | 67 |
| 60 | 64 | 79 |
| 60 | 76 | 55 |
| 60 | 76 | 67 |
| 60 | 76 | 79 |
| 72 | 52 | 55 |
| 72 | 52 | 67 |
| 72 | 52 | 79 |
| 72 | 64 | 55 |
| 72 | 64 | 67 |
| 72 | 64 | 79 |
| 72 | 76 | 55 |
| 72 | 76 | 67 |
| 72 | 76 | 79 |

** test sound with definst noise 
*** a definst template (noise, non-pitched)
 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(definst noisey2 [attack 0.01 sustain 0.4 release 0.1 vol 0.4 length 3] 
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (pink-noise) ; also have (white-noise) and others...
     vol))

(noisey2)
 #+END_SRC

 #+RESULTS:
 : #<instrument: noisey2>#<synth-node[loading]: post_tonal_overtone.485/noisey2 1575>

*** definst can take an envelope for scaling the ugen output--using lin
use of lin presents several default keyword args, when called for env-gen
#+BEGIN_SRC clojure 
(lin :attack :sustain :release :level :curve)
#+END_SRC

#+RESULTS:
| 0 | 3 | -99 | -99 | :curve | :attack | 1 | 0 | :curve | :release | 1 | 0 | 0 | 1 | 1 | 0 |

*** scale output using an env-gen
#+BEGIN_SRC clojure
;; not for evaluating?
(env-gen :envelope :gate :level-scale :level-bias :time-scale :action)
#+END_SRC

#+RESULTS:

*** define constant pink noise
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(definst noisey-sustained [vol 0.5] 
  (* (pink-noise) ; also have (white-noise) and others...
     vol))

(noisey-sustained 1)
  #+END_SRC

  #+RESULTS:
  : #<instrument: noisey-sustained>#<synth-node[loading]: post_tonal_485/noisey-sustained 7894>

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(stop)
  #+END_SRC

  #+RESULTS:
  : nil

* producing basic sounds
** play long white noise
We now call the above function with parameters.
*** example--10 second version, long release?

experimenting with different parameter values reveals that the
mechanics of ~env-gen~ function are not entirely clear. An attack of
'1' and sustain of '0' would seem weirder than what sounds.

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(noisey2 :attack 1 :sustain 0 :release 0.5 :vol 0.3 :length 10)
  #+END_SRC

  #+RESULTS:
  : #<synth-node[loading]: post_tonal_overtone.485/noisey2 1576>
** build some synth instruments for playing chords
Really understanding `definst` will take some time. Here are some
quick sound examples that use `sin-osc` and `saw` to produce those
respective waveforms.

 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(definst sin3 [freq 880 attack 0.1 sustain 0.15 release 0.25 vol 0.4 length 5]
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (sin-osc freq)
     vol))

(sin3)
 #+END_SRC

 #+RESULTS:
 : #<instrument: sin3>#<synth-node[loading]: post_tonal_overtone.core/sin3 62>

 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(definst saw1 [freq 880 attack 0.1 sustain 0.15 release 0.25 vol 0.4 length 5]
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (saw freq)
     vol))

(saw1)
 #+END_SRC

 #+RESULTS:
 : #<instrument: saw1>#<synth-node[loading]: post_tonal_overtone.core/saw1 63>

* develop chords progressions 
Because I am interested in post-tonal music, the following is about
how to incorporate such sounds into overtone projects.
** start working with post tonal set classes
*** getting-started babel session
note, this will only work if...you are in the proper namespace. What
that really means is...don't do this. 

Make sure that your data is loaded in a namespace declaration, i.e.
don't call this.
 #+BEGIN_SRC clojure :session getting-started :tangle yes 
;; (load "set-class-data")
 #+END_SRC

** make a function to work with sets
 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn voice-and-transpose-rand-set [set-type tn-level]
  (let [set (rand-nth set-type)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
        transposed-set (map #(+ tn-level %) voiced-set)
        set-voicing-group (list set voiced-set tn-level transposed-set)]
    (do
      (println set-voicing-group)
      (last set-voicing-group))))
 #+END_SRC

 #+RESULTS:
 : #'post_tonal_overtone.core/voice-and-transpose-rand-set

** play chords using above sin wave instrument
*** doseq chord tones by giving sin3 midi-converted hz values
 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn play-chord-sin2 [a-chord]
  (doseq [note a-chord] (sin3 (midi->hz note))))
 #+END_SRC

 #+RESULTS:
 : #'post_tonal_overtone.core/play-chord-sin2

 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(sin3 330)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post_tonal_overtone.core/sin3 7896>

 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(sin3 (midi->hz 96))
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post_tonal_overtone.core/sin3 66>

 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(play-chord-sin2 [64 76 81 86 91 96 101])
 #+END_SRC

 #+RESULTS:
 : nil

#+COMMENT why do you want to hear an extremely high pitched sin wave?
 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(definst med96 [] (* 0.01 (sin-osc (midi->hz 96))))

(med96)
 #+END_SRC

 #+RESULTS:
 : #<instrument: med96>

* begin creating scheduled events
To really understand how to use scheduling we'll need to look at some
other files that are dedicated to this pursuit. For now, here are some
quick examples
** old experiments
*** use 'at' to schedule chord events
Simply, we can use the `at` function to schedule some events relative
to a given starting point (which will be determined by calling `now`).
Note, that we hard-coding in the offsets, which means that this won't
be especially useful for more than a few listens. 

However, it neatly demonstrates that time can be quite nicely
quanitified--here in milliseconds.
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time1 []
  (let [time (now)]
    (at time          (play-chord-sin2 [68 81 46 50 88]))
    (at (+ 2000 time) (play-chord-sin2 [80 69 46 73 86]))
    (at (+ 4000 time) (play-chord-sin2 [68 59 48 85 64]))
    (at (+ 6000 time) (play-chord-sin2 [68 69 72 87 52]))
    (at (+ 8000 time) (play-chord-sin2 [89 55 45 60 62]))))

(chord-progression-time1)
  #+END_SRC
** test out a single chord player
*** this functionality has largely been superseded elsewhere
This provides sets of pitches to a sine instrument. The pitches are
chosen with the above machinery.
 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn sine-tetra-diss []
  (doseq [notes (voice-and-transpose-rand-set ; voicing
                 set-class/tetrachords
                       (rand-int 12))]
    (sin3 (midi->hz notes))))

(sine-tetra-diss)
 #+END_SRC

 #+RESULTS:
 : #'post_tonal_overtone.core/sine-tetra-dissnil





  #+RESULTS:
  : #'post_tonal_overtone.core/chord-progression-time1nil

*** test out single event versions using 'at'
 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time2 [inst]
  (let [time (now)]
    (at time (inst :attack 0.15 :sustain 0.2 :release 0.4 :vol 0.5 :length 10))))

(chord-progression-time2 sin3)
 #+END_SRC

 #+RESULTS:
 : #'post_tonal_overtone.core/chord-progression-time2#<synth-node[loading]: post_tonal_overtone.core/sin3 99>


 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(chord-progression-time2 saw1)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post_tonal_overtone.core/saw1 100>

*** establish a beat for scheduling events using metronome
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(def metro (metronome 60))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/metro

*** define and use a chord progression player--use 'apply-at'

 Note that this uses the sine-tetra-diss as a hard-coded 'instrument',
 or rather an instrumentalist.
  # the best one yet

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time8 [nome]
  (let [beat (nome)]
    (at (nome beat) (sine-tetra-diss))
    (apply-at (nome (inc beat)) chord-progression-time8 nome [])))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/chord-progression-time8

  # to paraphrase "A Foggy Day", how long can this thing last?

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(chord-progression-time8 metro)
  #+END_SRC

  #+RESULTS:
  : #<ScheduledJob id: 1, created-at: Tue 05:51:04s, initial-delay: 1069, desc: "Overtone delayed fn", scheduled? true>

*** use sawtooth synth to play various chords
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(map saw1 (map #(midi->hz %) (last (voice-rand-set *pentachords*))))
  #+END_SRC

  #+RESULTS:
  : '(#<synth-node(loading): post-tonal-overtone.core/saw1 1126> #<synth-node(loading): post-tonal-overtone.core/saw1 1127> #<synth-node(loading): post-tonal-overtone.core/saw1 1128> #<synth-node(loading): post-tonal-overtone.core/saw1 1129> #<synth-node(loading): post-tonal-overtone.core/saw1 1130>)

*** chord progression number 3--sawtooth intensive

  a lot of repetition with this one
  # apply-at appears to cause problems when attempting to
  # call a functions that takes more than one argument

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time3 [nome]
  (let [beat (nome)]
    (at (nome beat)
        (doseq [note (rand-nth [[60 61 62] [60 49 51 55 44]])]
          (saw1 (midi->hz note))))
    (apply-at (nome (inc beat)) chord-progression-time3 nome [])))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/chord-progression-time3

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(chord-progression-time3 metro)
  #+END_SRC

  #+RESULTS:
  : #<ScheduledJob id: 1, created-at: Tue 05:47:31s, initial-delay: 1872, desc: "Overtone delayed fn", scheduled? true>

*** chord progression 4
  # loops through random tetrachords without printing

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time4 [nome]
  (let [beat (nome)]
    (at (nome beat)
        (doseq [notes (voice-and-transpose-rand-set ; voicing
                       *tetrachords* ; set-type
                       (rand-int 12))]
          (saw1 (midi->hz notes))))
    (apply-at (nome (inc beat)) chord-progression-time4 nome [])))
  #+END_SRC

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(chord-progression-time4 metro)
  #+END_SRC

*** chord progression 5
  # hack to get around the apply-at problem


  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time5 [nome]
  (let [beat (nome)]
    (at (nome beat)
        (doseq [note (rand-nth some-midis)]
          (saw1 (midi->hz note))))
    (apply-at (nome (inc beat)) chord-progression-time5 nome [])))
  #+END_SRC

*** use a set of pitched chords
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(def some-midis [[72 61 50 46] [60 49 51 55 44] [74 63 52 68] [42 79
70 61]])
  #+END_SRC

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(chord-progression-time5 metro)
  #+END_SRC

*** define a sawtooth random chord player
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn saw-diss []
  (doseq [notes (voice-and-transpose-rand-set ; voicing
                       *tetrachords* ; set-type
                       (rand-int 12))]
    (saw1 (midi->hz notes))))
  #+END_SRC


  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(saw-diss)
  #+END_SRC



  # also good, only prints first chord

*** chord progression 6
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time6 [nome]
  (let [beat (nome)]
    (at (nome beat) (saw-diss))
    (apply-at (nome (inc beat)) chord-progression-time6 nome [])))
  #+END_SRC

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(chord-progression-time6 metro)
  #+END_SRC

*** chord progression 7
  # broken? because of apply-at problem?


  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time7 [nome sound]
  (let [beat (nome)]
    (at (nome beat) sound)
    (apply-at (nome (inc beat)) chord-progression-time7 nome sound
[])))
  #+END_SRC

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(chord-progression-time7 metro saw-diss)
  #+END_SRC

*** develop a looping function

 The use of "metro" hardcoded in causes problems?
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn looper [sound]    
    (let [beat (metro)]
        (at (metro beat) (sound))
        (apply-at (metro (inc beat)) looper sound [])))
  #+END_SRC

  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(looper (play-chord-sin2 '(80 69 46 73 86)))
  #+END_SRC

  #+RESULTS:

*** make a sawtooth chord player
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn play-chord-saw1 [a-chord]
  (doseq [note a-chord] (saw1 (midi->hz note))))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/play-chord-saw1

*** define a preselected set of chords for progression 9
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time9 []
  (let [time (now)]
    (at time          (play-chord-saw1 [68 81 46 50 88]))
    (at (+ 2000 time) (play-chord-saw1 [80 69 46 73 86]))
    (at (+ 4000 time) (play-chord-saw1 [68 59 48 85 64]))
    (at (+ 6000 time) (play-chord-saw1 [68 69 72 87 52]))
    (at (+ 8000 time) (play-chord-saw1 [89 55 45 60 62]))))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/chord-progression-time9


  #+BEGIN_SRC clojure :session getting-started :tangle yes             
(chord-progression-time9)
  #+END_SRC

  #+RESULTS:
  : nil

*** refactor chord progressions to use a player-fn
  #+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-progression-time10 [player-fn]
  (let [time (now)]
    (at (+ 0.00 time) (player-fn [68 81 46 50 88]))
    (at (+ 2000 time) (player-fn [80 69 46 73 86]))
    (at (+ 4000 time) (player-fn [68 59 48 85 64]))
    (at (+ 6000 time) (player-fn [68 69 72 87 52]))
    (at (+ 8000 time) (player-fn [89 55 45 60 62]))))
  #+END_SRC


  #+BEGIN_SRC clojure :session getting-started :tangle yes             
(chord-progression-time10 play-chord-saw1)
  #+END_SRC

** from the 'sequencing' wiki tutorial
*** use kick on each beat of a metronome
#+BEGIN_SRC clojure
(def kick (sample (freesound-path 2086)))

; setup a tempo for our metronome to use
(def forty-bpm (metronome 40))

; this function will play our sound at whatever tempo we've set our metronome to 
(defn looper [nome sound]    
    (let [beat (nome)]
        (at (nome beat) (sound))
        (apply-by (nome (inc beat)) looper nome sound [])))

; turn on the metronome
(looper forty-bpm kick)
#+END_SRC

#+RESULTS:
: #'post-tonal-overtone.core/kick#'post-tonal-overtone.core/one-twenty-bpm#'post-tonal-overtone.core/looper#<ScheduledJob id: 1, created-at: Mon 05:02:32s, initial-delay: 2694, desc: "Overtone delayed fn", scheduled? true>
#+BEGIN_SRC clojure
(stop)

#+END_SRC

#+RESULTS:
: nil

*** startup a metronome and check in with its beats as it runs
#+BEGIN_SRC clojure
; to get a feel for how the metronome works, try defining one at the REPL
(def nome (metronome 200))
#+END_SRC

#+BEGIN_SRC clojure
(nome)
#+END_SRC

#+RESULTS:
: 284

#+BEGIN_SRC clojure :session getting-started
; setup a tempo for our metronome to use
(def forty-bpm (metronome 40))

; this function will play our sound at whatever tempo we've set our metronome to 
(defn looper [nome sound]    
    (let [beat (nome)]
        (at (nome beat) (sound))
        (apply-by (nome (inc beat)) looper nome sound [])))

;; turn on the metronome 
;; uh, where is 'piano' anything defined?
(looper forty-bpm (play-quieter-piano-chord (map #(+ % 60) (repeatedly 6 (partial rand-int 12)))))
#+END_SRC

#+RESULTS:
: #'post-tonal-overtone.core/forty-bpm#'post-tonal-overtone.core/looper

#+BEGIN_SRC clojure
(defn foo [t freq]
  (at t (sin3 freq))
  (let [next-t (+ t 3000)
        next-f (+ freq 10)]
    (apply-by next-t #'foo [next-t next-f])))

(foo (now) 40)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 1, created-at: Mon 05:35:33s, initial-delay: 0, desc: "Overtone delayed fn", scheduled? false>

this one, using sin3 as defined above, gradually steps up and up
through the frequencies from a given fundamental
#+BEGIN_SRC clojure
(defn foo [t freq]
  (at t (sin3 freq))
  (let [next-t (+ t 6000)
        next-f (+ freq 10)]
    (apply-by next-t #'foo [next-t next-f])))

(foo (now) 40)
#+END_SRC
* miscellaneous utilities and problems
** all caps is a problem--clojure is case sensitive
#+BEGIN_SRC clojure :session getting-started :tangle yes 
(LET [TIME (NOW) ]
     (
      (AT (+ 0 TIME) (PLAYER-FN '(1 2 3)))
      (AT (+ 1000 TIME) (PLAYER-FN '(4 5 6)))))
#+END_SRC


# downcase


#+BEGIN_SRC clojure :session getting-started :tangle yes 
(defn chord-prog-time11 [player-fn]
  (let [TIME (NOW) ] 
       (AT (+ 0 TIME) (PLAYER-FN '(68 81 46 50 88)))
       (AT (+ 1000 TIME) (PLAYER-FN '(80 69 46 73 86)))
       (AT (+ 2000 TIME) (PLAYER-FN '(68 59 48 85 64)))
       (AT (+ 3000 TIME) (PLAYER-FN '(68 69 72 87 52)))
       (AT (+ 4000 TIME) (PLAYER-FN '(89 55 45 60 62)))))
#+END_SRC


#+BEGIN_SRC clojure :session getting-started :tangle yes 
(stop)
#+END_SRC

#+RESULTS:
: nil

