* stop all sound
#+BEGIN_SRC clojure
(stop)
#+END_SRC

#+RESULTS:
: nil

* get your overtone and org environment running
** basic overtone startup and test from org-mode
Don't boot an internal server, but connect to an already started instance.

Doesn't always work as expected? Make sure not just that *WorkSpace*
is open but that the server has reported back in the *PostBuffer*
#+BEGIN_SRC clojure :results silent
(use 'overtone.core)
#+END_SRC

#+BEGIN_SRC clojure :results silent
;; connect to an existing one, 
;; always on 57110, so no need to specify
(connect-external-server 57110)
#+END_SRC

#+RESULTS:
: :happy-hacking

** start some where--demo a sin-osc
#+BEGIN_SRC clojure
(demo 5 (sin-osc))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: user/audition-synth 57>

** make it easy to use org and emacs with kmacros
Set Cmd-F7 to call stop--requires correct navigation within this
buffer

#+BEGIN_SRC elisp
  (fset 'overtone-call-stop-from-buffer-beginning
        (lambda (&optional arg) "Keyboard macro." 
          (interactive "p") 
          (kmacro-exec-ring-item 
           (quote ([67108896 67108896 134217788 3 22 14 3 3 134217788 tab 21 67108896 21 67108896] 0 "%d")) arg)))
  (global-set-key [s-f7] 'overtone-call-stop-from-buffer-beginning)
#+END_SRC

#+RESULTS:
: overtone-call-stop-from-buffer-beginning

Use a repl to call (stop)
#+BEGIN_SRC elisp
(fset 'overtone-call-stop-in-repl
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([24 98 99 105 100 101 114 45 114 101 112 108 return 40 115 116 111 112 return 24 98 return] 0 "%d")) arg)))

(global-set-key [s-f7] 'overtone-call-stop-in-repl)
#+END_SRC

* use definst
** a simple noise with no real parameters
#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(definst anoise [vol 0.5]
  (* (pink-noise)
     vol))

(anoise)
#+END_SRC

#+RESULTS:
: #<instrument: anoise>#<synth-node[loading]: user/anoise 58>

** find a good way to consistently stop sounds when exploring
#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(kill anoise)
#+END_SRC

#+RESULTS:
: nil

* make a definst with more parameters
** use a "env-gen" Ugen
 #+BEGIN_SRC clojure :session getting-started :tangle yes 
(definst noisey [attack 0.01 sustain 0.4 release 0.1 vol 0.4 length 3] 
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (pink-noise) ; also have (white-noise) and others...
     vol))

(noisey)
 #+END_SRC

 #+RESULTS:
 : #<instrument: noisey>#<synth-node[loading]: user/noisey 43>

** consider the some underappreciated differences about the sounds you will make
UGen vs. SynthNode!
#+BEGIN_SRC clojure
(type (sin-osc))
#+END_SRC

#+RESULTS:
: overtone.sc.machinery.ugen.sc_ugen.SCUGen

#+BEGIN_SRC clojure
(type (noisey))
#+END_SRC

#+RESULTS:
: overtone.sc.node.SynthNode

** "Tour the Ugens?" or develop a system for exploration
Understanding what "insts" and "synths" are, what to put in them, and
how to put together all the ugens in some way that makes it fun and
meaningful to achieve your sonic goals is not easy.

For me, it is essential to be able to interact with sounds once they
are going. The most intuitive way for me to do that is with a
keyboard. Which means we'll want to get jumping on MIDI controller interactions.

* control sound in real time
** are you connected to a controller?

#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(midi-connected-devices)
#+END_SRC

#+RESULTS:
: '((:description "Axiom A.I.R. Mini32 MIDI"  :vendor "M-Audio"  :sinks 0  :sources 2147483647  :name "MIDI"  :overtone.studio.midi/full-device-key (:midi-device "M-Audio" "MIDI" "Axiom A.I.R. Mini32 MIDI" 0)  :info #object(com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x1bc8dfb "MIDI")  :overtone.studio.midi/dev-num 0  :device #object(com.sun.media.sound.MidiInDevice 0x293855dc "com.sun.media.sound.MidiInDevice@293855dc")  :version "Unknown version") (:description "Axiom A.I.R. Mini32 HyperControl"  :vendor "M-Audio"  :sinks 0  :sources 2147483647  :name "HyperControl"  :overtone.studio.midi/full-device-key (:midi-device "M-Audio" "HyperControl" "Axiom A.I.R. Mini32 HyperControl" 0)  :info #object(com.sun.media.sound.MidiInDeviceProvider$MidiInDeviceInfo 0x7f787dc9 "HyperControl")  :overtone.studio.midi/dev-num 0  :device #object(com.sun.media.sound.MidiInDevice 0x7047162b "com.sun.media.sound.MidiInDevice@7047162b")  :version "Unknown version"))

quickly check the output dump: 

#+BEGIN_SRC clojure :results silent
(event-debug-on)
#+END_SRC

Full-fledged note on/off messages are awful. Turn it off quickly

#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(event-debug-off)
#+END_SRC

#+RESULTS:
: false

** create a very simple instrument to control
#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(definst boop [note 60 amp 0.3]
  (let [freq (midicps note)]
    (* amp (sin-osc freq))))

#+END_SRC

#+RESULTS:
: #<instrument: boop>

#+BEGIN_SRC clojure
(demo (boop))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: user/audition-synth 60>

** you will rely on 'midi-poly-player' to control your instrument
#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(def booper (midi-poly-player boop))
#+END_SRC

#+RESULTS:
: #'user/booper

** It's pretty primitive to listen to tones pile up

Not enough to call =(stop)=, you will want to eliminate this whole
"player," though not the /instrument/. This is a two-step process!

#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(def booper (midi-poly-player nil))
#+END_SRC


#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(midi-player-stop)
#+END_SRC

** Better to use an "event-handler" with ~on-event~
Just a one-step process to eliminate the player

#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(on-event [:midi :note-on]
          (fn [e]
            (let [note (:note e)
                  vel  (:velocity e)]
              (boop note (* 0.01 vel))))
          ::boop-handler)
#+END_SRC

#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(remove-event-handler ::boop-handler)
#+END_SRC

* natural sounds have an envelope
but what you really want is a sound that decays!
And that "frees" the "synth" when done.

#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(definst steel-drum [note 60 amp 0.8]
  (let [freq (midicps note)]
    (* amp
       (env-gen (perc 0.01 0.2) 1 1 0 1 :action FREE)
       (+ (sin-osc (/ freq 2))
          (rlpf (saw freq) (* 1.1 freq) 0.4)))))
#+END_SRC

#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(def player (midi-poly-player steel-drum))
#+END_SRC

#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(def player (midi-poly-player nil))
#+END_SRC


#+BEGIN_SRC clojure :session *cider-repl post_tonal_overtone*
(midi-player-stop)
#+END_SRC

* now let's use the control change knob for real time interaction
** [#B] control volume on the old, simple 'anoise' inst
#+BEGIN_SRC clojure :results silent
(anoise)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(on-event [:midi :control-change] (fn [{cc-channel :note velocity :velocity}]
                                    (ctl anoise :vol (scale-range velocity 1 127 0 1)))
          ::cc-player)
#+END_SRC


#+BEGIN_SRC clojure :results silent
(remove-event-handler ::cc-player)
#+END_SRC


** get a noise to filter with that knob
#+BEGIN_SRC clojure :results silent
(definst an-fnoise [vol 0.1 ffreq 1000]
  (lpf (* (pink-noise)
          vol)
       ffreq))

#+END_SRC

#+BEGIN_SRC clojure :results silent
(an-fnoise 0.7)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(on-event [:midi :control-change] (fn [{cc-channel :note velocity :velocity}]
                                     (ctl an-fnoise :ffreq (scale-range velocity 1 127 100 8000))
                                         10) ;; why this?
          ::cc-filterplayer)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(remove-event-handler ::cc-filterplayer)
#+END_SRC

* can you control more than one parameter with your controller?
** use a 'cond' to match the cc-channel number (which comes in as a "note")
Make sure an-fnoise is playing!
#+BEGIN_SRC clojure :results silent
(on-event [:midi :control-change]
          (fn [{cc-channel :note vel :velocity}]
            (cond (= cc-channel 1) (ctl an-fnoise :vol (scale-range vel 1 127 0 1))
                  (= cc-channel 2) (ctl an-fnoise :ffreq (scale-range vel 1 127 200 8000))))
          ::pooper)
#+END_SRC



#+BEGIN_SRC clojure :results silent
(remove-event-handler ::pooper)
#+END_SRC

* with a basic interface in place, let's load soundfiles for "granular" playback
** granular synthesis
#+BEGIN_SRC clojure
(def gran-buf (load-sample "/Users/b/Google Drive/Audio_uploads/wav-file-uploads/goldberg-slow-mono.wav"))
#+END_SRC


#+BEGIN_SRC clojure
(definst gran [] (play-buf 1 gran-buf))
#+END_SRC


#+BEGIN_SRC clojure
(gran)
#+END_SRC


#+BEGIN_SRC clojure
(definst grainy [b 0] (let [
                         trate (mouse-y:kr 1 30)
                         dur (/ 2 trate)]
                        (t-grains:ar 1 (impulse:ar trate) b 1 (mouse-x:kr 0 (buf-dur:kr b)) dur 0 0.8 2)))

#+END_SRC


#+BEGIN_SRC clojure
(grainy gran-buf)
#+END_SRC

** add cc control to t-grains
#+BEGIN_SRC clojure
  (definst grainy-ctl [b 0 trate 1 amp 0.8]
    (let [trate trate
          dur (/ 2 trate)]
      (t-grains:ar 1 (impulse:ar trate) b 1 (mouse-x:kr 0 (buf-dur:kr b)) dur 0 amp 2)))

#+END_SRC




#+BEGIN_SRC clojure
(grainy-ctl :trate 2)
#+END_SRC



#+BEGIN_SRC clojure
(ctl grainy-ctl :trate 0.5)
#+END_SRC


Why does the handler function take a "10" as an argument
#+BEGIN_SRC clojure
  (on-event [:midi :control-change]
            (fn [{cc-channel :note velocity :velocity}]
            (ctl grainy-ctl :trate (scale-range velocity 1 127 0.1 3)) 10)
              ::cc-grainyctl)
#+END_SRC


#+BEGIN_SRC clojure
(remove-event-handler ::cc-grainyctl)
#+END_SRC

* you're going to need timing and abstract data manipulation functions
** use a 'metronome'
#+BEGIN_SRC clojure :results silent
(def slow-metro (metronome 15))
#+END_SRC

#+BEGIN_SRC clojure :results silent
(slow-metro)
#+END_SRC

** you can use at and apply-at for scheduling
Note, that this is the same as simply calling 'gran' by itself!
#+BEGIN_SRC clojure :results silent
(at (now) (gran))
#+END_SRC

But, because this is just a function definition...what will happen?
#+BEGIN_SRC clojure :results silent
(defn play-gran-now []
(at (now) (gran)))
#+END_SRC

#+BEGIN_SRC clojure :results silent
(play-gran-now)
#+END_SRC

** or you can use instead Supercollider Ugen timing machinery
#+BEGIN_SRC clojure :results silent
(impulse 1)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(definst slow-grain [b 0] 
(t-grains:ar 1 (impulse:ar 1) b 1 (line 0 (buf-dur:kr 0) 300) 1 0 0.8 2))
#+END_SRC



#+BEGIN_SRC clojure
(slow-grain)
#+END_SRC


#+BEGIN_SRC clojure :results silent
(definst slow-grain [b 0] 
(t-grains:ar 1 (impulse:ar 0.5) b 1 (line 0 (buf-dur:kr 0) 600) 2 0 0.8 4))

(slow-grain)
#+END_SRC

** everything sounds better with some reverb
A basic reverb player
#+BEGIN_SRC clojure :results silent
(defsynth reverb-on-left []
  (let [dry (play-buf 1 gran-buf)
    wet (free-verb dry 1)]
    (out 0 [wet dry])))

(reverb-on-left)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(defsynth reverb-wet-only []
  (let [dry (play-buf 1 gran-buf)
    wet (free-verb dry :mix 1 :damp 0.1 :room 0.9)]

    (out 0 [wet dry])))

(reverb-wet-only)
#+END_SRC

#+BEGIN_SRC clojure
(definst slow-grain-reverb [b 0] 
(free-verb (t-grains:ar 1 (impulse:ar 0.5) b 1 (line 0 (buf-dur:kr 0) 600) 2 0 1 4) :mix 0.5 :damp 0.1 :room 0.9))

(slow-grain-reverb)
#+END_SRC

* after a bit of work, a need for building "artist-specific" abstractions arises
** understanding workflow, tools, and idiomatic patterns for your domain.

Numbers and programming constructs are used to represent more than
just the values that translate computer memory to sound.

You will be getting to a point where you can use them to represent
arbitrary things of your own conception; lists of numbers as pieces of
something for anything!

It will help to be able to internal idiomatic usages of both the
Clojure language, as well as idiomatic ways to translate common
Supercollider constructs.

To do so, you will want to be developing certain basic abstractions
that are unique to you and your particular artistic needs and
interests. Additionally, you will want a way to explore documentation
conveniently, efficiently and, "funly!"
** Abstraction for using CC messages while exploring UGens and documentation
*** original useful two channel message
#+BEGIN_SRC clojure :results silent
(an-fnoise 0.7)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(on-event [:midi :control-change]
          (fn [{cc-channel :note vel :velocity}]
            (cond (= cc-channel 1) (ctl an-fnoise :vol (scale-range vel 1 127 0 1))
                  (= cc-channel 2) (ctl an-fnoise :ffreq (scale-range vel 1 127 200 8000))))
          ::pooper)

#+END_SRC

#+BEGIN_SRC clojure :results silent
(remove-event-handler ::pooper)
#+END_SRC

Putatative "expanded" version of an-fnoise with CC control

#+BEGIN_SRC clojure :results silent
(definst someother-fnoise [vol 0.1 ffreq 1000]
  (lpf (* (pink-noise)
          vol)
       ffreq))

(someother-fnoise)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(on-event [:midi :control-change]
          (fn [{cc-channel :note vel :velocity}]
            (cond (= cc-channel 1) (ctl someother-fnoise :vol   (scale-range vel 1 127 0 1))
                  (= cc-channel 2) (ctl someother-fnoise :ffreq (scale-range vel 1 127 200 8000))
                  (= cc-channel 3) (ctl someother-fnoise :vol   (scale-range vel 1 127 0 1))
                  (= cc-channel 4) (ctl someother-fnoise :ffreq (scale-range vel 1 127 (* 200))
                  (= cc-channel 5) (ctl someother-fnoise :vol   (scale-range vel 1 127 0 1))
                  (= cc-channel 6) (ctl someother-fnoise :vol   (scale-range vel 1 127 0 1))
                  (= cc-channel 7) (ctl someother-fnoise :vol   (scale-range vel 1 127 0 1))
                  (= cc-channel 8) (ctl someother-fnoise :vol   (scale-range vel 1 127 0 1))
                  (= cc-channel 40) (ctl someother-fnoise :vol   (scale-range vel 1 127 0 1))
                  (= cc-channel 41) (ctl someother-fnoise :ffreq   (scale-range vel 1 127 100 1000))
                  ))
          ::pooper)

#+END_SRC


So, what does this have? 

- =on-event= as function has 1.arguments, 2. a body that is a function, and
  1. name (with double colon)

- the cond in the function body is necessary to direct the messages to
  the proper cc-channel

- the velocity reported for each channel is used with a =ctl= message,
  making some modification of an existing, "playing" synth on the
  server?



the value being passed to the relevant argument of the synth (in this
case, the synth is someother-fnoise, and the argument is either 'vol' or
'ffreq') is the result of being scaled by the "scale-range" function.

We need this function to always take three determined arguments: 

1. the input value (in all these CC cases, this is "vel" or the reported
velocity of the given knob), 

2. the input min and max, which as MIDI messages is constrained to
   1-127

3. an output min and max.

We want to be able to manipulate these on the fly. Let's use another
button to report back a channel and a "velocity"
