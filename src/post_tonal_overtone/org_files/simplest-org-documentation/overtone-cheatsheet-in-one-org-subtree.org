* Overtone Cheat Sheet 0.9.1 in one subtree
** Instruments (need to be manually referred)                         :inst:
*** overtone.inst.drum
**** Drums
kick
kick2
kick3
kick4
dub-kick
dry-kick
small-hat
closed-hat
close-hat2
open-hat
hat3
soft-hat
noise-hat
round-kick
snare
snare2
noise-snare
tone-snare
tom
clap
bing
dance-kick
quick-kick
haziti-clap
*** overtone.inst.piano
   Piano piano
*** overtone.inst.sampled-piano
   Sampled Piano
 sampled-piano
*** overtone.inst.sampler
**** Sampler
***** granular
#+BEGIN_SRC clojure :results output
(doc granular)
#+END_SRC

#+RESULTS:

*** overtone.inst.bass

**** Bass

**** bass
#+BEGIN_SRC clojure :results output
(doc bass)
#+END_SRC

#+RESULTS:

**** grunge-bass
#+BEGIN_SRC clojure :results output
(doc grunge-bass)
#+END_SRC

#+RESULTS:

**** vintage-bass
#+BEGIN_SRC clojure :results output
(doc vintage-bass)
#+END_SRC

#+RESULTS:

**** daf-bass
#+BEGIN_SRC clojure :results output
(doc daf-bass)
#+END_SRC

#+RESULTS:

*** overtone.inst.synth
**** Synth
***** ticker
#+BEGIN_SRC clojure :results output
(doc ticker)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/ticker
: ([freq])
:   nil
***** ping
#+BEGIN_SRC clojure :results output
(doc ping)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/ping
: ([note attack decay])
:   nil
***** tb303
#+BEGIN_SRC clojure :results output
(doc tb303)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/tb303
: ([note wave r attack decay sustain release cutoff env-amount amp])
:   nil
***** mooger
#+BEGIN_SRC clojure :results output
(doc mooger)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/mooger
: ([note amp osc1 osc2 osc1-level osc2-level cutoff attack decay sustain release fattack fdecay fsustain frelease gate])
:   Choose 0, 1, or 2 for saw, sin, or pulse
***** rise-fall-pad
#+BEGIN_SRC clojure :results output
(doc rise-fall-pad)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/rise-fall-pad
: ([freq t amt amp])
:   nil
***** pad
#+BEGIN_SRC clojure :results output
(doc pad)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/pad
: ([note t amt amp a d s r])
:   nil
***** overpad
#+BEGIN_SRC clojure :results output
(doc overpad)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/overpad
: ([note amp attack release])
:   nil
***** buzz
#+BEGIN_SRC clojure :results output
(doc buzz)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/buzz
: ([pitch cutoff dur])
:   nil
***** ks1
#+BEGIN_SRC clojure :results output
(doc ks1)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/ks1
: ([note amp dur decay coef])
:   nil
***** ks-stringer
#+BEGIN_SRC clojure :results output
(doc ks-stringer)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/ks-stringer
: ([freq rate])
:   nil
***** fm-demo
#+BEGIN_SRC clojure :results output
(doc fm-demo)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/fm-demo
: ([note amp gate])
:   nil
***** harmonic-swimming
#+BEGIN_SRC clojure :results output
(doc harmonic-swimming)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/harmonic-swimming
: ([amp])
:   nil
***** whoahaha
#+BEGIN_SRC clojure :results output
(doc whoahaha)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/whoahaha
: ([freq dur osc mul])
:   nil
***** bubbles
#+BEGIN_SRC clojure :results output
(doc bubbles)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/bubbles
: ([bass-freq])
:   nil
***** supersaw
#+BEGIN_SRC clojure :results output
(doc supersaw)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/supersaw
: ([freq amp])
:   nil
***** cs80lead
#+BEGIN_SRC clojure :results output
(doc cs80lead)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/cs80lead
: ([freq amp att decay sus rel fatt fdecay fsus frel cutoff dtune vibrate vibdepth gate ratio cbus freq-lag])
:   nil
***** simple-flute
#+BEGIN_SRC clojure :results output
(doc simple-flute)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.inst.synth/simple-flute
: ([freq amp attack decay sustain release gate out])
:   nil

*** overtone.inst.io
**** IO 
***** mic
#+BEGIN_SRC clojure :results output
(doc mic)
#+END_SRC

#+RESULTS:

** Synths (need to be manually referred)                             :synth:
*** overtone.synth.sampled-piano
**** Sampled Piano
***** sampled-piano
#+BEGIN_SRC clojure :results output
(doc sampled-piano)
#+END_SRC

#+RESULTS:

*** overtone.synth.stringed
   Stringed
 s 

**** guitar
#+BEGIN_SRC clojure :results output
(doc guitar)
#+END_SRC

#+RESULTS:

*** overtone.synth.ixi

**** Ixi 

impulser kick kick2 kick3

*** overtone.synth.retro

**** Retro

**** tb-303
#+BEGIN_SRC clojure :results output
(doc tb-303)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.synth.retro/tb-303
: ([note wave cutoff env res sus dec amp gate action position out-bus])
:   A clone of the sound of a Roland TB-303 bass synthesizer.

*** overtone.synth.sts

**** STS

***** prophet
#+BEGIN_SRC clojure :results output
(doc prophet)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.synth.sts/prophet
([amp freq cutoff-freq rq attack decay out-bus])
  The Prophet Speaks (page 2)

   Dark and swirly, this synth uses Pulse Width Modulation (PWM) to
   create a timbre which continually moves around. This effect is
   created using the pulse ugen which produces a variable width square
   wave. We then control the width of the pulses using a variety of LFOs
   - sin-osc and lf-tri in this case. We use a number of these LFO
   modulated pulse ugens with varying LFO type and rate (and phase in
   some cases) to provide the LFO with a different starting point. We
   then mix all these pulses together to create a thick sound and then
   feed it through a resonant low pass filter (rlpf).

   For extra bass, one of the pulses is an octave lower (half the
   frequency) and its LFO has a little bit of randomisation thrown into
   its frequency component for that extra bit of variety.
#+end_example

** REPL helpers (OUTDATED)                                             :repl:
*** Outdated paths
**** Documentation
***** odoc
#+BEGIN_SRC clojure :results output
(doc odoc)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/odoc
: ([name])
: Macro
:   Prints Overtone documentation for a var or special form given its name.
:   Accounts for colliding ugens
***** ugen-doc
#+BEGIN_SRC clojure :results output
(doc ugen-doc)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/ugen-doc
: ([ug-name])
: Macro
:   Print documentation for ugen with name ug-name
***** find-ugen
#+BEGIN_SRC clojure :results output
(doc find-ugen)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/find-ugen
([& search-terms])
Macro
  Find a ugen containing the specified terms which may be either strings or
  regexp patterns. Will search the ugen's docstrings for occurrances of all the
  specified terms. Prints out a list of summaries of each matching ugen.
  If only one matching ugen is found, prints out full docstring.

  (find-ugen foo)         ;=> finds all ugens containing the word foo
  (find-ugen foo "bar") ;=> finds all ugens containing the words foo AND bar
  (find-ugen #"foo*")   ;=> finds all ugens matching the regex foo*
#+end_example
***** find-ugen-doc
#+BEGIN_SRC clojure :results output
(doc find-ugen-doc)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/find-ugen-doc
([& search-terms])
Macro
  Find a ugen containing the specified terms which may be either strings or
  regexp patterns. Will search the ugen's docstrings for occurrances of all the
  specified terms. Prints out each ugens full docstring. Similar to find-doc.

  (find-ugen-doc foo)         ;=> finds all ugens containing the word foo
  (find-ugen-doc "foo" bar) ;=> finds all ugens containing the words foo
                                    AND bar
  (find-ugen-doc #"foo*")   ;=> finds all ugens matching the regex foo*
#+end_example

**** Examples

***** examples
#+BEGIN_SRC clojure :results output
(doc examples)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/examples
: ([] [gen] [gen key])
:   Print out examples for a specific gen. If passed a gen and a key will list
:   the full example documentation. If passed no arguments will list out all
:   available examples.
:   (examples)          ;=> print out all examples
:   (examples foo)      ;=> print out examples for gen foo
:   (examples foo :bar) ;=> print out doc for example :bar for gen foo

***** example
#+BEGIN_SRC clojure :results output
(doc example)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/example
: ([gen key & params])
:   Fetch and call specific example for gen with key
:   This can then be passed to demo:
:   (demo (example dibrown :rand-walk))
: 
:   Also, params can be passed by appending them to the end of the args:
:   (demo (example foo :key arg1 arg2 :key1 arg3 :key2 arg4))

***** get-example
#+BEGIN_SRC clojure :results output
(doc get-example)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/get-example
: ([gen key])
:   Fetch specific example for gen with key. This is useful for storing an
:   example for later use. Returns a cgen.

**** Shell
***** ls
#+BEGIN_SRC clojure :results output
(doc ls)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/ls
: ([path])
:   Returns a listing of contents for the supplied path.

***** grep
#+BEGIN_SRC clojure :results output
(doc grep)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/grep
: ([stdin match])
:   Returns a listing of contents which match.

**** Synths
***** unify-synthdef
#+BEGIN_SRC clojure :results output
(doc unify-synthdef)
#+END_SRC

#+RESULTS:

**** Pretty Printing (note cheatsheet outdated)

***** opp
#+BEGIN_SRC clojure :results output
(doc opp)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/opp
: ([& args])
: Macro
:   Pretty-print x (or *1 if no argument is passed)

***** pp-synth
#+BEGIN_SRC clojure :results output
(doc pp-synth)
#+END_SRC

#+RESULTS:

***** pp-unified-synth
#+BEGIN_SRC clojure :results output
(doc pp-unified-synth)
#+END_SRC

#+RESULTS:

***** pp-sc-synth
#+BEGIN_SRC clojure :results output
(doc pp-sc-synth)
#+END_SRC

#+RESULTS:

***** pp-unified-sc-synth
#+BEGIN_SRC clojure :results output
(doc pp-unified-sc-synth)
#+END_SRC

#+RESULTS:

*** Current namespace actually contains
**** -rw-r--r--  1 b  staff  8162 Jul 10  2016 debug.clj
expand-control-ugs
opp
pp-sdef
pp-unified-sdef
sdef
unified-sdef
**** -rw-r--r--  1 b  staff  2762 Jul 10  2016 examples.clj
**** -rw-r--r--  1 b  staff  5529 Jul 10  2016 graphviz.clj
**** -rw-r--r--  1 b  staff   661 Jul 10  2016 inst.clj

#+BEGIN_SRC clojure :results output
(doc overtone.repl.inst/ns-instruments)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.repl.inst/ns-instruments
([ns])
  Returns a sequence of all the (public) instruments in the given
  namespace.

  For example:

    => (use 'overtone.inst.drum)
    nil
    => (ns-instruments 'overtone.inst.drum)
    (...)
    => (step-sequencer (metronome 200) 8 (ns-instruments 'overtone.inst.drum))

  Note that the returned sequence is a sequence of instrument
  *objects*, not vars, so they'll print sort of like this:

    #<Object$Associative$IFn$IMeta$IObj$17272e52 instrument:dub-kick>

  
#+end_example

**** -rw-r--r--  1 b  staff  1123 Jul 10  2016 shell.clj
**** -rw-r--r--  1 b  staff  5287 Jul 10  2016 ugens.clj
find-ugen
find-ugen-doc
odoc
pretty-ugen-doc-string
print-ugen-docs
ugen-doc
** Timing                                                           :timing:
*** Scheduling
**** Function Application 
***** now
  #+BEGIN_SRC clojure :results output
(doc now)  
  #+END_SRC

  #+RESULTS:
  : -------------------------
  : overtone.live/now
  : ([])
  :   Returns the current time in ms
***** after-delay
#+BEGIN_SRC clojure :results output
(doc after-delay)
#+END_SRC 

#+RESULTS:
: -------------------------
: overtone.live/after-delay
: ([ms-delay fun] [ms-delay fun description])
:   Schedules fun to be executed after ms-delay milliseconds. Pool
:   defaults to the player-pool.
***** periodic
 #+BEGIN_SRC clojure :results output 
 (doc periodic)
 #+END_SRC

 #+RESULTS:
 : -------------------------
 : overtone.live/periodic
 : ([ms-period fun] [ms-period fun initial-delay] [ms-period fun initial-delay description])
 :   Calls fun every ms-period, and takes an optional initial-delay for
 :   the first call in ms.

  interspaced apply-by apply-at
***** OSC 
at
***** Stopping 
stop-player kill-player
***** Feedback 
show-schedule
*** Metronome
**** Create 
*****  metronome
#+BEGIN_SRC clojure :results output
(doc  metronome)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/metronome
([bpm])
  A metronome is a beat management function.  Tell it what BPM you want,
  and it will output beat timestamps accordingly.  Call the returned function
  with no arguments to get the next beat number, or pass it a beat number
  to get the timestamp to play a note at that beat.

  Metronome also works with bars. Set the number of beats per bar using
  metro-bpb (defaults to 4). metro-bar returns a timestamp that can be used
  to play a note relative to a specified bar.

  (def m (metronome 128))
  (m)          ; => <next beat number>
  (m 200)      ; => <timestamp of beat 200>
  (m :bpm)     ; => return the current bpm val
  (m :bpm 140) ; => set bpm to 140
#+end_example

**** Manipulate

***** metro-start
#+BEGIN_SRC clojure :results output
(doc metro-start)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/metro-start
: ([metro] [metro start-beat])
:   Returns the start time of the metronome. Also restarts the metronome at
:      'start-beat' if given.

***** metro-tick
#+BEGIN_SRC clojure :results output
(doc metro-tick)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/metro-tick
: ([metro])
:   Returns the duration of one metronome 'tick' in milleseconds.

***** metro-beat
#+BEGIN_SRC clojure :results output
(doc metro-beat)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/metro-beat
: ([metro] [metro beat])
:   Returns the next beat number or the timestamp (in milliseconds) of the
:      given beat.

***** metro-bpm
#+BEGIN_SRC clojure :results output
(doc metro-bpm)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/metro-bpm
: ([metro] [metro new-bpm])
:   Get the current bpm or change the bpm to 'new-bpm'.

***** metro-tock
#+BEGIN_SRC clojure :results output
(doc metro-tock)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/metro-tock
: ([metro])
:   Returns the duration of one bar in milliseconds.

***** metro-bar
#+BEGIN_SRC clojure :results output
(doc metro-bar)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/metro-bar
: ([metro] [metro bar])
:   Returns the next bar number or the timestamp (in milliseconds) of the
:      given bar

***** metro-bpb
#+BEGIN_SRC clojure :results output
(doc metro-bpb)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/metro-bpb
: ([metro] [metro new-bpb])
:   Get the current beats per bar or change it to new-bpb

*** bps 

**** beat-ms
#+BEGIN_SRC clojure :results output
(doc beat-ms)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/beat-ms
: ([b bpm])
:   Convert 'b' beats to milliseconds at the given 'bpm'.

** Studio                                                           :studio:
*** Mixer
**** Control
***** volume
#+BEGIN_SRC clojure :results output
(doc volume)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/volume
: ([] [vol])
:   Set the volume on the master mixer. When called with no params, retrieves the
:    current value
***** input-gain
#+BEGIN_SRC clojure :results output
(doc input-gain)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/input-gain
: ([] [gain])
:   Set the input gain on the master mixer. When called with no params, retrieves
:   the current value

*** MIDI
**** Connected Controllers
***** midi-connected-devices
#+BEGIN_SRC clojure :results output
(doc midi-connected-devices)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/midi-connected-devices
([])
  Returns a sequence of device maps for all 'connected' MIDI
   devices. By device, we mean a MIDI unit that is capable of sending
   messages (such as a MIDI piano). By connected, we mean that Overtone
   is aware of the device and has added event handlers to emit incoming
   messages from the device as unique events.

   This currently returns a list which was created and cached at boot
   time. Therefore, devices connected after boot will not be
   available. We are considering work-arounds to this issue for a future
   release.
#+end_example
***** midi-connected-receivers
#+BEGIN_SRC clojure :results output
(doc midi-connected-receivers)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/midi-connected-receivers
([])
  Returns a sequence of device maps for all 'connected' MIDI
   receivers. By receiver, we mean a MIDI unit that is capable of
   receiving messages. By connected, we mean that Overtone is aware of
   the device.

   This currently returns a list which was created and cached at boot
   time. Therefore, devices connected after boot will not be
   available. We are considering work-arounds to this issue for a future
   release.
#+end_example
***** midi-find-connected-devices
#+BEGIN_SRC clojure :results output
(doc midi-find-connected-devices)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-find-connected-devices
: ([search])
:   Returns a list of connected MIDI devices where the full device key
:    either contains the search string or matches the search regexp
:    depending on the type of parameter supplied
***** midi-find-connected-device
#+BEGIN_SRC clojure :results output
(doc midi-find-connected-device)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-find-connected-device
: ([search])
:   Returns the first connected MIDI device found where the full device
:    key either contains the search string or matches the search regexp
:    depending on the type of parameter supplied
***** midi-find-connected-receivers
#+BEGIN_SRC clojure :results output
(doc midi-find-connected-receivers)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-find-connected-receivers
: ([search])
:   Returns a list of connected MIDI receivers where the full device key
:    either contains the search string or matches the search regexp
:    depending on the type of parameter supplied
***** midi-find-connected-receiver
#+BEGIN_SRC clojure :results output
(doc midi-find-connected-receiver)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-find-connected-receiver
: ([search])
:   Returns the first connected MIDI receiver found where the full device
:    key either contains the search string or matches the search regexp
:    depending on the type of parameter supplied

**** Info 
***** midi-device-num
#+BEGIN_SRC clojure :results output
(doc midi-device-num)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-device-num
: ([dev])
:   Returns the device number for the specified MIDI device

***** midi-full-device-key
#+BEGIN_SRC clojure :results output
(doc midi-full-device-key)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-full-device-key
: ([dev])
:   Returns the full device key for the specified MIDI device

**** Player 
***** 
***** midi-poly-player
#+BEGIN_SRC clojure :results output
(doc midi-poly-player)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/midi-poly-player
([play-fn] [play-fn player-key] [play-fn device-key player-key])
  Sets up the event handlers and manages synth instances to easily play
  a polyphonic instrument with a midi controller.  The play-fn should
  take the note and velocity as the only two arguments, and the synth
  should have a gate parameter that can be set to zero when a :note-off
  event is received.

    (definst ding
      [note 60 velocity 100 gate 1]
      (let [freq (midicps note)
            amp  (/ velocity 127.0)
            snd  (sin-osc freq)
            env  (env-gen (adsr 0.001 0.1 0.6 0.3) gate :action FREE)]
        (* amp env snd)))

    (def dinger (midi-poly-player ding))
  
#+end_example
***** midi-player-stop
#+BEGIN_SRC clojure :results output
(doc midi-player-stop)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-player-stop
: ([] [player-or-key])
:   nil
***** midi-inst-controller
#+BEGIN_SRC clojure :results output
(doc midi-inst-controller)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/midi-inst-controller
([state-atom handler mapping])
  Create a midi instrument controller for manipulating the parameters of an instrument
  using an external device.  Requires an atom to store the state of the parameters, a
  handler that will be called each time a parameter is modified, and a mapping table to
  specify how midi control messages should manipulate the parameters.

  (def ding-mapping
    {22 [:attack     #(* 0.3 (/ % 127.0))]
     23 [:decay      #(* 0.6 (/ % 127.0))]
     24 [:sustain    #(/ % 127.0)]
     25 [:release    #(/ % 127.0)]})

  (def ding-state (atom {}))

  (midi-inst-controller ding-state (partial ctl ding) ding-mapping)
  
#+end_example

**** Discovery
***** 
***** midi-capture-next-controller-control-key
#+BEGIN_SRC clojure :results output
(doc midi-capture-next-controller-control-key)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-capture-next-controller-control-key
: ([])
:   Returns a vector representing the unique key for the specific control
:   of the next modified controller. This is the key used for controller
:   specific MIDI events.
***** midi-capture-next-controller-key
#+BEGIN_SRC clojure :results output
(doc midi-capture-next-controller-key)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-capture-next-controller-key
: ([])
:   Returns a vector representing the unique key for the next modified
:   controller.

**** Keys
***** midi-device-keys
#+BEGIN_SRC clojure :results output
(doc midi-device-keys)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-device-keys
: ([])
:   Return a list of device event keys for the available MIDI devices
***** midi-mk-control-key-keyword
#+BEGIN_SRC clojure :results output
(doc midi-mk-control-key-keyword)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/midi-mk-control-key-keyword
: ([prefix control-key])
:   nil

**** State
***** midi-agent-for-control
#+BEGIN_SRC clojure :results output
(doc midi-agent-for-control)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/midi-agent-for-control
([control-key])
  Returns an agent representing the current value of a
  controller-specific control identified by a fully-qualified MIDI event
  key such as that generated by midi-mk-full-control-event-key. If the
  agent doesn't exist, it is created and cached. Subsequent calls with
  the same control-key will return the same agent.

  Agents are used because the event to update them can be safely handled
  synchronously (with on-sync-event) without watchers being able to
  block the thread generating the MIDI events. This also means that
  incoming events are sent to the agent in the correct order whereas if
  the thread pool were used (via on-event), the incoming events may be
  arbitrarily ordered.
#+end_example

*** Scope
**** Create & Reset
***** scope
#+BEGIN_SRC clojure :results output
(doc scope)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.studio.scope/scope
([] [thing] [kind id] [kind id keep-on-top?])
  Create a scope for either a bus or a buffer. Defaults to scoping audio-bus 0.
   Example use:

   (scope a-control-bus)
   (scope a-buffer)
   (scope an-audio-bus)
   (scope :audio-bus 1)
   (scope :control-bus 10)
   (scope :buf 10)
#+end_example
***** pscope
#+BEGIN_SRC clojure :results output
(doc pscope)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.studio.scope/pscope
: ([] [thing] [kind id])
:   Creates a 'permanent' scope, where the window is always kept
:   on top of other OS windows. See scope.
***** spectrogram
#+BEGIN_SRC clojure :results output
(doc spectrogram)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.studio.scope/spectrogram
: ([& {:keys [bus keep-on-top], :or {bus 0, keep-on-top false}}])
:   Create frequency scope for a bus.  Defaults to bus 0.
:    Example use:
:    (spectrogram :bus 1)

*** Recording
**** Stop & Start
***** recording-start
#+BEGIN_SRC clojure :results output
(doc recording-start)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/recording-start
([path & args])
  Start recording a wav file to a new file at wav-path. Be careful -
  may generate very large files. See buffer-stream for a list of output
  options.

  Note, due to the size of the buffer used for transferring the audio
  from the audio server to the file, there will be 1.5s of silence at
  the start of the recording
#+end_example
***** recording-stop
#+BEGIN_SRC clojure :results output
(doc recording-stop)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/recording-stop
: ([])
:   Stop system-wide recording. This frees the file and writes the wav headers.
:   Returns the path of the file created.

**** Query 

***** recording?
#+BEGIN_SRC clojure :results output
(doc recording?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/recording?
: ([])
:   nil

*** Inst Effects
**** Instrument
***** inst-volume vs. inst-volume!
#+BEGIN_SRC clojure :results output
(doc inst-volume!)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/inst-volume!
: ([inst vol])
:   Control the volume of a single instrument.
***** inst-out-bus
#+BEGIN_SRC clojure :results output
(doc inst-out-bus)
#+END_SRC

#+RESULTS:
***** inst-fx!
#+BEGIN_SRC clojure :results output
(doc inst-fx!)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/inst-fx!
:   Append an effect to an instrument channel. Returns a SynthNode or a
:   vector of SynthNodes representing the effect instance.
***** clear-fx
#+BEGIN_SRC clojure :results output
(doc clear-fx)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/clear-fx
: ([inst])
:   nil

**** FX
***** fx-noise-gate
#+BEGIN_SRC clojure :results output
(doc fx-noise-gate)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-noise-gate
: ([bus threshold slope-below slope-above clamp-time relax-time])
:   A noise gate only lets audio above a certain amplitude threshold through.  Often used to filter out hardware circuit noise or unwanted background noise.

***** fx-compressor
#+BEGIN_SRC clojure :results output
(doc fx-compressor)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-compressor
: ([bus threshold slope-below slope-above clamp-time relax-time])
:   A compressor clamps audio signals above an amplitude threshold down, compressing the dynamic range.  Used to normalize a poppy sound so that the amplitude is more consistent, or as a sound warping effect.  The clamp time determines the delay from when the signal is detected as going over the threshold to when clamping begins, and the slope determines the rate at which the clamp occurs.

***** fx-limiter
#+BEGIN_SRC clojure :results output
(doc fx-limiter)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-limiter
: ([bus threshold slope-below slope-above clamp-time relax-time])
:   A limiter sets a maximum threshold for the audio amplitude, and anything above this threshold is quickly clamped down to within it.

***** fx-sustainer
#+BEGIN_SRC clojure :results output
(doc fx-sustainer)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-sustainer
: ([bus threshold slope-below slope-above clamp-time relax-time])
:   nil

***** fx-freeverb
#+BEGIN_SRC clojure :results output
(doc fx-freeverb)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-freeverb
: ([bus wet-dry room-size dampening])
:   Uses the free-verb ugen.

***** fx-reverb
#+BEGIN_SRC clojure :results output
(doc fx-reverb)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-reverb
: ([bus])
:   Implements Schroeder reverb using delays.

***** fx-echo
#+BEGIN_SRC clojure :results output
(doc fx-echo)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-echo
: ([bus max-delay delay-time decay-time])
:   nil

***** fx-chorus
#+BEGIN_SRC clojure :results output
(doc fx-chorus)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-chorus
: ([bus rate depth])
:   nil

***** fx-distortion
#+BEGIN_SRC clojure :results output
(doc fx-distortion)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-distortion
: ([bus boost level])
:   nil

***** fx-distortion2
#+BEGIN_SRC clojure :results output
(doc fx-distortion2)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-distortion2
: ([bus amount])
:   nil

***** fx-distortion-tubescreamer
#+BEGIN_SRC clojure :results output
(doc fx-distortion-tubescreamer)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-distortion-tubescreamer
: ([bus hi-freq low-freq hi-freq2 gain threshold])
:   nil

***** fx-bitcrusher
#+BEGIN_SRC clojure :results output
(doc fx-bitcrusher)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-bitcrusher
: ([in-bus])
:   nil

***** fx-rlpf
#+BEGIN_SRC clojure :results output
(doc fx-rlpf)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-rlpf
: ([bus cutoff res])
:   nil

***** fx-rhpf
#+BEGIN_SRC clojure :results output
(doc fx-rhpf)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-rhpf
: ([bus cutoff res])
:   nil

***** fx-feedback
#+BEGIN_SRC clojure :results output
(doc fx-feedback)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-feedback
: ([bus delay-t decay])
:   nil

***** fx-feedback-distortion
#+BEGIN_SRC clojure :results output
(doc fx-feedback-distortion)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/fx-feedback-distortion
: ([bus delay-t noise-rate boost decay])
:   nil

** Synth Design                                                  :syndesign:

*** Design

**** definst
#+BEGIN_SRC clojure :results output
(doc definst)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/definst
([name doc-string? params ugen-form])
Macro
  Define an instrument and return a player function. The instrument
  definition will be loaded immediately, and a :new-inst event will be
  emitted. Expects a name, an optional doc-string, a vector of
  instrument params, and a ugen-form as its arguments.

  Instrument parameters are a vector of name/value pairs, for example:

  (definst inst-name [param0 value0 param1 value1 param2 value2] ...)

  The returned player function takes any number of positional
  arguments, followed by any number of keyword arguments. For example,
  all of the following are equivalent:

  (inst-name 0 1 2)
  (inst-name 0 1 :param2 2)
  (inst-name :param1 1 :param0 0 :param2 2)

  Omitted parameters are given their default value from the
  instrument's parameter list.

  A doc string may also be included between the instrument's name and
  parameter list:

  (definst lucille
    "What's that Lucille?"
    [] ...)

  Instruments are similar to basic synths but still differ in a number
  of notable ways:

  * Instruments will automatically wrap the body of code given in an
    out ugen. You do not need to include an out ugen yourself. For
    example:

    (definst foo [freq 440]
      (sin-osc freq))

    is similar to:

    (defsynth foo [freq 440]
      (out 0 (sin-osc freq)))

  * Instruments are limited to 1 or 2 channels. Instruments with more
    than 2 channels are allowed, but additional channels will not be
    audible. Use the mix and pan2 ugens to combine multiple channels
    within your inst if needed. For example:

    (definst bar
      [f1 100 f2 200 f3 300 f4 400]
      (mix (pan2 (sin-osc [f1 f2 f3 f4]) [-1 1 -1 1])))

  * Each instrument is assigned its own group which all instances will
    automatically be placed in. This allows you to control all of an
    instrument's running synths with one command:

    (ctl inst-name :param0 val0 :param1 val1)

    You may also kill all of an instrument's running synths:

    (kill inst-name)

  * A bus and bus-mixer are created for each instrument. This allows
    you to control the volume or pan of the instrument group with one
    command:

    (inst-pan! bar -1)     ;pan hard left.
    (inst-volume! bar 0.5) ;half the volume.

    For a stereo inst, you can control left and right pan or volume
    separately by passing an additional arg:

    (inst-pan! bar 1 -1)   ;ch1 right, ch2 left.
    (inst-volume! bar 0 1) ;mute ch1.

  * Each instrument has an fx-chain to which you can add any number of
    'fx synths' using the inst-fx function.
  
#+end_example

**** defsynth
#+BEGIN_SRC clojure :results output
(doc defsynth)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/defsynth
([s-name & s-form])
Macro
  Define a synthesizer and return a player function. The synth
  definition will be loaded immediately, and a :new-synth event will be
  emitted. Expects a name, an optional doc-string, a vector of synth
  params, and a ugen-form as its arguments.

  (defsynth foo [freq 440]
    (out 0 (sin-osc freq)))

  is equivalent to:

  (def foo
    (synth [freq 440] (out 0 (sin-osc freq))))

  Params can also be given rates. By default, they are :kr, however
  another rate can be specified by using either a pair of [default rate]
  or a map with keys :default and rate:

  (defsynth foo [freq [440 :kr] gate [0 :tr]] ...)
  (defsynth foo [freq {:default 440 :rate :kr}] ...)

  A doc string can also be included:
  (defsynth bar
    "The phatest space pad ever!"
    [] (...))

  The function generated will accept a target vector argument that
  must come first, containing position and target as elements (see the
  node function docs).

  ;; call foo player with default args:
  (foo)

  ;; call foo player specifying node should be at the tail of group 0
  (foo [:tail 0])

  ;; call foo player with positional arguments
  (foo 440 0.3)

  ;; target node to be at the tail of group 0 with positional args
  (foo [:tail 0] 440 0.3)

  ;; or target node to be at the head of group 2
  (foo [:head 2] 440 0.3)

  ;; you may also use keyword args
  (foo :freq 440 :amp 0.3)

  ;; which allows you to re-order the args
  (foo :amp 0.3 :freq 440 )

  ;; you can also combine a target vector with keyword args
  (foo [:head 2] :amp 0.3 :freq 440)

  ;; finally, you can combine target vector, keywords args and
  ;; positional args. Positional args must go first.
  (foo [:head 2] 440 :amp 0.3)
#+end_example

*** Examples

**** defexamples
#+BEGIN_SRC clojure :results output
(doc defexamples)
#+END_SRC

#+RESULTS:

*** CGens

**** defcgen
#+BEGIN_SRC clojure :results output
(doc defcgen)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/defcgen
([c-name & c-form])
Macro
  Define one or more related cgens (composite generators) with different rates.

  A cgen has a name, docstring and 0 or more params which themselves have names
  and optional info maps with the keys :default and :doc. Next you need to
  describe a number of rated bodies which may reference the named params.
  Finally, an optional :default may be specified which will define the default
  rate for this cgen, or if ommitted the standard rate precedence is used.

  An example cgen definition is as follows:

  (defcgen pm-osc
    "phase modulation sine oscillator pair."
    [car-freq {:default 0.0 :doc "Carrier frequency"}
     mod-freq {:default 0.0 :doc "Modulation frequency"}
     pm-index {:default 0.0 :doc "Phase modulation index"}
     mod-phase {:default 0.0 :doc "Modulation phase"}]
    "Longer more detailed documentation..."
    (:ar (sin-osc:ar car-freq (* pm-index (sin-osc:ar mod-freq mod-phase))))
    (:kr (sin-osc:kr car-freq (* pm-index (sin-osc:kr mod-freq mod-phase))))
    (:default :ar))
#+end_example

*** Auditioning

**** demo
#+BEGIN_SRC clojure :results output
(doc demo)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/demo
([& body])
Macro
  Listen to an anonymous synth definition for a fixed period of time.
  Useful for experimentation.  If the root node is not an out ugen, then
  it will add one automatically.  You can specify a timeout in seconds
  as the first argument otherwise it defaults to *demo-time* ms. See
  #'run for a version of demo that does not add an out ugen.

  (demo (sin-osc 440))      ;=> plays a sine wave for *demo-time* ms
  (demo 0.5 (sin-osc 440))  ;=> plays a sine wave for half a second
#+end_example

**** run
#+BEGIN_SRC clojure :results output
(doc run)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/run
([& body])
Macro
  Run an anonymous synth definition for a fixed period of time.
  Useful for experimentation. Does NOT add an out ugen - see #'demo for
  that. You can specify a timeout in seconds as the first argument
  otherwise it defaults to *demo-time* ms.

  (run (send-reply (impulse 1) "/foo" [1] 43)) ;=> send OSC messages
#+end_example

*** Checking
with-no-ugen-checks
with-ugen-debugging

*** Arguments
**** synth-args
#+BEGIN_SRC clojure :results output
(doc synth-args)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/synth-args
: ([synth])
:   Returns a seq of the synth's args as keywords

**** synth-arg-index
#+BEGIN_SRC clojure :results output
(doc synth-arg-index)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/synth-arg-index
([synth arg-name])
  Returns an integer index of synth's argument with arg-name.

   For example:

   (defsynth foo [freq 440 amp 0.5] (out 0 (* amp (sin-osc freq))))

   (synth-arg-index foo :amp) #=> 1
   (synth-arg-index foo "freq") #=> 0
   (synth-arg-index foo :baz) #=> nil
#+end_example

** Synth Control                                                :syncontrol:
*** Live Control 
**** ctl 
#+BEGIN_SRC clojure :results output
(doc ctl )
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/ctl
: ([node & args])
:   Send a node control messages specified in pairs of :arg-name val. It
:   is possible to pass a sequence of nodes in which case the same control
:   messages will be sent to all nodes.  i.e.
:   (ctl 34 :freq 440 :amp 0.2)
:   (ctl [34 37] :freq 440 :amp 0.2)
**** kill
#+BEGIN_SRC clojure :results output
(doc kill)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/kill
([& nodes])
  Multi-purpose killing function.

  * running synths - Stop and removes the node from the node
                     tree.
  * groups         - Stops all synths within the group (and
                     subgroups) but will leave the group structure
                     intact.

#+end_example

*** Node Liveness

**** inactive-node-modification-error
#+BEGIN_SRC clojure :results output
(doc inactive-node-modification-error)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/inactive-node-modification-error
: ([])
:   Returns the current value for the dynamic var
:   *inactive-node-modification-error*

**** inactive-buffer-modification-error
#+BEGIN_SRC clojure :results output
(doc inactive-buffer-modification-error)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/inactive-buffer-modification-error
: ([])
:   Returns the current value for the dynamic var
:   *inactive-buffer-modification-error*

**** block-node-until-ready?
#+BEGIN_SRC clojure :results output
(doc block-node-until-ready?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/block-node-until-ready?
: ([])
:   Returns the current value for the dynamic var
:   *block-node-until-ready?*

**** without-node-blocking
#+BEGIN_SRC clojure :results output
(doc without-node-blocking)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/without-node-blocking
: ([& body])
: Macro
:   Stops the current thread from being blocked if you send a
:    modification message to a server node that hasn't completed
:    loading. This may result in messages sent within the body of this
:    macro being ignored by the server.

**** with-inactive-node-modification-error
#+BEGIN_SRC clojure :results output
(doc with-inactive-node-modification-error)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/with-inactive-node-modification-error
: ([error-type & body])
: Macro
:   Specify the inactive node modification error for the specified
:    block. Options are: :exception, :warning and :silent

**** with-inactive-buffer-modification-error
#+BEGIN_SRC clojure :results output
(doc with-inactive-buffer-modification-error)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/with-inactive-buffer-modification-error
: ([error-type & body])
: Macro
:   Specify the inactive buffer modification error for the specified
:    block. Options are: :exception, :warning and :silent

**** with-inactive-modification-error
#+BEGIN_SRC clojure :results output
(doc with-inactive-modification-error)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/with-inactive-modification-error
: ([error-type & body])
: Macro
:   Specify the inactive modification error for both nodes and buffers
:    within the specified block. Options are: :exception, :warning
:    and :silent

** Event Handling                                                   :events:
*** Add
**** on-event
#+BEGIN_SRC clojure :results output
(doc on-event)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/on-event
([event-type handler key])
  Asynchronously runs handler whenever events of event-type are
  fired. This asynchronous behaviour can be overridden if required - see
  sync-event for more information. Events may be triggered with the fns
  event and sync-event.

  Takes an event-type (name of the event), a handler fn and a key (to
  refer back to this handler in the future). The handler must accept a
  single event argument, which is a map containing the :event-type
  property and any other properties specified when it was fired.

  (on-event "/tr" handler ::status-check )
  (on-event :midi-note-down (fn [event]
                              (funky-bass (:note event)))
                            ::midi-note-down-hdlr)

  Handlers can return :overtone/remove-handler to be removed from
  the handler list after execution.
#+end_example
**** on-sync-event
#+BEGIN_SRC clojure :results output
(doc on-sync-event)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/on-sync-event
([event-type handler key])
  Synchronously runs handler whenever events of type event-type are
  fired on the thread that generated the event (by calling ether event
  or event-sync). Note, this causes the event-generating thread to block
  whilst this handler is being handled. For a non-blocking event handler
  see on-event.


  Takes an event-type (name of the event), a handler fn and a key (to
  refer back to this handler in the future). The handler must accept a
  single event argument, which is a map containing the :event-type
  property and any other properties specified when it was fired.

  (on-event "/tr" handler ::status-check )
  (on-event :midi-note-down (fn [event]
                              (funky-bass (:note event)))
                            ::midi-note-down-hdlr)

  Handlers can return :overtone/remove-handler to be removed from the
  handler list after execution.
#+end_example
**** on-latest-event
#+BEGIN_SRC clojure :results output
(doc on-latest-event)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/on-latest-event
([event-type handler key])
  Runs handler on a separate thread to the thread that generated the
  event - however event order is preserved per thread similar to
  on-sync-event. However, only the last matching event will trigger the
  handler with all intermediate events being dropped if the handler fn
  is still busy executing.

  *Warning* - is not guaranteed to be triggered for all matching events.

  Useful for low-latency sequential handling of events despite
  potentially long-running handler fns where handling the most recent
  event is all that matters.
#+end_example
**** oneshot-event
#+BEGIN_SRC clojure :results output
(doc oneshot-event)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/oneshot-event
: ([event-type handler key])
:   Add a one-shot handler which will be removed when called. This
:    handler is guaranteed to be called only once.
: 
:   (oneshot-event "/foo" (fn [v] (println v)) ::debug)
**** oneshot-sync-event
#+BEGIN_SRC clojure :results output
(doc oneshot-sync-event)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/oneshot-sync-event
: ([event-type handler key])
:   Add a synchronous one-shot handler which will be removed when
:    called. This handler is guaranteed to be called only once.
: 
:   (oneshot-sync-event "/foo" (fn [v] (println v)) ::debug)

*** Fire

**** event
#+BEGIN_SRC clojure :results output
(doc event)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/event
([event-type & args])
  Fire an event of type event-type with any number of additional
  properties.

  NOTE: an event requires either a map as a single argument, or
  key/value pairs which will be poured into an event map.  It will not
  work if you just pass values.

  (event ::my-event)
  (event ::filter-sweep-done :instrument :phat-bass)
#+end_example

**** sync-event
#+BEGIN_SRC clojure :results output
(doc sync-event)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/sync-event
: ([event-type & args])
:   Runs all event handlers synchronously of type event-tye regardless
:   of whether they were declared as async or not. If handlers create
:   new threads which generate events, these will revert back to the
:   default behaviour of event (i.e. not forced sync). See event.

*** Remove

**** remove-event-handler
#+BEGIN_SRC clojure :results output
(doc remove-event-handler)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/remove-event-handler
([key])
  Remove an event handler previously registered with specified
   key. Removes both sync and async handlers with a given key for a
   particular event type.

  (defn my-foo-handler [event] (do-stuff (:val event)))

  (on-event :foo my-foo-handler ::bar-key)
  (event :foo :val 200) ; my-foo-handler gets called with:
                        ; {:event-type :foo :val 200}
  (remove-event-handler ::bar-key)
  (event :foo :val 200) ; my-foo-handler no longer called
#+end_example

*** Debug

**** event-debug-on
#+BEGIN_SRC clojure :results output
(doc event-debug-on)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/event-debug-on
: ([])
:   Prints out all incoming events to stdout. May slow things down.

**** event-debug-off
#+BEGIN_SRC clojure :results output
(doc event-debug-off)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/event-debug-off
: ([])
:   Stops debug info from being printed out.

**** event-monitor-on
#+BEGIN_SRC clojure :results output
(doc event-monitor-on)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/event-monitor-on
: ([])
:   Start recording new incoming events into a map which can be examined
:   with #'event-monitor

**** event-monitor-off
#+BEGIN_SRC clojure :results output
(doc event-monitor-off)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/event-monitor-off
: ([])
:   Stop recording new incoming events

**** event-monitor-timer
#+BEGIN_SRC clojure :results output
(doc event-monitor-timer)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/event-monitor-timer
: ([] [seconds])
:   Record events for a specific period of time in seconds (defaults to
:   5).

**** event-monitor
#+BEGIN_SRC clojure :results output
(doc event-monitor)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/event-monitor
: ([] [event-key])
:   Return a map of the most recently seen events. This is reset every
:   time #'event-monitor-on is called.

**** event-monitor-keys
#+BEGIN_SRC clojure :results output
(doc event-monitor-keys)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/event-monitor-keys
: ([])
:   Return a set of all the keys of most recently seen events.

*** [#A] Ugen Triggers

**** trig-id
#+BEGIN_SRC clojure :results output
(doc trig-id)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/trig-id
: ([])
:   Returns a new globally unique id useful for feeding into send-trig
:    and matching on the event stream.
: 
:    See on-trigger docstring for usage example.

**** on-trigger
#+BEGIN_SRC clojure :results output
(doc on-trigger)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/on-trigger
([trig-id handler key] [node trig-id handler key])
  Registers a standard on-event handler with key which will call
   handler when matching triggers are recieved. Triggers are created
   with the send-trig ugen. Handler should be a fn which takes one
   argument - the latest trigger value. Triggers registered with the
   same key as another trigger or standard handler will remove and
   replace the old handler.

   Consider using trig-id to create a unique trigger id

    ;; create new id
    (def uid (trig-id))

    ;; define a synth which uses send-trig
    (defsynth foo
              [t-id 0]
              (send-trig (impulse 10) t-id (sin-osc)))

    ;; register a handler fn
    (on-trigger uid
                (fn [val] (println "trig val:" val))
                ::debug)

    ;; create a new instance of synth foo with trigger id as a
    ;; param
    (foo uid)

    ;;Trigger handler can be removed with:
    (remove-event-handler ::debug)
#+end_example

**** on-latest-trigger
#+BEGIN_SRC clojure :results output
(doc on-latest-trigger)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/on-latest-trigger
([trig-id handler key] [node trig-id handler key])
  Registers a standard on-latest-event handler with key which will call
   handler when matching triggers are recieved. Triggers are created
   with the send-trig ugen. Handler should be a fn which takes one
   argument - the latest trigger value. Triggers registered with the
   same key as another trigger or standard handler will remove and
   replace the old handler.

   Consider using trig-id to create a unique trigger id. See on-trigger
   docstring for usage example.

   Trigger handler can be removed with remove-event-handler.
#+end_example

**** on-sync-trigger
#+BEGIN_SRC clojure :results output
(doc on-sync-trigger)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/on-sync-trigger
([trig-id handler key] [node trig-id handler key])
  Registers a standard on-sync-event handler with key which will call
   handler when matching triggers are recieved. Triggers are created
   with the send-trig ugen. Handler should be a fn which takes one
   argument - the latest trigger value. Triggers registered with the
   same key as another trigger or standard handler will remove and
   replace the old handler.

   Consider using trig-id to create a unique trigger id. See on-trigger
   docstring for usage example.

   Trigger handler can be removed with remove-event-handler.
#+end_example

** Nodes & Groups                                           :nodes:groups:
*** Create & Free 
**** node
#+BEGIN_SRC clojure :results output
(doc node)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/node
([synth-name] [synth-name arg-map] [synth-name arg-map location] [synth-name arg-map location sdef])
  Asynchronously instantiate a synth node on the audio server.  Takes
  the synth name and a map of argument name/value pairs.  Optionally use
  target <node/group-id> and position <pos> to specify where the node
  should be located.  The position can be one
  of :head, :tail :before, :after, or :replace.

  (node "foo")
  (node "foo" {:pitch 60})
  (node "foo" {:pitch 60} {:target 0})
  (node "foo" {:pitch 60} {:position :tail :target 2})
  
#+end_example
**** group
#+BEGIN_SRC clojure :results output
(doc group)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/group
([] [name-or-position] [name-or-position position-or-target] [name position target] [name id position target])
  Create a new synth group as a child of the target group. By default
  creates a new group at the tail of the root group.

  The position can be one of :head, :tail :before, :after, or :replace.

  (group)                  ;=> Creates a new group at the tail of the
                               foundation-default-group
  (group "foo")            ;=> Creates a group named foo
  (group :tail my-g)       ;=> Creates a group at the tail of group
                               my-g
  (group "bar" :head my-g) ;=> Creates a named group at the head of
                               group my-g
#+end_example
**** node-free
#+BEGIN_SRC clojure :results output
(doc node-free)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-free
: ([this])
:   nil
**** group-free
#+BEGIN_SRC clojure :results output
(doc group-free)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/group-free
: ([group])
:   Destroys this group and any containing synths or subgroups.
**** group-clear
#+BEGIN_SRC clojure :results output
(doc group-clear)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/group-clear
: ([group])
:   Nukes all nodes in the group. This completely clears out all
:          subgroups and frees all subsynths.
**** group-deep-clear
#+BEGIN_SRC clojure :results output
(doc group-deep-clear)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/group-deep-clear
: ([group])
:   Traverses all groups below this group and frees all the
:          synths. Group structure is left unaffected.

*** Manipulate

**** node-start
#+BEGIN_SRC clojure :results output
(doc node-start)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-start
: ([this])
:   nil

**** node-pause
#+BEGIN_SRC clojure :results output
(doc node-pause)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-pause
: ([this])
:   nil

**** node-place
#+BEGIN_SRC clojure :results output
(doc node-place)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-place
: ([this position dest-node])
:   nil

**** node-control
#+BEGIN_SRC clojure :results output
(doc node-control)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-control
: ([this params])
:   Modify control parameters of the synth node.

**** node-control-range
#+BEGIN_SRC clojure :results output
(doc node-control-range)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-control-range
: ([this ctl-start ctl-vals])
:   Modify a range of control parameters of the synth node.

**** node-map-controls
#+BEGIN_SRC clojure :results output
(doc node-map-controls)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-map-controls
: ([this names-buses])
:   Connect a node's controls to a control bus.

**** node-map-n-controls
#+BEGIN_SRC clojure :results output
(doc node-map-n-controls)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-map-n-controls
: ([this start-control start-bus n])
:   Connect N controls of a node to a set of sequential control
:         buses, starting at the given control name.

**** group-prepend-node
#+BEGIN_SRC clojure :results output
(doc group-prepend-node)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/group-prepend-node
: ([group node])
:   Adds the node to the head (first to be executed) of the group.

**** group-append-node
#+BEGIN_SRC clojure :results output
(doc group-append-node)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/group-append-node
: ([group node])
:   Adds the node to the tail (last to be executed) of the group.

*** Info

**** node? 
#+BEGIN_SRC clojure :results output
(doc node? )
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node?
: ([obj])
:   Returns true if obj is a synth node i.e. a SynthNode or a SynthGroup
:    object which has a type which derives
:    from :overtone.sc.node/synth-node

**** node-live? 
#+BEGIN_SRC clojure :results output
(doc node-live? )
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-live?
: ([n])
:   Returns true if n is a running synth node.

**** node-loading?
#+BEGIN_SRC clojure :results output
(doc node-loading?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-loading?
: ([n])
:   Returns true if n is a loading synth node.

**** node-active?
#+BEGIN_SRC clojure :results output
(doc node-active?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-active?
: ([n])
:   Returns true if n is an active synth node.

**** node-tree
#+BEGIN_SRC clojure :results output
(doc node-tree)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-tree
: ([] [root])
:   Returns a data representation of the synth node tree starting at
:   the root group.

**** pp-node-tree 
#+BEGIN_SRC clojure :results output
(doc pp-node-tree )
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/pp-node-tree
: ([] [root])
:   Pretty print the node tree to *out*

**** node-get-control
#+BEGIN_SRC clojure :results output
(doc node-get-control)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-get-control
: ([node control-name])
:   Get a single synth control value by name.

**** node-get-controls
#+BEGIN_SRC clojure :results output
(doc node-get-controls)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-get-controls
: ([node control-names])
:   Get one or more synth control values by name.  Returns a map of
:   key/value pairs, for example:
: 
:   {:freq 440.0 :attack 0.2}

*** Foundation Groups

**** foundation-overtone-group
#+BEGIN_SRC clojure :results output
(doc foundation-overtone-group)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/foundation-overtone-group
([])
  Returns the node id for the container group for the whole of the Overtone
   foundational infrastructure. All of Overtone's groups and nodes will
   be a child of this node.

   This group should not typically be used. Prefer a group within
   foundation-user-group such as foundation-default-group or
   foundation-safe-group.
#+end_example

**** foundation-output-group
#+BEGIN_SRC clojure :results output
(doc foundation-output-group)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/foundation-output-group
: ([])
:   Returns the node id for the Overtone output group used for the
:    default output mixers.
: 
:    This group should not typically be used. Prefer a group within
:    foundation-user-group such as foundation-default-group or
:    foundation-safe-group.

**** foundation-monitor-group
#+BEGIN_SRC clojure :results output
(doc foundation-monitor-group)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/foundation-monitor-group
: ([])
:   Returns the node id for the Overtone output group for the default
:    monitors i.e. the recording synths.
: 
:    This group should not typically be used. Prefer a group within
:    foundation-user-group such as foundation-default-group or
:    foundation-safe-group.

**** foundation-input-group
#+BEGIN_SRC clojure :results output
(doc foundation-input-group)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/foundation-input-group
: ([])
:   Returns the node id for the Overtone output group for the default
:    input mixers.
: 
:    This group should not typically be used. Prefer a group within
:    foundation-user-group such as foundation-default-group or
:    foundation-safe-group.

**** foundation-user-group
#+BEGIN_SRC clojure :results output
(doc foundation-user-group)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/foundation-user-group
([])
  Returns the node id for the main Overtone user group. This is where
   you should place your activity. This group already contains three
   convenience groups which you should prefer to using this group
   directly:

  * foundation-safe-pre-default-group
  * foundation-default-group
  * foundation-safe-post-default-group

  See the docstrings for these groups for more details.
#+end_example

**** foundation-default-group
#+BEGIN_SRC clojure :results output
(doc foundation-default-group)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/foundation-default-group
: ([])
:   Returns the node id for the default Overtone group. This is where the
:    majority of user activity should take place. This group is the target
:    of a deep clear when the stop fn is called.

**** foundation-safe-group
#+BEGIN_SRC clojure :results output
(doc foundation-safe-group)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/foundation-safe-group
([])
  Synonym for foundation-safe-post-default-group.

  Returns the node id for a safe Overtone group. This is similar to
  the default group only it isn't the target of deep clear when the stop
  fn is called. Therefore synths in this group will *not* be
  automatically stopped on execution of the stop fn.

  This returns the safe group which is positioned *after* the default
  group. For a safe group that is positioned before the default group
  see foundation-safe-pre-default-group.
#+end_example

**** foundation-safe-pre-default-group
#+BEGIN_SRC clojure :results output
(doc foundation-safe-pre-default-group)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/foundation-safe-pre-default-group
([])
  Returns the node id for a safe Overtone group. This is similar to
  the default group only it isn't the target of deep clear when the stop
  fn is called. Therefore synths in this group will *not* be
  automatically stopped on execution of the stop fn.

  This returns the safe group which is positioned *after* the default
  group. For a safe group that is positioned after the default group
  see foundation-safe-post-default-group.
#+end_example

**** foundation-safe-post-default-group
#+BEGIN_SRC clojure :results output
(doc foundation-safe-post-default-group)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/foundation-safe-post-default-group
([])
  Returns the node id for a safe Overtone group. This is similar to
  the default group only it isn't the target of deep clear when the stop
  fn is called. Therefore synths in this group will *not* be
  automatically stopped on execution of the stop fn.

  This returns the safe group which is positioned *after* the default
  group. For a safe group that is positioned before the default group
  see foundation-safe-pre-default-group.
#+end_example

*** Manipulation Handlers

**** 

**** on-node-destroyed
#+BEGIN_SRC clojure :results output
(doc on-node-destroyed)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/on-node-destroyed
: ([node f])
:   Creates a oneshot event handler which will be triggered when node is
:    destroyed. Returns event handler key.

**** on-node-created
#+BEGIN_SRC clojure :results output
(doc on-node-created)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/on-node-created
: ([node f])
:   Creates a oneshot event handler which will be triggered when node is
:    created. Returns event handler key.

**** on-node-paused
#+BEGIN_SRC clojure :results output
(doc on-node-paused)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/on-node-paused
: ([node f])
:   Creates a recurring event handler which will be triggered when node
:    is paused. This on-pause handler is automatically removed when node
:    is destroyed. Returns on-pause handler key.

**** on-node-started
#+BEGIN_SRC clojure :results output
(doc on-node-started)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/on-node-started
: ([node f])
:   Creates a recurring event handler which will be triggered when node
:    is paused. This on-started handler is automatically removed when node
:    is destroyed. Returns on-started handler key.

*** Event Keys

*** node-destroyed-event-key
#+BEGIN_SRC clojure :results output
(doc node-destroyed-event-key)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-destroyed-event-key
: ([node])
:   Returns the key used for node destroyed events

*** node-created-event-key
#+BEGIN_SRC clojure :results output
(doc node-created-event-key)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-created-event-key
: ([node])
:   Returns the key used for node created events

*** node-paused-event-key
#+BEGIN_SRC clojure :results output
(doc node-paused-event-key)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-paused-event-key
: ([node])
:   Returns the key used for node paused events

*** node-started-event-key
#+BEGIN_SRC clojure :results output
(doc node-started-event-key)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/node-started-event-key
: ([node])
:   Returns the key used for node started events

** Server                                                           :server:
*** Startup
**** boot-server
#+BEGIN_SRC clojure :results output
(doc boot-server)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/boot-server
: ([])
:   Boot the default server.
**** boot-internal-server
#+BEGIN_SRC clojure :results output
(doc boot-internal-server)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/boot-internal-server
: ([])
:   Boot an internal server in the same process as overtone itself. Not
:   currently available on all platforms
**** boot-external-server
#+BEGIN_SRC clojure :results output
(doc boot-external-server)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/boot-external-server
: ([] [port] [port opts])
:   Boot an external server by starting up an external process and connecting to
:   it. Requires SuperCollider to be installed in the standard location for your
:   OS.
**** connect-external-server
#+BEGIN_SRC clojure :results output
(doc connect-external-server)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/connect-external-server
: ([] [port] [host port])
:   Connect to an externally running SC audio server listening to port
:   on host.  Host defaults to localhost and port defaults to 57110.

*** Shutdown
**** kill-server
#+BEGIN_SRC clojure :results output
(doc  kill-server)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/kill-server
: ([])
:   Shutdown the running server

*** Control
**** stop
#+BEGIN_SRC clojure :results output
(doc stop)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/stop
: ([])
:   Stop all running synths and metronomes. This does not remove any
:   synths/insts you may have defined, rather it just stops any of them
:   that are currently playing. Groups are left unaffected.

**** clear
#+BEGIN_SRC clojure :results output
(doc clear)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/clear
: ([])
:   Stop all running synths and metronomes. This does not remove any
:   synths/insts you may have defined, rather it just stops any of them
:   that are currently playing. Subgroups are cleared out and removed.

**** stop-all
#+BEGIN_SRC clojure :results output
(doc stop-all)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/stop-all
: ([])
:   Stop all running synths and metronomes including those in the safe
:   pre and post groups. This does not remove any synths/insts you may
:   have defined, rather it just stops any of them that are currently
:   playing. Groups are left unaffected

**** clear-all
#+BEGIN_SRC clojure :results output
(doc clear-all)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/clear-all
: ([])
:   Stop all running synths and metronomes including those in the safe
:   pre and post groups. This does not remove any synths/insts you may
:   have defined, rather it just stops any of them that are currently
:   playing. Subgroups are cleared out and removed.

*** OSC Communication
**** snd
#+BEGIN_SRC clojure :results output
(doc snd)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/snd
: ([path & args])
:   Sends an OSC message to the server. If the message path is a known
:   scsynth path, then the types of the arguments will be checked
:   according to what scsynth is expecting. Automatically converts any
:   args which are longs to ints.
: 
:   (snd "/foo" 1 2.0 "eggs")

**** recv
#+BEGIN_SRC clojure :results output
(doc recv)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/recv
([path] [path matcher-fn])
  Register your intent to wait for a message associated with given
  path to be received from the server. Returns a promise that will
  contain the message once it has been received. Does not block
  current thread (this only happens once you try and look inside the
  promise and the reply has not yet been received).

  If an optional matcher-fn is specified, will only deliver the
  promise when the matcher-fn returns true. The matcher-fn should
  accept one arg which is the incoming event info.
#+end_example

**** clear-msg-queue
#+BEGIN_SRC clojure :results output
(doc clear-msg-queue)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/clear-msg-queue
: ([])
:   Remove any scheduled OSC messages from the run queue.

**** at
#+BEGIN_SRC clojure :results output
(doc at)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/at
([time-ms & body])
Macro
  Schedule server communication - specify that communication messages
   execute on the server at a specific time in the future:

   ;; control synth foo to change :freq to 150
   ;; one second from now:
   (at (+ (now) 1000) (ctl foo :freq 150))

   Only affects code that communicates with the server using OSC
   messaging i.e. synth triggering and control. All code in the body of
   the at macro is executed immediately. Any OSC messages which are
   triggered as a result of executing the body are not immediately sent
   but are instead captured and then sent in a single OSC bundle with
   the specified timestamp once the body has completed. The server then
   stores these bundles and executes them at the specified time. This
   allows you to schedule the triggering and control of synths for
   specific times.

   The bundling is thread-local, so you don't have to worry about
   accidentally scheduling packets into a bundle started on another
   thread.

   Be careful not to confuse at with apply-at and apply-by which
   directly affect Clojure code.

   Warning, all liveness and 'node blocking when not ready' checks are
   disabled within the context of this macro. This means that it will
   fail silently if a server node you wish to control either has been
   since terminated or not had time to be initialised.
#+end_example

**** snd-immediately
#+BEGIN_SRC clojure :results output
(doc snd-immediately)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/snd-immediately
: ([& body])
: Macro
:   nil

*** Diagnostic
**** server-status
#+BEGIN_SRC clojure :results output
(doc server-status)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-status
: ([])
:   Check the status of the audio server.

**** server-info
#+BEGIN_SRC clojure :results output
(doc server-info)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/server-info
([])
  Fetches a bunch of useful server info. Has to trigger and poll a
  synth to fetch data. See #'server-num-output-buses,
  #'server-num-input-buses, #'server-num-audio-buses and
  #'server-num-buffers #'server-sample-rate, #'server-sample-dur,
  #'server-control-rate, #'server-control-dur for fast cached versions
  of the static values in this info map. Note, the number of running
  synths will also include the synth used to obtain this information.
#+end_example

**** server-opts
#+BEGIN_SRC clojure :results output
(doc server-opts)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-opts
: ([])
:   Returns options for currently connected server (if available)

**** server-connected?
#+BEGIN_SRC clojure :results output
(doc server-connected?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-connected?
: ([])
:   Returns true if the server is currently connected

**** server-disconnected?
#+BEGIN_SRC clojure :results output
(doc server-disconnected?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-disconnected?
: ([])
:   Returns true if the server is currently disconnected

**** server-connecting?
#+BEGIN_SRC clojure :results output
(doc server-connecting?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-connecting?
: ([])
:   Returns true if the server is connecting

**** internal-server?
#+BEGIN_SRC clojure :results output
(doc internal-server?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/internal-server?
: ([])
:   Returns true if the server is internal

**** external-server?
#+BEGIN_SRC clojure :results output
(doc external-server?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/external-server?
: ([])
:   Returns true if the server is external

**** connection-info
#+BEGIN_SRC clojure :results output
(doc connection-info)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/connection-info
: ([])
:   Returns connection information regarding the currently connected
:   server

**** server-sample-rate
#+BEGIN_SRC clojure :results output
(doc server-sample-rate)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-sample-rate
: ([])
:   Returns the sample rate of the server. This number is cached for a
:    given running server for the duration of boot

**** server-num-output-buses
#+BEGIN_SRC clojure :results output
(doc server-num-output-buses)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-num-output-buses
: ([])
:   Returns the number of output buses accessible by the server. This number may
:   change depending on host architecture but is cached for a given running server
:   for the duration of boot.

**** server-num-input-buses
#+BEGIN_SRC clojure :results output
(doc server-num-input-buses)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-num-input-buses
: ([])
:   Returns the number of input buses accessible by the server. This number may
:   change depending on host architecture but is cached for a given running
:   server for the duration of boot.

**** server-num-audio-buses
#+BEGIN_SRC clojure :results output
(doc server-num-audio-buses)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-num-audio-buses
: ([])
:   Returns the number of audio buses accessible by the server. This number may
:   change depending on host architecture but is cached for a given running server
:   for the duration of boot.

**** server-num-buffers
#+BEGIN_SRC clojure :results output
(doc server-num-buffers)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/server-num-buffers
: ([])
:   Returns the number of buffers accessible by the server. This number may
:   change depending on host architecture but is cached for a given running server
:   for the duration of boot.

**** ensure-connected!
#+BEGIN_SRC clojure :results output
(doc ensure-connected!)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/ensure-connected!
: ([])
:   Throws an exception if the server isn't currently connected

*** Debug
**** sc-osc-log-on
#+BEGIN_SRC clojure :results output
(doc sc-osc-log-on)
#+END_SRC

#+RESULTS:

**** sc-osc-log-off
#+BEGIN_SRC clojure :results output
(doc sc-osc-log-off)
#+END_SRC

#+RESULTS:

**** sc-osc-log
#+BEGIN_SRC clojure :results output
(doc sc-osc-log)
#+END_SRC

#+RESULTS:

**** sc-debug-on
#+BEGIN_SRC clojure :results output
(doc sc-debug-on)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/sc-debug-on
: ([])
:   Turn on output from both the Overtone and the audio server.

**** sc-debug-off
#+BEGIN_SRC clojure :results output
(doc sc-debug-off)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/sc-debug-off
: ([])
:   Turn off debug output from both the Overtone and the audio server.

**** external-server-log
#+BEGIN_SRC clojure :results output
(doc external-server-log)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/external-server-log
: ([])
:   Print the external server log.

**** sc-osc-debug-on
#+BEGIN_SRC clojure :results output
(doc sc-osc-debug-on)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/sc-osc-debug-on
: ([])
:   Log and print out all outgoing OSC messages

**** sc-osc-debug-off
#+BEGIN_SRC clojure :results output
(doc sc-osc-debug-off)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/sc-osc-debug-off
: ([])
:   Turns off OSC debug messages (see sc-osc-debug-on)

** Visualisation
*** Graphviz
**** Dot Notation
**** graphviz
#+BEGIN_SRC clojure :results output
(doc graphviz)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/graphviz
: ([s])
:   Generate dot notation for synth design.
:    (see overtone.repl.debug/unified-sdef)

**** Show PDF

**** show-graphviz-synth
#+BEGIN_SRC clojure :results output
(doc show-graphviz-synth)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/show-graphviz-synth
([s])
  Generate pdf of design for synth s. This assumes that graphviz has
   been installed and the dot program is available on the system's PATH.

   On OS X, a simple way to install graphviz is with homebrew: brew
   install graphviz

   Also opens pdf on Mac OS X (with open) and Linux (with xdg-open).
#+end_example

** External Assets
*** Generic URLs
**** Auto cache & Return Path
asset-path asset-seq
asset-bundle-path
asset-bundle-dir

*** Freesound.org

**** Playable Function
 freesound

**** Auto cache & Query
 freesound-info
 freesound-path
 freesound-pack-info
 freesound-pack-dir
 freesound-search
 freesound-searchm
 freesound-search-paths

** Algorithmic Composition                                            :algo:
*** Chance
**** Choice
***** choose
#+BEGIN_SRC clojure :results output
(doc choose)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/choose
: ([col])
:   Choose a random element from col.
***** choose-n
#+BEGIN_SRC clojure :results output
(doc choose-n)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/choose-n
: ([n col])
:   Choose n random elements from col.
***** weighted-choose
#+BEGIN_SRC clojure :results output
(doc weighted-choose)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/weighted-choose
([val-prob-map] [vals probabilities])
  Returns an element from list vals based on the corresponding
  probabilities list. The length of vals and probabilities should be
  similar and the sum of all the probabilities should be 1. It is also
  possible to pass a map of val -> prob pairs as a param.

  The following will return one of the following vals with the
  corresponding probabilities:
  1 -> 50%
  2 -> 30%
  3 -> 12.5%
  4 -> 7.5%
  (weighted-choose [1 2 3 4] [0.5 0.3 0.125 0.075])
  (weighted-choose {1 0.5, 2 0.3, 3 0.125, 4 0.075})
#+end_example

****** Dice
******* weighted-coin
#+BEGIN_SRC clojure :results output
(doc weighted-coin)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/weighted-coin
: ([n])
:   Returns true or false. Probability of true is weighted by n which
:    should be within the range 0 - 1. n will be truncated to range 0 - 1
:    if it isn't

******* ranged-rand
#+BEGIN_SRC clojure :results output
(doc ranged-rand)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/ranged-rand
: ([min max])
:   Returns a random value within the specified range

*** Scaling
**** Range
**** scale-range
#+BEGIN_SRC clojure :results output
(doc scale-range)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/scale-range
([x in-min in-max out-min out-max])
  Scales a given input value within the specified input range to a
  corresponding value in the specified output range using the formula:

           (out-max - out-min) (x - in-min)
   f (x) = --------------------------------  + out-min
                    in-max - in-min


#+end_example

**** Rounding

**** closest-to
#+BEGIN_SRC clojure :results output
(doc closest-to)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/closest-to
: ([n low hi])
:   Returns either low or hi depending on which is numerically closer
:   to n.
:   (closest-to 4.7 4 6) ;=> 4 (4.7 is closer to 4 than 6)

**** round-to
#+BEGIN_SRC clojure :results output
(doc round-to)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/round-to
: ([n div])
:   Rounds n to the nearest multiple of div
:   (round-to 4.7 1) ;=> 5
:   (round-to 4.7 2) ;=> 4 (4.7 is closer to 4 than 6)

*** Trig
**** Scaled
***** 
***** cosr
#+BEGIN_SRC clojure :results output
(doc cosr)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/cosr
([idx range centre period])
  Scaled, shifted (i.e. mul-add) cosine fn with the frequency specified in
  terms of the idx (typically representing the beat).

  Returns a value at idx along a scaled cosine fn with specified centre and
  range. The frequency is defined to be period idxs. Similar to Impromptu's
  cosr.

  (cosr 0 2 10 8) ;=> 12
  (cosr 2 2 10 8) ;=> 10
  (cosr 4 2 10 8) ;=> 8
  (cosr 6 2 10 8) ;=> 10
  (cosr 8 2 10 8) ;=> 12
#+end_example
***** sinr
#+BEGIN_SRC clojure :results output
(doc sinr)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/sinr
([idx range centre period])
  Scaled, shifted (i.e. mul-add) sine fn with the frequency specified in
  terms of the idx (typically representing the beat).

  Returns a value at idx along a scaled sine fn with specified centre and
  range. The frequency is defined to be period idxs. Similar to Impromptu's
  sinr.

  (sinr 0 2 10 8) ;=> 10
  (sinr 2 2 10 8) ;=> 12
  (sinr 4 2 10 8) ;=> 10
  (sinr 6 2 10 8) ;=> 8
  (sinr 8 2 10 8) ;=> 10
#+end_example
***** tanr
#+BEGIN_SRC clojure :results output
(doc tanr)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/tanr
([idx range centre period])
  Scaled, shifted (i.e. mul-add) tan fn with the frequency specified in
  terms of the idx (typically representing the beat).

  Returns a value at idx along a scaled tan fn with specified centre and
  range. The frequency is defined to be period idxs. Similar to Impromptu's
  tanr.

  (tanr 0 2 10 8)        ;=> 10
  (tanr 1.999999 2 10 8) ;=> ~2546489
  (tanr 2 2 10 8)        ;=> ~3.2665
  (tanr 4 2 10 8)        ;=> 10
  (tanr 5.999999 2 10 8) ;=> ~2546489
  (tanr 6 2 10 8)        ;=> ~1.0886
  (tanr 8 2 10 8)        ;=> 10
#+end_example

*** Functions
**** Cycling
***** cycle-fn
#+BEGIN_SRC clojure :results output
(doc cycle-fn)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/cycle-fn
([& fns])
  Returns a fn which will cycle between each of the fns specified. The
   first time the fn is called, the first fn in fns will be called, the
   second time, the second fn in fns etc, cycling around indefinitely.

   The args passed into the returned fn will be passed through to the
   appropriate inner fn. Additionally, the result of the inner fn will
   be returned as the result of the outer fn.

   Will catch any exceptions generated by the internal fns and print a
   stacktrace to stdout.

   (def f (cycle-fn (fn [st] (println "hi" st))
                    (fn [st] (println "yo" st))
                    (fn [st] (println "ho ho" st))))

   (f "there") ;=> "hi there"
   (f "bro")   ;=> "yo bro"
   (f "santa") ;=> "ho ho santa"
   (f "again") ;=> "hi again"
#+end_example

*** List
**** Rotation
***** rotate
#+BEGIN_SRC clojure :results output
(doc rotate)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/rotate
([n coll])
  Treat a list/vector as a circular data structure and rotate it by n
   places:

   (rotate 0  [1 2 3 4]) ;=> [1 2 3 4]
   (rotate 2  [1 2 3 4]) ;=> [3 4 1 2]
   (rotate -1 [1 2 3 4]) ;=> [4 1 2 3]

   Note, coll should be countable.
#+end_example

**** Creation

***** fill
#+BEGIN_SRC clojure :results output
(doc fill)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/fill
([size coll])
  Create a new vector with the specified size containing either part of
   list ls, or ls repeated until size elements have been placed into result
   vector.

   (fill 5 [1])      ;=> [1 1 1 1 1]
   (fill 6 [1 2 3])   ;=> [1 2 3 1 2 3]
   (fill 7 [5 6]   )  ;=> [5 6 5 6 5 6 5]
   (fill 3 [1 2 3 4]) ;=> [1 2 3]

   Note, coll should be non-empty and countable.
#+end_example

** Music
*** Pitch
**** Ratios
 unison octave fifth sixth third fourth
  min-third min-sixth
**** Note Shifting
 shift flat sharp invert inc-first
  dec-last
**** Notes
note octave-note nth-octave
  nth-equal-tempered-freq
  canonical-pitch-class-name note-info
  mk-midi-string match-note
**** Scales
scale resolve-scale scale-field
  nth-interval resolve-degree degree->int
  degree->interval degrees->pitches
  resolve-degree resolve-degrees
  interval-freq
**** Chords
 chord resolve-chord rand-chord
  invert-chord chord-degree
**** Discovery
 find-scale-name find-note-name
  find-pitch-class-name find-chord
**** Frequencies
 cents midi->hz hz->midi
**** Amplitude
 db->amp

** Sound Data
*** Buffers                                                       :buffers:
**** Create & Free
***** buffer
#+BEGIN_SRC clojure :results output
(doc buffer)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/buffer
: ([size] [size num-channels-or-name] [size num-channels name])
:   Synchronously allocate a new zero filled buffer for storing audio
:   data with the specified size and num-channels. Size will be
:   automatically floored and converted to a Long - i.e. 2.7 -> 2
***** buffer-free
#+BEGIN_SRC clojure :results output
(doc buffer-free)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/buffer-free
: ([buf])
:   Synchronously free an audio buffer and the memory it was consuming.
***** buffer-alloc-read
#+BEGIN_SRC clojure :results output
(doc buffer-alloc-read)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buffer-alloc-read
([path] [path start] [path start n-frames])
  Synchronously allocates a buffer with the same number of channels as
  the audio file given by 'path'. Reads the number of samples
  requested ('n-frames') into the buffer, or fewer if the file is
  smaller than requested. Reads sound file data from the given starting
  frame ('start') in the file. If 'n-frames' is less than or equal to
  zero, the entire file is read.

  Ignores OSC scheduling via the at macro; all inner OSC calls are sent
  immediately.
#+end_example

**** Generate Buffer Data
data->wavetable

**** create-buffer-data
#+BEGIN_SRC clojure :results output
(doc create-buffer-data)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/create-buffer-data
([size f range-min range-max])
  Create a sequence of floats for use as a buffer.  Result will contain
   values obtained by calling f with values linearly interpolated
   between range-min (inclusive) and range-max (exclusive).  For most
   purposes size must be a power of 2.

   Examples:

   Just a line from -1 to 1:
    (create-buffer-data 32 identity -1 1)

   Sine-wave for (osc) ugen:
    (create-buffer-data 512 #(Math/sin %) 0 TWO-PI)

   Chebyshev polynomial for wave-shaping:
    (create-buffer-data 1024 #(- (* 2 % %) 1) -1 1)
#+end_example

**** Read & Write To Server
 buffer-read buffer-write!
  buffer-write-relay! buffer-fill!
  buffer-set! buffer-get
  buffer-save buffer-data
  buffer-read
**** Write To Filesystem
 write-wav
**** Streaming In & Out

buffer-stream buffer-stream?
  buffer-stream-close buffer-cue
  buffer-cue? buffer-cue-pos
  buffer-stream-close
**** Query
***** buffer? 
#+BEGIN_SRC clojure :results output
(doc buffer?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/buffer?
: ([buf])
:   Returns true if buf is a buffer.

***** buffer-info?
#+BEGIN_SRC clojure :results output
(doc buffer-info)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buffer-info
([buf-id])
  Fetch the information for buffer associated with buf-id (either an
  integer or an associative with an :id key). Synchronous.

  Information returned is as follows:

  :size       - number of frames in the buffer
  :n-channels - number of audio channels stored in the buffer
  :rate       - rate of the buffer (typical rate is 44100 samples per
                second)
  :n-samples  - total number of samples in the buffer (* size n-channels)
  :rate-scale - rate to specify in order to play the buffer correctly
                according
                to the server's sample rate (/ rate (server-sample-rate))
  :duration   - duration of the buffer in seconds
  :id         - unique id for the buffer
#+end_example

***** file-buffer? 
#+BEGIN_SRC clojure :results output
(doc file-buffer?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/file-buffer?
: ([buf])
:   nil

***** buffer-out-stream?
#+BEGIN_SRC clojure :results output
(doc buffer-out-stream?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/buffer-out-stream?
: ([bs])
:   nil

***** buffer-in-stream?
#+BEGIN_SRC clojure :results output
(doc buffer-in-stream?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/buffer-in-stream?
: ([bc])
:   nil

**** Info
***** buffer-info
#+BEGIN_SRC clojure :results output
(doc buffer-info)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buffer-info
([buf-id])
  Fetch the information for buffer associated with buf-id (either an
  integer or an associative with an :id key). Synchronous.

  Information returned is as follows:

  :size       - number of frames in the buffer
  :n-channels - number of audio channels stored in the buffer
  :rate       - rate of the buffer (typical rate is 44100 samples per
                second)
  :n-samples  - total number of samples in the buffer (* size n-channels)
  :rate-scale - rate to specify in order to play the buffer correctly
                according
                to the server's sample rate (/ rate (server-sample-rate))
  :duration   - duration of the buffer in seconds
  :id         - unique id for the buffer
#+end_example

***** num-frames
#+BEGIN_SRC clojure :results output
(doc num-frames)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/num-frames
: ([buf])
:   Returns the size of the buffer.

***** buffer-id
#+BEGIN_SRC clojure :results output
(doc buffer-id)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/buffer-id
: ([b])
:   Return the id of buffer b. Simply punts out to to-sc-id

*** Samples
**** Create
***** load-sample
#+BEGIN_SRC clojure :results output
(doc load-sample)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/load-sample
([path & args])
  Synchronously load a .wav or .aiff file into a memory buffer. Returns
   the buffer.

    ; e.g.
    (load-sample "~/studio/samples/kit/boom.wav")

  Takes optional params :start and :size. Allocates buffer to number of
  channels of file and number of samples requested (:size), or fewer if
  sound file is smaller than requested. Reads sound file data from the
  given starting frame in the file (:start). If the number of frames
  argument is less than or equal to zero, the entire file is read.

  If optional param :force is set to true, any previously create cache
  of the sample will be removed and the sample will be forcibly
  reloaded.
#+end_example
***** load-samples
#+BEGIN_SRC clojure :results output
(doc load-samples)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/load-samples
: ([& path-glob])
:   Takes a directory path or glob path (see #'overtone.helpers.file/glob)
:    and loads up all matching samples and returns a seq of maps
:    representing information for each loaded sample (see
:    load-sample). Samples should be in .aiff or .wav format.
***** sample
#+BEGIN_SRC clojure :results output
(doc sample)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/sample
([path & args])
  Loads a .wav or .aiff file into a memory buffer. Returns a function
   capable of playing that sample. Memoizes result and returns same
   sample on subsequent calls.

   ; e.g.
   (sample "~/music/samples/flibble.wav")

  
#+end_example
***** defsample
#+BEGIN_SRC clojure :results output
(doc defsample)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/defsample
: ([s-name path & args])
: Macro
:   Define a s-name as a var in the current namespace referencing a
:    sample with the specified path and args.
: 
:    Equivalent to:
:    (def s-name (sample path args...))

**** Playback

***** mono-player
#+BEGIN_SRC clojure :results output
(doc mono-player)
#+END_SRC

#+RESULTS:

***** stereo-player
#+BEGIN_SRC clojure :results output
(doc stereo-player)
#+END_SRC

#+RESULTS:

*** Busses
**** Create & Free
***** control-bus
#+BEGIN_SRC clojure :results output
(doc control-bus)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/control-bus
: ([] [n-channels-or-name] [n-channels name])
:   Allocate one or more successive control buses. By default, just one
:    bus is allocated. However, if you specify a number of channels, a
:    successive range of that length will be allocated.
: 
:    You may also specify a name for the bus for labelling purposes.
***** audio-bus
#+BEGIN_SRC clojure :results output
(doc audio-bus)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/audio-bus
([] [n-channels-or-name] [n-channels name])
  Allocate one or more successive audio buses. By default, just one
   bus is allocated. However, if you specify a number of channels, a
   successive range of that length will be allocated.

   For example, to allocate a stereo bus: (audio-bus 2)

   You may also specify a name for the bus for labelling purposes.
#+end_example
***** free-bus
#+BEGIN_SRC clojure :results output
(doc free-bus)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/free-bus
: ([bus])
:   Free this control or audio bus - enabling the resource to be re-allocated

**** Modify & Read

***** 

***** control-bus-set! 
#+BEGIN_SRC clojure :results output
(doc control-bus-set! )
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/control-bus-set!
([bus val] [bus val offset])
  Asynchronously updates control bus to new val.

   (control-bus-set! my-bus 3) ;=> Sets my-bus to the value 3

   An optional offset may be supplied to access values within
   multi-channel buses.

   Modification takes place on the server asynchronously.
#+end_example

***** control-bus-set-range!
#+BEGIN_SRC clojure :results output
(doc control-bus-set-range!)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/control-bus-set-range!
([bus vals] [bus vals offset])
  Asynchronously set a range of consecutive control buses to the
   supplied vals.

   An optional offset may be supplied to set values within multi-channel
   buses.

   Modification takes place on the server asynchronously.
#+end_example

***** control-bus-get
#+BEGIN_SRC clojure :results output
(doc control-bus-get)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/control-bus-get
: ([bus] [bus offset])
:   Synchronously get the current value of a control bus. If a
:    control-bus record is passed in, all channels are returned.
: 
:    An optional offset may be supplied to access values within
:    multi-channel buses.

***** control-bus-get-range
#+BEGIN_SRC clojure :results output
(doc control-bus-get-range)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/control-bus-get-range
: ([bus len] [bus len offset])
:   Synchronously get a range (of length len) of consecutive control bus
:    values.
: 
:    An optional offset may be supplied to access values within
:    multi-channel buses.

**** Query
***** bus? 
#+BEGIN_SRC clojure :results output
(doc bus? )
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/bus?
: ([bus])
:   Returns true if the specified bus is a map representing a bus (either control
:   or audio) 
***** control-bus? 
#+BEGIN_SRC clojure :results output
(doc control-bus? )
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/control-bus?
: ([bus])
:   Returns true if the specified bus is a map representing a control bus.
***** audio-bus?
#+BEGIN_SRC clojure :results output
(doc audio-bus?)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/audio-bus?
: ([bus])
:   Returns true if the specified bus is a map representing a control bus.

**** Info
***** bus-id
#+BEGIN_SRC clojure :results output
(doc bus-id)
#+END_SRC

#+RESULTS:

**** Monitor

***** bus-monitor
#+BEGIN_SRC clojure :results output
(doc bus-monitor)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/bus-monitor
([bus] [bus chan-offset])
  Returns either a control or audio bus monitor depending on the rate
   of bus supplied. Returns an atom containing the current value of the
   control bus. Note that this isn't the peak amplitude, rather the
   direct value of the control bus.

   For multi-channel buses, an offset may be specified. Current
   amplitude is updated within the returned atom every 50 ms.

   Note - only creates one monitor per bus - subsequent calls for the
   same bus will return a cached monitor.

   See audio-bus-monitor and control-bus-monitor for specific details.
#+end_example

***** control-bus-monitor
#+BEGIN_SRC clojure :results output
(doc control-bus-monitor)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/control-bus-monitor
([control-bus] [control-bus chan-offset])
  Control bus monitor. Returns an atom containing the current value of
   the control bus. Note that this isn't the peak amplitude, rather the
   direct value of the control bus.

   For multi-channel buses, an offset may be specified. Current
   amplitude is updated within the returned atom every 50 ms.

   Note - only creates one monitor per control bus - subsequent calls for
   the same control bus idx will return a cached monitor.
#+end_example

***** audio-bus-monitor
#+BEGIN_SRC clojure :results output
(doc audio-bus-monitor)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/audio-bus-monitor
([audio-bus] [audio-bus chan-offset])
  Mono bus amplitude monitor. Returns an atom containing the current
   amplitude of the audio bus. Note that this isn't the current value,
   rather it's the peak amplitude of the signal within the audio bus.

   For multi-channel buses, an offset may be specified. Current
   amplitude is updated within the returned atom every 50 ms.

   Note - only creates one monitor per audio bus - subsequent calls for
   the same audio bus idx will return a cached monitor.
#+end_example

** Persistence
*** Local Store
**** Access
***** store-get
#+BEGIN_SRC clojure :results output
(doc store-get)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/store-get
: ([key] [key not-found])
:   Get config value. Returns default if specified and the config does
:   not contain key.
***** store-set! 
#+BEGIN_SRC clojure :results output
(doc store-set! )
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/store-set!
: ([key val])
:   Set store key to val
***** store
#+BEGIN_SRC clojure :results output
(doc store)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/store
: ([])
:   Get the full user store map

** CGens
*** Audio In 
**** sound-in
#+BEGIN_SRC clojure :results output
(doc sound-in)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/sound-in
([bus])
  
  read audio from hardware inputs 

  [bus 0]

  bus - The channel (or array of channels) to read 
        in. These start at 0, which will 
        correspond to the first audio input. 

  Reads audio from the input of your computer or soundcard. 
  It is a wrapper UGen based on In, which offsets the index 
  such that 0 will always correspond to the first input 
  regardless of the number of inputs present.

  N.B. On Intel based Macs, reading the built-in microphone 
  or input may require creating an aggregate device in 
  AudioMIDI Setup. 

  Categories: Composite Ugen
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

*** Buffer Playback

**** 

**** scaled-play-buf
#+BEGIN_SRC clojure :results output
(doc scaled-play-buf)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/scaled-play-buf
([num-channels buf-num rate trigger start-pos loop action])
  
  Play back a sample resident in a buffer with a rate scaled 
  depending on the buffer's sample-rate. 

  [num-channels :none, buf-num 0, rate 1, trigger 1.0, start-pos 0.0, loop 0.0, action 0]

  num-channels - The number of channels that the 
                 buffer will be. This must be a 
                 fixed integer. 
  buf-num      - The index of the buffer to use. 
  rate         - Rate multiplier. 1.0 is the 
                 default rate for the specified 
                 buffer, 2.0 is one octave up, 0.5 
                 is one octave down -1.0 is 
                 backwards normal rate ... etc. 
                 Interpolation is cubic. 
  trigger      - A trigger causes a jump to the 
                 startPos. A trigger occurs when a 
                 signal changes from <= 0 to > 0. 
  start-pos    - Sample frame to start playback. 
  loop         - 1 means true, 0 means false. This 
                 is modulateable. 
  action       - Action to be executed when the 
                 buffer is finished playing. 

  Uses buf-rate-scale to determine the rate with which to 
  play back the specified buffer. 

  Categories: Composite Ugen
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** scaled-v-disk
#+BEGIN_SRC clojure :results output
(doc scaled-v-disk)
#+END_SRC

#+RESULTS:

*** Control
**** hold
#+BEGIN_SRC clojure :results output
(doc hold)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/hold
([in hold-time release-time done])
  
  Hold an input source for a set period of time and then 
  stop. 

  [in 0.0, hold-time 1.0, release-time 0.01, done ]

  in           - Input source. 
  hold-time    - Hold time in seconds. 
  release-time - Release time in seconds 
  done         - Action to take after release 

  Hold an input source for a set period of time and then 
  stop by applying a simple envelope. Takes a hold-time, a 
  release-time, and a done action. 

  Categories: Composite Ugen
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

*** Oscillators

**** pm-osc
#+BEGIN_SRC clojure :results output
(doc pm-osc)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/pm-osc
([car-freq mod-freq pm-index mod-phase])
  
  Phase modulation sine oscillator pair. 

  [car-freq 0.0, mod-freq 0.0, pm-index 0.0, mod-phase 0.0]

  car-freq  - Carrier frequency 
  mod-freq  - Modulation frequency 
  pm-index  - Phase modulation index 
  mod-phase - Modulation phase 

  Please add some docs! 

  Categories: Composite Ugen
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** square
#+BEGIN_SRC clojure :results output
(doc square)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/square
([freq])
  
  A square wave generator 

  [freq 440]

  freq - Signal frequency 

  A square wave only exists in two states: high and low. 
  This wave produces only odd harmonics resulting in a 
  mellow, hollow sound. This makes it particularly suitable 
  for emulating wind instruments, adding width to strings 
  and pads, or for the creation of deep, wide bass sounds.

  See the pulse ugen if you wish to modulate the width. 

  Categories: Composite Ugen
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

*** Mix

**** mix
#+BEGIN_SRC clojure :results output
(doc mix)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/mix
([ins])
  
  Mix a list of input channels into a single channel. 

  [ins []]

  ins - List of input channels to mix 

  Mix the list of input channels by summing them together 
  and dividing by the number of input signals. See sum if 
  you wish to just add the signals together. 

  Categories: Composite Ugen
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** splay
#+BEGIN_SRC clojure :results output
(doc splay)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/splay
([in-array spread level center level-comp?])
  
  Spread input channels across a stereo field 

  [in-array [], spread 1, level 1, center 0, level-comp? true]

  in-array    - List of input channels to splay. 
  spread      - The audio spread width. 
  level       - Ampilitude level of each 
                individual spread channel (only 
                used if level-comp is false). 
  center      - Center point of audio spread. 
  level-comp? - Boolean switch to determine 
                whether automatic level 
                compensation should be used. 

  Spread input channels across a stereo field, with control 
  over the center point and spread width of the target 
  field, and level compensation that lowers the volume for 
  each additional input channel. 

  Categories: Composite Ugen
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** sum
#+BEGIN_SRC clojure :results output
(doc sum)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/sum
([ins])
  
  sum a list of input channels into a single channel. 

  [ins []]

  ins - List of input channels to sum 

  Sum the list of input channels by summing them together. 
  Be careful about summing too many channels together as the 
  resulting signal will be progressively amplified. 

  Categories: Composite Ugen
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

*** Pitch

**** add-cents
#+BEGIN_SRC clojure :results output
(doc add-cents)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/add-cents
([freq n-cents])
  
  Add n-cents to freq. 

  [freq :none, n-cents 1]

  freq    - Input frequency source 
  n-cents - Number of cents to add 

  Returns a frequency which is the result of adding n-cents 
  to the src frequency. A cent is a logarithmic measurement 
  of pitch, where 1-octave equals 1200 cents. 

  Categories: Composite Ugen
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

*** Tapping

**** tap
#+BEGIN_SRC clojure :results output
(doc tap)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/tap
([label freq src])
  
  Tap the hell out of ugens for great win 

  [label :none, freq :none, src :none]

  label - String label for this tap. Must be 
          unique to a given synth. 
  freq  - Frequency of tap value updates in Hertz 
  src   - Ugen to tap 

  Allows you to tap arbitrary ugens within a given synth. 
  The containing synth then automatically gets atoms for 
  each ugen you tap which will automagically be populated by 
  the latest ugen value updated at the specified frequency. 

  Categories: Composite Ugen
  Rates: [ :kr ]
  Default rate: :kr
#+end_example

*** Range

**** range-lin
#+BEGIN_SRC clojure :results output
(doc range-lin)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/range-lin
([in dstlo dsthi])
  
  Map ugens with default range linearly to another 

  [in 0.0, dstlo 1.0, dsthi 2.0]

  in    - Input to convert (should have range -1 
          to 1) 
  dstlo - Lower limit of output range 
  dsthi - Upper limit of output range 

  Linearly maps input signal with expected range of -1 to 1 
  to the specified range from dstlo to dsthi. 

  Categories: Composite Ugen
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

** ugens                                                             :ugens:
*** UGen Helper Constants
**** Done Actions 
***** NO-ACTION
#+BEGIN_SRC clojure :results output
(doc NO-ACTION)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/NO-ACTION
:   Do nothing when the ugen is finished
***** PAUSE
#+BEGIN_SRC clojure :results output
(doc PAUSE)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/PAUSE
:   Pause the enclosing synth, but do not free it
***** FREE
#+BEGIN_SRC clojure :results output
(doc FREE)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE
:   Free the enclosing synth
***** FREE-AND-BEFORE
#+BEGIN_SRC clojure :results output
(doc FREE-AND-BEFORE)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-AND-BEFORE
:   Free both this synth and the preceding node
***** FREE-AND-AFTER
#+BEGIN_SRC clojure :results output
(doc FREE-AND-AFTER)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-AND-AFTER
:   Free both this synth and the following node
***** FREE-AND-GROUP-BEFORE
#+BEGIN_SRC clojure :results output
(doc FREE-AND-GROUP-BEFORE)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-AND-GROUP-BEFORE
:   Free this synth; if the preceding node is a group then do g_freeAll
:    on it, else free it
***** FREE-AND-GROUP-AFTER
#+BEGIN_SRC clojure :results output
(doc FREE-AND-GROUP-AFTER)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-AND-GROUP-AFTER
:   Free this synth; if the following node is a group then do g_freeAll
:    on it, else free it
***** FREE-UPTO-THIS
#+BEGIN_SRC clojure :results output
(doc FREE-UPTO-THIS)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-UPTO-THIS
:   Free this synth and all preceding nodes in this group
***** FREE-FROM-THIS-ON
#+BEGIN_SRC clojure :results output
(doc FREE-FROM-THIS-ON)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-FROM-THIS-ON
:   Free this synth and all following nodes in this group
***** FREE-PAUSE-BEFORE
#+BEGIN_SRC clojure :results output
(doc FREE-PAUSE-BEFORE)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-PAUSE-BEFORE
:   Free this synth and pause the preceding node
***** FREE-PAUSE-AFTER
#+BEGIN_SRC clojure :results output
(doc FREE-PAUSE-AFTER)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-PAUSE-AFTER
:   Free this synth and pause the following node
***** FREE-AND-GROUP-BEFORE-DEEP
#+BEGIN_SRC clojure :results output
(doc FREE-AND-GROUP-BEFORE-DEEP)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-AND-GROUP-BEFORE-DEEP
:   Free this synth and if the preceding node is a group then do
:   g_deepFree on it, else free it
***** FREE-AND-GROUP-AFTER-DEEP
#+BEGIN_SRC clojure :results output
(doc FREE-AND-GROUP-AFTER-DEEP)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-AND-GROUP-AFTER-DEEP
:   Free this synth and if the following node is a group then do
:  g_deepFree on it, else free it
***** FREE-CHILDREN
#+BEGIN_SRC clojure :results output
(doc FREE-CHILDREN)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-CHILDREN
:   Free this synth and all other nodes in this group (before and after)
***** FREE-GROUP
#+BEGIN_SRC clojure :results output
(doc FREE-GROUP)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/FREE-GROUP
:   Free the enclosing group and all nodes within it (including this
:    synth)

**** FFT Windows 

***** SINE
#+BEGIN_SRC clojure :results output
(doc SINE)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/SINE
:   nil

***** HANN
#+BEGIN_SRC clojure :results output
(doc HANN)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/HANN
:   nil

***** RECT
#+BEGIN_SRC clojure :results output
(doc RECT)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/RECT
:   nil

**** Lines

***** LINEAR
#+BEGIN_SRC clojure :results output
(doc LINEAR)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/LINEAR
:   nil

***** LIN
#+BEGIN_SRC clojure :results output
(doc LIN)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/LIN
:   nil

***** EXPONENTIAL
#+BEGIN_SRC clojure :results output
(doc EXPONENTIAL)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/EXPONENTIAL
:   nil

***** EXP
#+BEGIN_SRC clojure :results output
(doc EXP)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/EXP
:   nil

**** Onset Analysis
POWER MAGSUM COMPLEX RCOMPLEX PHASE
   WPHASE MKL
**** Infinity
***** INFINITE 
***** INF
#+BEGIN_SRC clojure :results output
(doc INF)
#+END_SRC

#+RESULTS:
: -------------------------
: overtone.live/INF
:   Positive infinity - abbreviation for Float/POSITIVE_INFINITY

*** UGen Envelope Helper Functions
   env-perc env-triangle env-sine env-lin env-cutoff
   env-dadsr env-adsr env-asr

*** Unary UGens
   neg not-pos? abs ceil floor frac sign squared cubed
   sqrt exp reciprocal midicps cpsmidi midiratio
   ratiomidi dbamp ampdb octcps cpsoct log log2
   log10 sin cos tan asin acos atan sinh cosh tanh
   distort softclip rect-window han-window wel-window
   tri-window

*** Binary UGens
   + - * / mod = not= < > <= >= min max and or xor
   round round-up round-down atan2 hypot hypot-aprox
   pow ring1 ring2 ring3 ring4 difsqr sumsqr sqrsum
   sqrdif absdif thresh amclip scale-neg clip2 excess
   fold2 wrap2

*** B Equalization Suit UGens
   b-low-pass b-hi-pass b-all-pass b-band-pass
   b-band-stop b-peak-eq b-low-shelf b-hi-shelf

*** Buffer IO UGens                                             :buffer:io:

**** play-buf
#+BEGIN_SRC clojure :results output
(doc play-buf)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/play-buf
([num-channels bufnum rate trigger start-pos loop action])
  
  [num-channels :none, bufnum 0, rate 1.0, trigger 1.0, start-pos 0.0, loop 0.0, action 0]

  num-channels - The number of channels that the 
                 buffer will be. This must be a 
                 fixed integer. The architechture 
                 of the SynthDef cannot change 
                 after it is compiled. Warning: if 
                 you supply a bufnum of a buffer 
                 that has a different numChannels 
                 then you have specified to the 
                 play-buf, it will fail silently. 
  bufnum       - The index of the buffer to use. 
  rate         - 1.0 is the server's sample rate, 
                 2.0 is one octave up, 0.5 is one 
                 octave down -1.0 is backwards 
                 normal rate ... etc. 
                 Interpolation is cubic. Note: if 
                 the buffer's sample rate is 
                 different from the server's, you 
                 will need to multiply the desired 
                 playback rate by (file's rate / 
                 server's rate). The UGen 
                 (buf-rate-scale bufnum) returns 
                 this factor. 
  trigger      - A trigger causes a jump to the 
                 startPos. A trigger occurs when a 
                 signal changes from <= 0 to > 0. 
  start-pos    - Sample frame to start playback. 
  loop         - 1 means true, 0 means false. This 
                 is modulateable. 
  action       - An integer representing an action 
                 to be executed when the buffer is 
                 finished playing. This can be 
                 used to free the enclosing synth. 
                 Action is only evaluated if loop 
                 is 0 

  Plays back a sample resident in a buffer 

  Categories: Buffer
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** t-grains
#+BEGIN_SRC clojure :results output
(doc t-grains)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/t-grains
([num-channels trigger bufnum rate center-pos dur pan amp interp])
  
  [num-channels 2, trigger 0, bufnum 0, rate 1, center-pos 0, dur 0.1, pan 0.0, amp 0.1, interp 4]

  num-channels - Number of output channels 
  trigger      - At each trigger, the following 
                 arguments are sampled and used as 
                 the arguments of a new grain. A 
                 trigger occurs when a signal 
                 changes from <= 0 to > 0. If the 
                 trigger is audio rate then the 
                 grains will start with sample 
                 accuracy. 
  bufnum       - The index of the buffer to use. 
                 It must be a one channel (mono) 
                 buffer. 
  rate         - 1.0 is normal, 2.0 is one octave 
                 up, 0.5 is one octave down -1.0 
                 is backwards normal rate. Unlike 
                 PlayBuf, the rate is multiplied 
                 by BufRate, so you needn't do 
                 that yourself. 
  center-pos   - The position in the buffer in 
                 seconds at which the grain 
                 envelope will reach maximum 
                 amplitude. 
  dur          - Duration of the grain in seconds 
  pan          - A value from -1 to 1. Determines 
                 where to pan the output in the 
                 same manner as PanAz. 
  amp          - Amplitude of the grain. 
  interp       - 1,2,or 4. Determines whether the 
                 grain uses (1) no interpolation, 
                 (2) linear interpolation, or (4) 
                 cubic interpolation. 

  Sample playback from a buffer with fine control for doing 
  granular synthesis. Triggers generate grains from a single 
  channel (mono) buffer. Each grain has a Hann envelope 
  (sin^2(x) for x from 0 to pi) and is panned between two 
  channels of multiple outputs. 

  Categories: Buffer, Generators -> Granular
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** buf-rd
#+BEGIN_SRC clojure :results output
(doc buf-rd)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-rd
([num-channels bufnum phase loop interpolation])
  
  Read the contents of a buffer at a specified index 

  [num-channels 1, bufnum 0, phase 0.0, loop 1.0, interpolation 2]

  num-channels  - The number of channels of the 
                  supplied buffer. This must be a 
                  fixed integer and not a signal 
                  or a control proxy. The 
                  architecture of the synth design 
                  cannot change after it is 
                  compiled. (Warning: if you 
                  supply a bufnum of a buffer that 
                  has a different number of 
                  channels than you have specified 
                  to buf-rd , it will fail 
                  silently). 
  bufnum        - The index of the buffer to use 
  phase         - Audio rate modulatable index 
                  into the buffer. Warning: The 
                  phase argument only offers 
                  precision for addressing 2**24 
                  samples (about 6.3 minutes at 
                  44100Hz) 
  loop          - 1 means true, 0 means false. 
                  This is modulatable. 
  interpolation - 1 means no interpolation, 2 is 
                  linear, 4 is cubic interpolation 

  Reads the contents of a buffer at a given index. 

  Categories: Buffer
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** buf-wr
#+BEGIN_SRC clojure :results output
(doc buf-wr)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-wr
([input-array bufnum phase loop])
  
  [input-array :none, bufnum 0, phase 0.0, loop 1.0]

  input-array - Input ugens (channelArray) 
  bufnum      - The index of the buffer to use 
  phase       - Modulatable index into the buffer 
                (has to be audio rate). 
  loop        - 1 means true, 0 means false. This 
                is modulatable 

  Writes to a buffer at a given index. Note, buf-wr (in 
  difference to buf-rd) does not do multichannel expansion, 
  because input is an array. 

  Categories: Buffer
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** record-buf
#+BEGIN_SRC clojure :results output
(doc record-buf)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/record-buf
([input-array bufnum offset rec-level pre-level run loop trigger action])
  
  [input-array :none, bufnum 0, offset 0.0, rec-level 1.0, pre-level 0.0, run 1.0, loop 1.0, trigger 1.0, action 0]

  input-array - An Array of input channels 
  bufnum      - The index of the buffer to use 
  offset      - An offset into the buffer in 
                frames, 
  rec-level   - Value to multiply by input before 
                mixing with existing data. 
  pre-level   - Value to multiply to existing data 
                in buffer before mixing with input 
  run         - If zero, then recording stops, 
                otherwise recording proceeds. 
  loop        - If zero then don't loop, otherwise 
                do. This is modulate-able. 
  trigger     - A trigger causes a jump to the 
                offset position in the Buffer. A 
                trigger occurs when a signal 
                changes from <= 0 to > 0. 
  action      - An integer representing an action 
                to be executed when the buffer is 
                finished playing. This can be used 
                to free the enclosing synth. 
                Action is only evaluated if loop 
                is 0 

  Record a stream of values into a buffer. If recLevel is 
  1.0 and preLevel is 0.0 then the new input overwrites the 
  old data. If they are both 1.0 then the new data is added 
  to the existing data. (Any other settings are also valid.) 
  Note that the number of channels must be fixed for the 
  defsynth, it cannot vary depending on which buffer you 
  use. 

  Categories: Buffer
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** scope-out
#+BEGIN_SRC clojure :results output
(doc scope-out)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/scope-out
([input-array bufnum])
  
  [input-array :none, bufnum 0.0]

  input-array - - 
  bufnum      - A buffer or buffer index value. 

  No documentation has been defined for this ugen. 

  Categories: Buffer
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** local-buf
#+BEGIN_SRC clojure :results output
(doc local-buf)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/local-buf
([num-frames num-channels])
  
  Create a synth-local buffer. 

  [num-frames :none, num-channels 1]

  num-frames   - The number of frames the buffer 
                 should contain. 
  num-channels - The number of channels for the 
                 buffer. 

  A given local-buf may only be used within the synth it is 
  defined in. More efficient than using a standard buffer 

  Categories: Composite Ugen
  Rates: [ :ir ]
  Default rate: :ir
#+end_example

**** max-local-bufs
#+BEGIN_SRC clojure :results output
(doc max-local-bufs)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/max-local-bufs
([num-local-bufs])
  
  [num-local-bufs :none]

  num-local-bufs - - 

  No documentation has been defined for this ugen. 

  Categories: 
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** set-buf
#+BEGIN_SRC clojure :results output
(doc set-buf)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/set-buf
([buf values offset])
  
  [buf :none, values :none, offset 0]

  buf    - - 
  values - - 
  offset - - 

  No documentation has been defined for this ugen. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** clear-buf
#+BEGIN_SRC clojure :results output
(doc clear-buf)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/clear-buf
([buf])
  
  [buf :none]

  buf - - 

  No documentation has been defined for this ugen. 

  Categories: 
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

*** Chaos UGens
   quad-n quad-l quad-c cusp-n cusp-l gbman-n
   gbman-l henon-n henon-l henon-c latoocarfian-n
   latoocarfian-l latoocarfian-c lin-cong-n lin-cong-l
   lin-cong-c standard-n standard-l fb-sine-n
   fb-sine-l fb-sine-c lorenz-l

*** Compander
   amplitude compander normalizer limiter

*** Delay UGens

**** delay1
#+BEGIN_SRC clojure :results output
(doc delay1)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/delay1
([in])
  
  [in 0.0]

  in - Input to be delayed. 

  Delay input signal by one frame of samples. Note: for 
  audio-rate signals the delay is 1 audio frame, and for 
  control-rate signals the delay is 1 control period. 

  Categories: Delays
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** delay-n
#+BEGIN_SRC clojure :results output
(doc delay-n)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/delay-n
([in max-delay-time delay-time])
  
  [in 0.0, max-delay-time 0.2, delay-time 0.2]

  in             - The input signal 
  max-delay-time - The maximum delay time in 
                   seconds. Used to initialize the 
                   delay buffer size 
  delay-time     - Delay time in seconds 

  Simple delay line, no interpolation. See also DelayL which 
  uses linear interpolation, and DelayC which uses cubic 
  interpolation. Cubic interpolation is more computationally 
  expensive than linear, but more accurate. 

  Categories: Delays
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** delay-l
#+BEGIN_SRC clojure :results output
(doc delay-l)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/delay-l
([in max-delay-time delay-time])
  
  [in 0.0, max-delay-time 0.2, delay-time 0.2]

  in             - The input signal 
  max-delay-time - The maximum delay time in 
                   seconds. Used to initialize the 
                   delay buffer size 
  delay-time     - Delay time in seconds 

  Simple delay line, linear interpolation. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** delay-c
#+BEGIN_SRC clojure :results output
(doc delay-c)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/delay-c
([in max-delay-time delay-time])
  
  [in 0.0, max-delay-time 0.2, delay-time 0.2]

  in             - The input signal 
  max-delay-time - The maximum delay time in 
                   seconds. Used to initialize the 
                   delay buffer size 
  delay-time     - Delay time in seconds 

  Simple delay line, cubic interpolation. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** comb-n
#+BEGIN_SRC clojure :results output
(doc comb-n)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/comb-n
([in max-delay-time delay-time decay-time])
  
  [in 0.0, max-delay-time 0.2, delay-time 0.2, decay-time 1.0]

  in             - The input signal 
  max-delay-time - The maximum delay time in 
                   seconds. Used to initialize the 
                   delay buffer size 
  delay-time     - Delay time in seconds 
  decay-time     - Time for the echoes to decay by 
                   60 decibels. If this time is 
                   negative then the feedback 
                   coefficient will be negative, 
                   thus emphasizing only odd 
                   harmonics at an octave lower. 

  Comb delay line, no interpolation. See also CombL which 
  uses linear interpolation, and CombC which uses cubic 
  interpolation. Cubic interpolation is more computationally 
  expensive than linear, but more accurate. 

  Categories: Delays
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** comb-l
#+BEGIN_SRC clojure :results output
(doc comb-l)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/comb-l
([in max-delay-time delay-time decay-time])
  
  [in 0.0, max-delay-time 0.2, delay-time 0.2, decay-time 1.0]

  in             - The input signal 
  max-delay-time - The maximum delay time in 
                   seconds. Used to initialize the 
                   delay buffer size 
  delay-time     - Delay time in seconds 
  decay-time     - Time for the echoes to decay by 
                   60 decibels. If this time is 
                   negative then the feedback 
                   coefficient will be negative, 
                   thus emphasizing only odd 
                   harmonics at an octave lower. 

  Comb delay line, linear interpolation 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** comb-c
#+BEGIN_SRC clojure :results output
(doc comb-c)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/comb-c
([in max-delay-time delay-time decay-time])
  
  [in 0.0, max-delay-time 0.2, delay-time 0.2, decay-time 1.0]

  in             - The input signal 
  max-delay-time - The maximum delay time in 
                   seconds. Used to initialize the 
                   delay buffer size 
  delay-time     - Delay time in seconds 
  decay-time     - Time for the echoes to decay by 
                   60 decibels. If this time is 
                   negative then the feedback 
                   coefficient will be negative, 
                   thus emphasizing only odd 
                   harmonics at an octave lower. 

  Comb delay line, cubic interpolation 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** allpass-n
#+BEGIN_SRC clojure :results output
(doc allpass-n)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/allpass-n
([in max-delay-time delay-time decay-time])
  
  [in 0.0, max-delay-time 0.2, delay-time 0.2, decay-time 1.0]

  in             - The input signal 
  max-delay-time - The maximum delay time in 
                   seconds. Used to initialize the 
                   delay buffer size 
  delay-time     - Delay time in seconds 
  decay-time     - Time for the echoes to decay by 
                   60 decibels. If this time is 
                   negative then the feedback 
                   coefficient will be negative, 
                   thus emphasizing only odd 
                   harmonics at an octave lower. 

  All pass delay line, no interpolation. See also AllpassC 
  which uses cubic interpolation, and AllpassL which uses 
  linear interpolation. Cubic interpolation is more 
  computationally expensive than linear, but more accurate. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** allpass-l
#+BEGIN_SRC clojure :results output
(doc allpass-l)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/allpass-l
([in max-delay-time delay-time decay-time])
  
  [in 0.0, max-delay-time 0.2, delay-time 0.2, decay-time 1.0]

  in             - The input signal 
  max-delay-time - The maximum delay time in 
                   seconds. Used to initialize the 
                   delay buffer size 
  delay-time     - Delay time in seconds 
  decay-time     - Time for the echoes to decay by 
                   60 decibels. If this time is 
                   negative then the feedback 
                   coefficient will be negative, 
                   thus emphasizing only odd 
                   harmonics at an octave lower. 

  All pass delay line, linear interpolation 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** allpass-c
#+BEGIN_SRC clojure :results output
(doc allpass-c)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/allpass-c
([in max-delay-time delay-time decay-time])
  
  [in 0.0, max-delay-time 0.2, delay-time 0.2, decay-time 1.0]

  in             - The input signal 
  max-delay-time - The maximum delay time in 
                   seconds. Used to initialize the 
                   delay buffer size 
  delay-time     - Delay time in seconds 
  decay-time     - Time for the echoes to decay by 
                   60 decibels. If this time is 
                   negative then the feedback 
                   coefficient will be negative, 
                   thus emphasizing only odd 
                   harmonics at an octave lower. 

  All pass delay line, cubic interpolation 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** buf-delay-n
#+BEGIN_SRC clojure :results output
(doc buf-delay-n)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-delay-n
([buf in delay-time])
  
  [buf 0.0, in 0.0, delay-time 0.2]

  buf        - Buffer number 
  in         - The input signal 
  delay-time - Delay time in seconds 

  Buffer based simple delay line with no interpolation. See 
  also BufDelayL which uses linear interpolation, and 
  BufDelayC which uses cubic interpolation. Cubic 
  interpolation is more computationally expensive than 
  linear, but more accurate. 

  Categories: Delays
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** buf-delay-l
#+BEGIN_SRC clojure :results output
(doc buf-delay-l)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-delay-l
([buf in delay-time])
  
  [buf 0.0, in 0.0, delay-time 0.2]

  buf        - Buffer number 
  in         - The input signal 
  delay-time - Delay time in seconds 

  Buffer based simple delay line with linear interpolation 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** buf-delay-c
#+BEGIN_SRC clojure :results output
(doc buf-delay-c)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-delay-c
([buf in delay-time])
  
  [buf 0.0, in 0.0, delay-time 0.2]

  buf        - Buffer number 
  in         - The input signal 
  delay-time - Delay time in seconds 

  Buffer based simple delay line with cubic interpolation 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** buf-comb-n
#+BEGIN_SRC clojure :results output
(doc buf-comb-n)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-comb-n
([buf in delay-time decay-time])
  
  [buf 0, in 0.0, delay-time 0.2, decay-time 1.0]

  buf        - Buffer number 
  in         - The input signal 
  delay-time - Delay time in seconds 
  decay-time - Time for the echoes to decay by 60 
               decibels. If this time is negative 
               then the feedback coefficient will 
               be negative, thus emphasizing only 
               odd harmonics at an octave lower. 

  Buffer based comb delay line with no interpolation. See 
  also [BufCombL] which uses linear interpolation, and 
  BufCombC which uses cubic interpolation. Cubic 
  interpolation is more computationally expensive than 
  linear, but more accurate. 

  Categories: Delays
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** buf-comb-l
#+BEGIN_SRC clojure :results output
(doc buf-comb-l)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-comb-l
([buf in delay-time decay-time])
  
  [buf 0, in 0.0, delay-time 0.2, decay-time 1.0]

  buf        - Buffer number 
  in         - The input signal 
  delay-time - Delay time in seconds 
  decay-time - Time for the echoes to decay by 60 
               decibels. If this time is negative 
               then the feedback coefficient will 
               be negative, thus emphasizing only 
               odd harmonics at an octave lower. 

  Buffer based comb delay line with linear interpolation 

  Categories: 
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** buf-comb-c
#+BEGIN_SRC clojure :results output
(doc buf-comb-c)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-comb-c
([buf in delay-time decay-time])
  
  [buf 0, in 0.0, delay-time 0.2, decay-time 1.0]

  buf        - Buffer number 
  in         - The input signal 
  delay-time - Delay time in seconds 
  decay-time - Time for the echoes to decay by 60 
               decibels. If this time is negative 
               then the feedback coefficient will 
               be negative, thus emphasizing only 
               odd harmonics at an octave lower. 

  Buffer based comb delay line with cubic interpolation 

  Categories: 
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** buf-allpass-n
#+BEGIN_SRC clojure :results output
(doc buf-allpass-n)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-allpass-n
([buf in delay-time decay-time])
  
  [buf 0, in 0.0, delay-time 0.2, decay-time 1.0]

  buf        - Buffer number 
  in         - The input signal 
  delay-time - Delay time in seconds 
  decay-time - Time for the echoes to decay by 60 
               decibels. If this time is negative 
               then the feedback coefficient will 
               be negative, thus emphasizing only 
               odd harmonics at an octave lower. 

  Buffer based all pass delay line with no interpolation. 
  See also BufAllpassC which uses cubic interpolation, and 
  BufAllpassL which uses linear interpolation. Cubic 
  interpolation is more computationally expensive than 
  linear, but more accurate. 

  Categories: 
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** buf-allpass-l
#+BEGIN_SRC clojure :results output
(doc buf-allpass-l)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-allpass-l
([buf in delay-time decay-time])
  
  [buf 0, in 0.0, delay-time 0.2, decay-time 1.0]

  buf        - Buffer number 
  in         - The input signal 
  delay-time - Delay time in seconds 
  decay-time - Time for the echoes to decay by 60 
               decibels. If this time is negative 
               then the feedback coefficient will 
               be negative, thus emphasizing only 
               odd harmonics at an octave lower. 

  Buffer based all pass delay line with linear interpolation 

  Categories: 
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** buf-allpass-c
#+BEGIN_SRC clojure :results output
(doc buf-allpass-c)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-allpass-c
([buf in delay-time decay-time])
  
  [buf 0, in 0.0, delay-time 0.2, decay-time 1.0]

  buf        - Buffer number 
  in         - The input signal 
  delay-time - Delay time in seconds 
  decay-time - Time for the echoes to decay by 60 
               decibels. If this time is negative 
               then the feedback coefficient will 
               be negative, thus emphasizing only 
               odd harmonics at an octave lower. 

  Buffer based all pass delay line with cubic interpolation 

  Categories: 
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

*** Demand UGens
   demand duty t-duty demand-env-gen dseries dgeom
   dbufrd dbufwr dseq dser dshuf drand dxrand dswitch1
   dswitch dwhite dbrown dibrown dstutter donce dpoll

*** Envelope Ugens

**** done
done

**** free-self
free-self

**** pause-self
pause-self

**** free-self-when-done
free-self-when-done

**** pause-self-when-done
pause-self-when-done

**** pause
pause

**** free
free
**** env-gen
 #+BEGIN_SRC clojure :results output 
(doc env-gen)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/env-gen
 ([envelope gate level-scale level-bias time-scale action])

   [envelope :none, gate 1.0, level-scale 1.0, level-bias 0.0, time-scale 1.0, action 0]

   envelope    - An Array of Controls. 
   gate        - This triggers the envelope and 
                 holds it open while > 0. If the 
                 envelope is fixed-length (e.g. 
                 perc), the gate argument is used 
                 as a simple trigger. If it is an 
                 sustaining envelope (e.g. adsr, 
                 asr), the envelope is held open 
                 until the gate becomes 0, at which 
                 point is released. If the gate of 
                 an env-gen is set to -1 or below, 
                 then the envelope will cutoff 
                 immediately. The time for it to 
                 cutoff is the amount less than -1, 
                 with -1 being as fast as possible, 
                 -1.5 being a cutoff in 0.5 
                 seconds, etc. The cutoff shape is 
                 linear. 
   level-scale - Scales the levels of the 
                 breakpoints. 
   level-bias  - Offsets the levels of the 
                 breakpoints. 
   time-scale  - Scales the durations of the 
                 segments. 
   action      - An integer representing an action 
                 to be executed when the env is 
                 finished playing. This can be used 
                 to free the enclosing synth, etc. 

   Envelope generator, interpolates across a path of control 
   points over time, see the overtone.sc.envelope functions 
   to generate the control points array

   Note:

   The actual minimum duration of a segment is not zero, but 
   one sample step for audio rate and one block for control 
   rate. This may result in asynchronicity when in two 
   envelopes of different number of levels, the envelope 
   times add up to the same total duration. Similarly, when 
   modulating times, the new time is only updated at the end 
   of the current segment - this may lead to asynchronicity 
   of two envelopes with modulated times. 

   Categories: Envelopes
   Rates: [ :ar, :kr ]
   Default rate: :kr
#+end_example

**** linen
 #+BEGIN_SRC clojure :results output 
(doc linen)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/linen
 ([gate attack-time sus-level release-time action])

   [gate 1.0, attack-time 0.01, sus-level 1.0, release-time 1.0, action 0]

   gate         - Input trigger 
   attack-time  - Time taken to rise to susLevel in 
                  seconds 
   sus-level    - Level to hold the envelope at 
                  until gate is triggered 
   release-time - Time to fall from susLevel back 
                  to 0 after the gate has been 
                  triggered 
   action       - Done action 

   A linear envelope generator, rises to sus-level over 
   attack-time seconds and after the gate goes non-positive 
   falls over release-time to finally perform the (optional) 
   action 

   Categories: Envelopes
   Rates: [ :kr ]
   Default rate: :kr
#+end_example

**** i-env-gen
 #+BEGIN_SRC clojure :results output 
(doc i-env-gen)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/i-env-gen
 ([ienvelope index])

   [ienvelope :none, index :none]

   ienvelope - An InterplEnv (this is static for 
               the life of the UGen) 
   index     - A point to access within the 
               InterplEnv 

   Plays back break point envelopes from the index point. 

   Categories: Envelopes
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

*** Fixed Frequency Oscillator UGens
**** f-sin-osc
#+BEGIN_SRC clojure :results output
(doc f-sin-osc)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/f-sin-osc
([freq iphase])
  
  [freq 440.0, iphase 0.0]

  freq   - Frequency in Hertz 
  iphase - Phase offset or modulator in radians 

  Very fast sine wave generator (2 PowerPC instructions per 
  output sample!) implemented using a ringing filter. This 
  generates a much cleaner sine wave than a table lookup 
  oscillator and is a lot faster. However, the amplitude of 
  the wave will vary with frequency. Generally the amplitude 
  will go down as you raise the frequency and go up as you 
  lower the frequency.

  WARNING: In the current implementation, the amplitude can 
  blow up if the frequency is modulated by certain 
  alternating signals. 

  Categories: Generators -> Deterministic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example
**** klang
#+BEGIN_SRC clojure :results output
(doc klang)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/klang
([specs freqscale freqoffset])
  
  [specs :none, freqscale 1.0, freqoffset 0.0]

  specs      - An array of three arrays 
               frequencies, amplitudes and phases: 
               (1) an array of filter frequencies, 
               (2) an Array of filter amplitudes, 
               or nil. If nil, then amplitudes 
               default to 1.0, (3) an Array of 
               initial phases, or nil. If nil, 
               then phases default to 0.0. 
  freqscale  - A scale factor multiplied by all 
               frequencies at initialization time. 
  freqoffset - An offset added to all frequencies 
               at initialization time. 

  Klang is a bank of fixed frequency sine oscillators. Klang 
  is more efficient than creating individual oscillators but 
  offers less flexibility.

  The specs can't be changed after it has been started. For 
  a modulatable but less efficient version, see dyn-klang. 

  Categories: Generators -> Deterministic, Filters -> Linear
  Rates: [ :ar ]
  Default rate: :ar
#+end_example
**** klank
#+BEGIN_SRC clojure :results output
(doc klank)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/klank
([specs input freqscale freqoffset decayscale])
  
  [specs :none, input :none, freqscale 1.0, freqoffset 0.0, decayscale 1.0]

  specs      - An array of three arrays: 
               frequencies, amplitudes and ring 
               times: *all arrays should have the 
               same length* (1) an Array of filter 
               frequencies. (2) an Array of filter 
               amplitudes, or nil. If nil, then 
               amplitudes default to 1.0 (3) an 
               Array of 60 dB decay times for the 
               filters. 
  input      - The excitation input to the 
               resonant filter bank. 
  freqscale  - A scale factor multiplied by all 
               frequencies at initialization time. 
  freqoffset - An offset added to all frequencies 
               at initialization time. 
  decayscale - A scale factor multiplied by all 
               ring times at initialization time. 

  Klank is a bank of fixed frequency resonators which can be 
  used to simulate the resonant modes of an object. Each 
  mode is given a ring time, which is the time for the mode 
  to decay by 60 dB.

  The specs can't be changed after it has been started. For 
  a modulatable but less efficient version, see dyn-klank. 

  Categories: Generators -> Deterministic, Filters -> Linear
  Rates: [ :ar ]
  Default rate: :ar
#+end_example
**** blip
#+BEGIN_SRC clojure :results output
(doc blip)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/blip
([freq numharm])
  
  [freq 440.0, numharm 200.0]

  freq    - Frequency in Hertz (control rate) 
  numharm - Number of harmonics. This may be 
            lowered internally if it would cause 
            aliasing. 

  Band Limited Impulse generator. All harmonics have equal 
  amplitude. This is the equivalent of buzz in MusicN 
  languages. WARNING: This waveform in its raw form could be 
  damaging to your ears at high amplitudes or for long 
  periods.

  It is improved from other implementations in that it will 
  crossfade in a control period when the number of harmonics 
  changes, so that there are no audible pops. It also 
  eliminates the divide in the formula by using a 1/sin 
  table (with special precautions taken for 1/0). The lookup 
  tables are linearly interpolated for better quality.

  Synth-O-Matic (1990) had an impulse generator called blip, 
  hence that name here rather than 'buzz'. 

  Categories: Generators -> Deterministic
  Rates: [ :ar ]
  Default rate: :ar
#+end_example
**** saw
#+BEGIN_SRC clojure :results output
(doc saw)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/saw
([freq])
  
  band limited sawtooth wave generator 

  [freq 440.0]

  freq - Frequency in Hertz (control rate). 

  The sawtooth wave produces even and odd harmonics in 
  series and therefore produces a bright sound that is an 
  excellent starting point for brassy, raspy sounds. It's 
  also suitable for creating the gritty, bright sounds 
  needed for leads and raspy basses. Due to its harmonic 
  richness it's extremely suitable for use with sounds that 
  will be filter swept. 

  Categories: Generators -> Deterministic
  Rates: [ :ar ]
  Default rate: :ar
#+end_example
**** pulse
#+BEGIN_SRC clojure :results output
(doc pulse)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/pulse
([freq width])
  
  band limited pulse wave generator with pulse width 
  modulation. 

  [freq 440.0, width 0.5]

  freq  - Frequency in Hertz (control rate) 
  width - Pulse width ratio from zero to one. 0.5 
          makes a square wave (control rate) 

  Pulse waves are a general form of square wave that allow 
  for the width of the pulses to be varied. A square wave is 
  therefore a pulse with a width of 0.5 i.e. the width of 
  the high and low states is identical.

  Adjusting the ratio of the pulse width will vary the 
  harmonic content of the sound. For example, reductions in 
  the width allow you to produce thin reed-like timbres 
  along with the wide, hollow sounds created by a square 
  wave. 

  Categories: Generators -> Deterministic
  Rates: [ :ar ]
  Default rate: :ar
#+end_example
**** p-sin-grain
#+BEGIN_SRC clojure :results output
(doc p-sin-grain)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/p-sin-grain
([freq dur amp])
  
  [freq 440.0, dur 0.2, amp 1.0]

  freq - Frequency in cycles per second. Must be a 
         scalar 
  dur  - Grain duration 
  amp  - Amplitude of grain 

  Fixed frequency sine oscillator this ugen uses a very fast 
  algorithm for generating a sine wave at a fixed frequency 

  Categories: Generators -> Deterministic
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

*** FFT UGens
   fft ifft pv-mag-above pv-mag-below pv-mag-clip
   pv-local-max pv-mag-smear pv-bin-shift pv-mag-shift
   pv-mag-squared pv-mag-noise pv-phase-shift90
   pv-phase-shift270 pv-conj pv-phase-shift
   pv-brick-wall pv-bin-wipe pv-mag-mul pv-copy-phase
   pv-copy pv-max pv-min pv-mul pv-div pv-add
   pv-mag-div pv-rand-comb pv-rect-comb pv-rect-comb2
   pv-rand-wipe pv-diffuser pv-mag-freeze
   pv-bin-scramble fft-trigger
   Extra FFT UGens
   pv-conformal-map convolution convolution2
   convolution2-l stereo-convolution2-l convolution3
   pv-jenson-andersen pv-hainsworth-foote running-sum

*** Filter UGens
   resonz one-pole one-zero two-pole two-zero apf
   integrator decay decay2 lag lag2 lag3 ramp lag-ud
   lag2-ud lag3-ud leak-dc rlpf rhpf hpf bpf brf
   mid-eq lpz1 lpz2 hpz1 hpz2 slope bpz2 median slew
   sos ringz formlet detect-silence

*** Grain UGens
   grain-sin grain-in warp1

*** Information UGens
**** sample-rate
#+BEGIN_SRC clojure :results output
(doc sample-rate)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/sample-rate
([])
  
  []


  Returns the current sample rate 

  Categories: 
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** sample-dur
#+BEGIN_SRC clojure :results output
(doc sample-dur)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/sample-dur
([])
  
  []


  Returns the current sample duration of the server in 
  seconds 

  Categories: 
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** radians-per-sample
#+BEGIN_SRC clojure :results output
(doc radians-per-sample)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/radians-per-sample
([])
  
  []


   

  Categories: 
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** control-rate
#+BEGIN_SRC clojure :results output
(doc control-rate)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/control-rate
([])
  
  []


  Returns the current control rate of the server 

  Categories: 
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** control-dur
#+BEGIN_SRC clojure :results output
(doc control-dur)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/control-dur
([])
  
  []


  Returns the current control rate block duration of the 
  server in seconds 

  Categories: 
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** subsample-offset
#+BEGIN_SRC clojure :results output
(doc subsample-offset)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/subsample-offset
([])
  
  []


  Offset from synth start within one sample 

  Categories: 
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** [#C] num-output-busses
#+BEGIN_SRC clojure :results output
(doc num-output-busses)
#+END_SRC

#+RESULTS:

**** num-input-busses
#+BEGIN_SRC clojure :results output
(doc num-input-busses)
#+END_SRC

#+RESULTS:

**** num-audio-busses
#+BEGIN_SRC clojure :results output
(doc num-audio-busses)
#+END_SRC

#+RESULTS:

**** num-control-busses
#+BEGIN_SRC clojure :results output
(doc num-control-busses)
#+END_SRC

#+RESULTS:

**** num-buffers
#+BEGIN_SRC clojure :results output
(doc num-buffers)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/num-buffers
([])
  
  []


  Returns the number of buffers allocated on the server 

  Categories: 
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** num-running-synths
#+BEGIN_SRC clojure :results output
(doc num-running-synths)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/num-running-synths
([])
  
  []


  Returns the number of currently running synths 

  Categories: 
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** buf-sample-rate
#+BEGIN_SRC clojure :results output
(doc buf-sample-rate)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-sample-rate
([buf])
  
  [buf 0]

  buf - A buffer 

  Returns the buffers current sample rate 

  Categories: 
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** buf-rate-scale
#+BEGIN_SRC clojure :results output
(doc buf-rate-scale)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-rate-scale
([buf])
  
  [buf 0]

  buf - A buffer 

  Returns a ratio by which the playback of a buffer is to be 
  scaled 

  Categories: 
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** buf-frames
#+BEGIN_SRC clojure :results output
(doc buf-frames)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-frames
([buf])
  
  [buf 0]

  buf - A buffer 

  Returns the current number of allocated frames i.e. the 
  size of the buffer. This is the equivalent of Clojure's 
  count on a seq. 

  Categories: 
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** buf-samples
#+BEGIN_SRC clojure :results output
(doc buf-samples)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-samples
([buf])
  
  [buf 0]

  buf - A buffer 

  Current number of samples allocated in the buffer 

  Categories: 
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** buf-dur
#+BEGIN_SRC clojure :results output
(doc buf-dur)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-dur
([buf])
  
  [buf 0]

  buf - A buffer 

  Returns the current duration of a buffer in seconds. 

  Categories: 
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** buf-channels
#+BEGIN_SRC clojure :results output
(doc buf-channels)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/buf-channels
([buf])
  
  [buf 0]

  buf - A buffer 

  Current number of channels of soundfile in buffer 

  Categories: 
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** check-bad-values
#+BEGIN_SRC clojure :results output
(doc check-bad-values)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/check-bad-values
([in id post])
  
  [in :none, id 0, post 2]

  in   - The UGen whose output is to be tested 
  id   - An id number to identify this UGen. 
  post - One of three post modes: 0 = no posting; 
         1 = post a line for every bad value; 2 = 
         post a line only when the floating-point 
         classification changes (e.g., normal -> 
         NaN and vice versa) 

  Test for infinity, not-a-number, and denormals. If one of 
  these is found, it posts a warning. Its output is as 
  follows: 0 = a normal float, 1 = NaN, 2 = infinity, and 3 
  = a denormal. 

  Categories: Info
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** poll
#+BEGIN_SRC clojure :results output
(doc poll)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/poll
([trig in label])
  
  Print current value of ugen 

  [trig :none, in 1, label polled-val]

  trig  - A non-positive to positive transition 
          telling Poll to return a value 
  in    - The signal you want to poll 
  label - A string or symbol to be printed with 
          the polled value 

  Print the current output value of a ugen. Does this via 
  OSC communication, therefore there's no need for a trig-id 
  arg - see send-trig or send-reply for more capable 
  alternatives. 

  Categories: Composite Ugen
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

*** Input UGens
**** mouse-x
#+BEGIN_SRC clojure :results output
(doc mouse-x)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/mouse-x
([min max warp lag])
  
  [min 0.0, max 1.0, warp 0, lag 0.2]

  min  - Minimum value (when mouse is at the left 
         of the screen) 
  max  - Maximum value (when mouse is at the right 
         of the screen) 
  warp - Mapping curve - either LINEAR or 
         EXPONENTIAL (LIN and EXP abbreviations 
         are allowed). Default is LINEAR. 
  lag  - Lag factor to dezipper cursor movement. 

  Maps the current mouse X coordinate to a value between min 
  and max 

  Categories: User interaction
  Rates: [ :kr ]
  Default rate: :kr
#+end_example

**** mouse-y
#+BEGIN_SRC clojure :results output
(doc mouse-y)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/mouse-y
([min max warp lag])
  
  [min 0.0, max 1.0, warp 0, lag 0.2]

  min  - Minimum value (when mouse is at the top 
         of the screen) 
  max  - Maximum value (when mouse is at the 
         bottom of the screen) 
  warp - Mapping curve - either LINEAR or 
         EXPONENTIAL (LIN and EXP abbreviations 
         are allowed). Default is LINEAR 
  lag  - Lag factor to smooth out cursor movement. 

  Maps the current mouse Y coordinate to a value between min 
  and max 

  Categories: 
  Rates: [ :kr ]
  Default rate: :kr
#+end_example

**** mouse-button
#+BEGIN_SRC clojure :results output
(doc mouse-button)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/mouse-button
([up down lag])
  
  [up 0.0, down 1.0, lag 0.2]

  up   - Value when the key is not pressed 
  down - Value when the key is pressed 
  lag  - Lag factor 

  Toggles between two values when the left mouse button is 
  up or down 

  Categories: User interaction
  Rates: [ :kr ]
  Default rate: :kr
#+end_example

**** key-state
#+BEGIN_SRC clojure :results output
(doc key-state)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/key-state
([keycode minval maxval lag])
  
  [keycode 0.0, minval 0.0, maxval 1.0, lag 0.2]

  keycode - The keycode value of the key to check. 
  minval  - The value to output when the key is 
            not pressed. 
  maxval  - The value to output when the key is 
            pressed. 
  lag     - Lag factor 

  Toggles between two values when a key on the keyboard is 
  up or down. Note that this ugen does not prevent normal 
  typing. 

  Categories: User interaction
  Rates: [ :kr ]
  Default rate: :kr
#+end_example

*** IO UGens
disk-out
disk-in
v-disk-in
in
local-in
lag-in
in-feedback
in-trig
shared-in
out
replace-out
offset-out
local-out
x-out
shared-out

*** Line Ugens

**** line
#+BEGIN_SRC clojure :results output
(doc line)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/line
([start end dur action])
  
  Line generator. 

  [start 0.0, end 1.0, dur 1.0, action 0]

  start  - Starting value 
  end    - Ending value 
  dur    - Duration in seconds 
  action - A done action to be evaluated when the 
           line is completed. Default: NO-ACTION 

  Generates a line from the start value to the end value. 

  Categories: Envelopes
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** x-line
#+BEGIN_SRC clojure :results output
(doc x-line)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/x-line
([start end dur action])
  
  Exponential line generator. 

  [start 1.0, end 2.0, dur 1.0, action 0]

  start  - Starting value 
  end    - Ending value 
  dur    - Duration in seconds 
  action - A done action to be evaluated when the 
           line is completed. Default: NO-ACTION 

  Generates an exponential curve from the start value to the 
  end value. Both the start and end values must be non-zero 
  and have the same sign. 

  Categories: Envelopes
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** lin-exp
#+BEGIN_SRC clojure :results output
(doc lin-exp)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lin-exp
([in srclo srchi dstlo dsthi])
  
  Map a linear range to an exponential range 

  [in 0.0, srclo 0.0, srchi 1.0, dstlo 1.0, dsthi 2.0]

  in    - Input to convert 
  srclo - Lower limit of input range 
  srchi - Upper limit of input range 
  dstlo - Lower limit of output range 
  dsthi - Upper limit of output range 

  Convert from a linear range to an exponential range. The 
  dstlo and dsthi arguments must be nonzero and have the 
  same sign. 

  Categories: Maths
  Rates: [ :ar, :kr ]
  Default rate: :auto
#+end_example

**** lin-lin
#+BEGIN_SRC clojure :results output
(doc lin-lin)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lin-lin
([in srclo srchi dstlo dsthi])
  
  Map values from one linear range to another 

  [in 0.0, srclo 0.0, srchi 1.0, dstlo 1.0, dsthi 2.0]

  in    - Input to convert 
  srclo - Lower limit of input range 
  srchi - Upper limit of input range 
  dstlo - Lower limit of output range 
  dsthi - Upper limit of output range 

   

  Categories: Composite Ugen
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** amp-comp
#+BEGIN_SRC clojure :results output
(doc amp-comp)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/amp-comp
([freq root exp])
  
  Basic psychoacoustic amplitude compensation. 

  [freq 261.6256, root 261.6256, exp 0.3333]

  freq - Input frequency value. For freq == root, 
         the output is 1.0. 
  root - Root freq relative to which the curve is 
         calculated (usually lowest freq) 
  exp  - Exponent: how steep the curve decreases 
         for increasing freq 

  Amplitude compensation: because higher frequencies are 
  normally perceived as louder. Note that for frequencies 
  very much smaller than root the amplitudes can become very 
  high. In this case limit the freqor use amp-comp-a

  Implements the (optimized) formula:

  compensationFactor = (root / freq) ** exp 

  Categories: Analysis -> Amplitude
  Rates: [ :ir, :ar, :kr ]
  Default rate: :auto
#+end_example

**** amp-comp-a
#+BEGIN_SRC clojure :results output
(doc amp-comp-a)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/amp-comp-a
([freq root min-amp root-amp])
  
  Basic psychoacoustic amplitude compensation (ANSI 
  A-weighting curve). 

  [freq 1000.0, root 0, min-amp 0.32, root-amp 1.0]

  freq     - Input frequency value. For freq == 
             root, the output is root-amp 
  root     - Root freq relative to which the curve 
             is calculated (usually lowest freq) 
  min-amp  - Amplitude at the minimum point of the 
             curve (around 2512 Hz) 
  root-amp - Amplitude at the root frequency. 

  Higher frequencies are normally perceived as louder, which 
  amp-comp-a compensates. Following the measurings by 
  Fletcher and Munson, the ANSI standard describes a 
  function for loudness vs. frequency. Note that this curve 
  is only valid for standardized amplitude. 1 For a simpler 
  but more flexible curve, see amp-comp 

  Categories: Analysis -> Amplitude
  Rates: [ :ir, :ar, :kr ]
  Default rate: :auto
#+end_example

**** k2a
#+BEGIN_SRC clojure :results output
(doc k2a)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/k2a
([in])
  
  [in 0.0]

  in - Input signal 

  Control rate to audio rate converter via linear 
  interpolation. 

  Categories: Conversion
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** a2k
#+BEGIN_SRC clojure :results output
(doc a2k)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/a2k
([in])
  
  [in 0.0]

  in - Input signal 

  Audio rate to control rate converter via linear 
  interpolation 

  Categories: Conversion
  Rates: [ :kr ]
  Default rate: :kr
#+end_example

**** t2k
#+BEGIN_SRC clojure :results output
(doc t2k)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/t2k
([in])
  
  [in 0.0]

  in - Input signal 

  Audio rate trigger to control rate trigger converter. Uses 
  the maxiumum trigger in the input during each control 
  period. 

  Categories: Conversion
  Rates: [ :kr ]
  Default rate: :kr
#+end_example

**** t2a
#+BEGIN_SRC clojure :results output
(doc t2a)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/t2a
([in offset])
  
  [in 0.0, offset 0]

  in     - Input signal 
  offset - Sample offset within control period 

  Control rate trigger to audio rate trigger converter 
  (maximally one per control period). 

  Categories: Conversion
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** dc
#+BEGIN_SRC clojure :results output
(doc dc)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/dc
([in])
  
  [in :none]

  in - Constant value to output, cannot be 
       modulated, set at initialisation time 

  Outputs the initial value you give it. 

  Categories: Generators -> Single-value
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** silent
#+BEGIN_SRC clojure :results output
(doc silent)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/silent
([num-channels])
  
  [num-channels 1]

  num-channels - Number of channels of silence. 

  Continuously outputs 0 

  Categories: Generators -> Single-value
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

*** Machine Listening UGens
   beat-track loudness onsets key-track mfcc
   beat-track2 spec-flatness spec-pcile spec-centroid

*** Miscellaneous UGens

**** pitch-shift
#+BEGIN_SRC clojure :results output
(doc pitch-shift)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/pitch-shift
([in window-size pitch-ratio pitch-dispersion time-dispersion])
  
  [in :none, window-size 0.2, pitch-ratio 1.0, pitch-dispersion 0.0, time-dispersion 0.0]

  in               - The input signal. 
  window-size      - The size of the grain window 
                     in seconds. This value cannot 
                     be modulated. 
  pitch-ratio      - The ratio of the pitch shift. 
                     Must be from 0.0 to 4.0 
  pitch-dispersion - The maximum random deviation 
                     of the pitch from the 
                     pitchRatio. 
  time-dispersion  - A random offset of from zero 
                     to timeDispersion seconds is 
                     added to the delay of each 
                     grain. Use of some dispersion 
                     can alleviate a hard comb 
                     filter effect due to uniform 
                     grain placement. It can also 
                     be an effect in itself. 
                     timeDispersion can be no 
                     larger than windowSize. 

  A time domain granular pitch shifter. Grains have a 
  triangular amplitude envelope and an overlap of 4:1. 

  Categories: Filters -> Pitch
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** pluck
#+BEGIN_SRC clojure :results output
(doc pluck)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/pluck
([in trig maxdelaytime delaytime decaytime coef])
  
  [in 0.0, trig 1.0, maxdelaytime 0.2, delaytime 0.2, decaytime 1.0, coef 0.5]

  in           - An excitation signal. 
  trig         - Upon a negative to positive 
                 transition, the excitation signal 
                 will be fed into the delay line. 
  maxdelaytime - The max delay time in seconds 
                 (initializes the internal delay 
                 buffer). 
  delaytime    - Delay time in seconds. 
  decaytime    - Time for the echoes to decay by 
                 60 decibels. Negative times 
                 emphasize odd partials. 
  coef         - The coef of the internal OnePole 
                 filter. Values should be between 
                 -1 and +1 (larger values will be 
                 unstable... so be careful!). 

  Implements the Karplus-Strong style of synthesis, where a 
  delay line (normally starting with noise) is filtered and 
  fed back on itself so that over time it becomes periodic. 

  Categories: Generators -> Deterministic
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** part-conv
#+BEGIN_SRC clojure :results output
(doc part-conv)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/part-conv
([in fftsize irbufnum])
  
  [in :none, fftsize :none, irbufnum :none]

  in       - Processing target. 
  fftsize  - Spectral convolution partition size 
             (twice partition size). You must 
             ensure that the blocksize divides the 
             partition size and there are at least 
             two blocks per partition (to allow 
             for amortisation) 
  irbufnum - Prepared buffer of spectra for each 
             partition of the inpulse response 

  Partitioned convolution. Various additional buffers must 
  be supplied. Mono impulse response only! If inputting 
  multiple channels, you'll need independent PartConvs, one 
  for each channel. But the charm is: impulse response can 
  be as large as you like (CPU load increases with IR size. 
  Various tradeoffs based on fftsize choice, due to rarer 
  but larger FFTs. This plug-in uses amortisation to spread 
  processing and avoid spikes). Normalisation factors 
  difficult to anticipate; convolution piles up multiple 
  copies of the input on top of itself, so can easily 
  overload. 

  Categories: 
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** hilbert
#+BEGIN_SRC clojure :results output
(doc hilbert)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/hilbert
([in])
  
  [in :none]

  in - The input signal 

  No documentation has been defined for this ugen. 

  Categories: Filters -> Nonlinear
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** freq-shift
#+BEGIN_SRC clojure :results output
(doc freq-shift)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/freq-shift
([in freq phase])
  
  [in :none, freq 0.0, phase 0.0]

  in    - The signal to process 
  freq  - Amount of shift in cycles per second 
  phase - Phase of the frequency shift (0 - 2pi) 

  FreqShift implements single sideband amplitude modulation, 
  also known as frequency shifting, but not to be confused 
  with pitch shifting. Frequency shifting moves all the 
  components of a signal by a fixed amount but does not 
  preserve the original harmonic relationships. 

  Categories: Filters -> Nonlinear, Filters -> Pitch
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** g-verb                                                       :reverb:
#+BEGIN_SRC clojure :results output
(doc g-verb)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/g-verb
([in roomsize revtime damping inputbw spread drylevel earlyreflevel taillevel maxroomsize])
  
  [in :none, roomsize 10.0, revtime 3.0, damping 0.5, inputbw 0.5, spread 15.0, drylevel 1.0, earlyreflevel 0.7, taillevel 0.5, maxroomsize 300.0]

  in            - Mono input 
  roomsize      - In squared meters. 
  revtime       - In seconds 
  damping       - 0 to 1, high frequency rolloff, 
                  0 damps the reverb signal 
                  completely, 1 not at all 
  inputbw       - 0 to 1, same as damping control, 
                  but on the input signal 
  spread        - A control on the stereo spread 
                  and diffusion of the reverb 
                  signal 
  drylevel      - Amount of dry signal 
  earlyreflevel - Amount of early reflection level 
  taillevel     - Amount of tail level 
  maxroomsize   - To set the size of the delay 
                  lines. 

  A two-channel reverb UGen, based on the "GVerb" LADSPA 
  effect by Juhana Sadeharju (kouhia at nic.funet.fi).

  WARNING - in the current version of the server, there are 
  severe noise issues when you attempt to modify the 
  roomsize or set it to a value greater than 40. 

  Categories: Reverbs
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** free-verb                                                    :reverb:
#+BEGIN_SRC clojure :results output
(doc free-verb)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/free-verb
([in mix room damp])
  
  [in :none, mix 0.33, room 0.5, damp 0.5]

  in   - The input signal 
  mix  - Dry/wet balance. range 0..1 
  room - Room size. rage 0..1 
  damp - Reverb HF damp. range 0..1 

  A reverb coded from experiments with faust. Valid 
  parameter range from 0 to 1. Values outside this range are 
  clipped by the UGen. 

  Categories: Reverbs
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** free-verb2                                                   :reverb:
#+BEGIN_SRC clojure :results output
(doc free-verb2)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/free-verb2
([in in2 mix room damp])
  
  [in :none, in2 :none, mix 0.33, room 0.5, damp 0.5]

  in   - Input signal channel 1 
  in2  - Input signal channel 2 
  mix  - Dry/wet balance. range 0..1 
  room - Room size. rage 0..1 
  damp - Reverb HF damp. range 0..1 

  A two-channel reverb coded from experiments with faust. 
  Valid parameter range from 0 to 1. Values outside this 
  range are clipped by the UGen. 

  Categories: Reverbs
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** moog-ff
#+BEGIN_SRC clojure :results output
(doc moog-ff)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/moog-ff
([in freq gain reset])
  
  [in 0.0, freq 100.0, gain 2.0, reset 0.0]

  in    - The input signal 
  freq  - The cutoff frequency 
  gain  - The filter resonance gain, between zero 
          and 4 
  reset - When greater than zero, this will reset 
          the state of the digital filters at the 
          beginning of a computational block. 

  A digital implementation of the Moog VCF (filter). 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** spring
#+BEGIN_SRC clojure :results output
(doc spring)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/spring
([in spring damp])
  
  [in 0.0, spring 0.0, damp 0.0]

  in     - Modulated input force 
  spring - Spring constant (incl. mass) 
  damp   - Damping 

  Physical model of resonating spring 

  Categories: Filters -> Nonlinear
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** ball
#+BEGIN_SRC clojure :results output
(doc ball)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/ball
([in g damp friction])
  
  [in 0.0, g 1.0, damp 0.0, friction 0.01]

  in       - Modulated surface level 
  g        - Gravity 
  damp     - Damping on impact 
  friction - Proximity from which on attraction to 
             surface starts 

  Models the path of a bouncing object that is reflected by 
  a vibrating surface 

  Categories: Filters -> Nonlinear
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** t-ball
#+BEGIN_SRC clojure :results output
(doc t-ball)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/t-ball
([in g damp friction])
  
  [in 0.0, g 10.0, damp 0.0, friction 0.01]

  in       - Modulated surface level 
  g        - Gravity 
  damp     - Damping on impact 
  friction - Proximity from which on attraction to 
             surface starts 

  Models the impacts of a bouncing object that is reflected 
  by a vibrating surface 

  Categories: Filters -> Nonlinear
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** check-bad-values
#+BEGIN_SRC clojure :results output
(doc check-bad-values)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/check-bad-values
([in id post])
  
  [in :none, id 0, post 2]

  in   - The UGen whose output is to be tested 
  id   - An id number to identify this UGen. 
  post - One of three post modes: 0 = no posting; 
         1 = post a line for every bad value; 2 = 
         post a line only when the floating-point 
         classification changes (e.g., normal -> 
         NaN and vice versa) 

  Test for infinity, not-a-number, and denormals. If one of 
  these is found, it posts a warning. Its output is as 
  follows: 0 = a normal float, 1 = NaN, 2 = infinity, and 3 
  = a denormal. 

  Categories: Info
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** gendy1
#+BEGIN_SRC clojure :results output
(doc gendy1)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/gendy1
([ampdist durdist adparam ddparam minfreq maxfreq ampscale durscale init-cps knum])
  
  [ampdist 1.0, durdist 1.0, adparam 1.0, ddparam 1.0, minfreq 440.0, maxfreq 660.0, ampscale 0.5, durscale 0.5, init-cps 12, knum 12]

  ampdist  - Choice of probability distribution 
             for the next perturbation of the 
             amplitude of a control point. The 
             distributions are (adapted from the 
             GENDYN program in Formalized Music): 
             0- LINEAR,1- CAUCHY, 2- LOGIST, 3- 
             HYPERBCOS, 4- ARCSINE, 5- EXPON, 6- 
             SINUS, Where the sinus (Xenakis' 
             name) is in this implementation taken 
             as sampling from a third party 
             oscillator. See example below. 
  durdist  - Choice of distribution for the 
             perturbation of the current inter 
             control point duration. 
  adparam  - A parameter for the shape of the 
             amplitude probability distribution, 
             requires values in the range 0.0001 
             to 1 (there are safety checks in the 
             code so don't worry too much if you 
             want to modulate!) 
  ddparam  - A parameter for the shape of the 
             duration probability distribution, 
             requires values in the range 0.0001 
             to 1 
  minfreq  - Minimum allowed frequency of 
             oscillation for the Gendy1 
             oscillator, so gives the largest 
             period the duration is allowed to 
             take on. 
  maxfreq  - Maximum allowed frequency of 
             oscillation for the Gendy1 
             oscillator, so gives the smallest 
             period the duration is allowed to 
             take on. 
  ampscale - Normally 0.0 to 1.0, multiplier for 
             the distribution's delta value for 
             amplitude. An ampscale of 1.0 allows 
             the full range of -1 to 1 for a 
             change of amplitude. 
  durscale - Normally 0.0 to 1.0, multiplier for 
             the distribution's delta value for 
             duration. An ampscale of 1.0 allows 
             the full range of -1 to 1 for a 
             change of duration. 
  init-cps - Initialise the number of control 
             points in the memory. Xenakis 
             specifies 12. There would be this 
             number of control points per cycle of 
             the oscillator, though the 
             oscillator's period will constantly 
             change due to the duration 
             distribution. 
  knum     - Current number of utilised control 
             points, allows modulation. 

  An implementation of the dynamic stochastic synthesis 
  generator conceived by Iannis Xenakis and described in 
  Formalized Music (1992, Stuyvesant, NY: Pendragon Press) 
  chapter 9 (pp 246-254) and chapters 13 and 14 (pp 
  289-322). The BASIC program in the book was written by 
  Marie-Helene Serra so I think it helpful to credit her 
  too. The program code has been adapted to avoid infinities 
  in the probability distribution functions. The 
  distributions are hard-coded in C but there is an option 
  to have new amplitude or time breakpoints sampled from a 
  continuous controller input. 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** gendy2
#+BEGIN_SRC clojure :results output
(doc gendy2)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/gendy2
([ampdist durdist adparam ddparam minfreq maxfreq ampscale durscale init-cps knum a c])
  
  [ampdist 1.0, durdist 1.0, adparam 1.0, ddparam 1.0, minfreq 440.0, maxfreq 660.0, ampscale 0.5, durscale 0.5, init-cps 12, knum 12, a 1.17, c 0.31]

  ampdist  - Choice of probability distribution 
             for the next perturbation of the 
             amplitude of a control point. The 
             distributions are (adapted from the 
             GENDYN program in Formalized Music): 
             0- LINEAR, 1- CAUCHY, 2- LOGIST, 3- 
             HYPERBCOS, 4- ARCSINE, 5- EXPON, 6- 
             SINUS, Where the sinus (Xenakis' 
             name) is in this implementation taken 
             as sampling from a third party 
             oscillator. 
  durdist  - Choice of distribution for the 
             perturbation of the current inter 
             control point duration. 
  adparam  - A parameter for the shape of the 
             amplitude probability distribution, 
             requires values in the range 0.0001 
             to 1 (there are safety checks in the 
             code so don't worry too much if you 
             want to modulate!) 
  ddparam  - A parameter for the shape of the 
             duration probability distribution, 
             requires values in the range 0.0001 
             to 1 
  minfreq  - Minimum allowed frequency of 
             oscillation for the Gendy1 
             oscillator, so gives the largest 
             period the duration is allowed to 
             take on. 
  maxfreq  - Maximum allowed frequency of 
             oscillation for the Gendy1 
             oscillator, so gives the smallest 
             period the duration is allowed to 
             take on. 
  ampscale - Normally 0.0 to 1.0, multiplier for 
             the distribution's delta value for 
             amplitude. An ampscale of 1.0 allows 
             the full range of -1 to 1 for a 
             change of amplitude. 
  durscale - Normally 0.0 to 1.0, multiplier for 
             the distribution's delta value for 
             duration. An ampscale of 1.0 allows 
             the full range of -1 to 1 for a 
             change of duration. 
  init-cps - Initialise the number of control 
             points in the memory. Xenakis 
             specifies 12. There would be this 
             number of control points per cycle of 
             the oscillator, though the 
             oscillator's period will constantly 
             change due to the duration 
             distribution. 
  knum     - Current number of utilised control 
             points, allows modulation. 
  a        - Parameter for Lehmer random number 
             generator perturbed by Xenakis as in 
             ((old*a)+c)%1.0 
  c        - Parameter for Lehmer random number 
             generator perturbed by Xenakis 

  See gendy1 help file for background. This variant of 
  GENDYN is closer to that presented in Hoffmann, Peter. 
  (2000) The New GENDYN Program. Computer Music Journal 
  24:2, pp 31-38. 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** gendy3
#+BEGIN_SRC clojure :results output
(doc gendy3)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/gendy3
([ampdist durdist adparam ddparam freq ampscale durscale init-cps knum])
  
  [ampdist 1.0, durdist 1.0, adparam 1.0, ddparam 1.0, freq 440.0, ampscale 0.5, durscale 0.5, init-cps 12, knum 12]

  ampdist  - Choice of probability distribution 
             for the next perturbation of the 
             amplitude of a control point. The 
             distributions are (adapted from the 
             GENDYN program in Formalized Music): 
             0- LINEAR,1- CAUCHY, 2- LOGIST, 3- 
             HYPERBCOS, 4- ARCSINE, 5- EXPON, 6- 
             SINUS, Where the sinus (Xenakis' 
             name) is in this implementation taken 
             as sampling from a third party 
             oscillator. 
  durdist  - Choice of distribution for the 
             perturbation of the current inter 
             control point duration. 
  adparam  - A parameter for the shape of the 
             amplitude probability distribution, 
             requires values in the range 0.0001 
             to 1 (there are safety checks in the 
             code so don't worry too much if you 
             want to modulate!) 
  ddparam  - A parameter for the shape of the 
             duration probability distribution, 
             requires values in the range 0.0001 
             to 1 
  freq     - Oscillation frquency. 
  ampscale - Normally 0.0 to 1.0, multiplier for 
             the distribution's delta value for 
             amplitude. An ampscale of 1.0 allows 
             the full range of -1 to 1 for a 
             change of amplitude. 
  durscale - Normally 0.0 to 1.0, multiplier for 
             the distribution's delta value for 
             duration. An ampscale of 1.0 allows 
             the full range of -1 to 1 for a 
             change of duration. 
  init-cps - Initialise the number of control 
             points in the memory. Xenakis 
             specifies 12. There would be this 
             number of control points per cycle of 
             the oscillator, though the 
             oscillator's period will constantly 
             change due to the duration 
             distribution. 
  knum     - Current number of utilised control 
             points, allows modulation. 

  See Gendy1 help file for background. This variant of 
  GENDYN normalises the durations in each period to force 
  oscillation at the desired pitch. The breakpoints still 
  get perturbed as in Gendy1. There is some glitching in the 
  oscillator caused by the stochastic effects: control 
  points as they vary cause big local jumps of amplitude. 
  Put ampscale and durscale low to minimise this. All 
  parameters can be modulated at control rate except for 
  initCPs which is used only at initialisation. 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

*** Noise UGens                                                   :noise:

**** white-noise
#+BEGIN_SRC clojure :results output
(doc white-noise)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/white-noise
([])
  
  Noise whose spectrum has equal power at all frequencies. 

  []


  Noise that contains equal amounts of energy at every 
  frequency - comparable to radio static.

  Useful for generating percussive sounds such as snares and 
  hand claps. Also useful for simulating wind or sea 
  effects, for producing breath effects in wind instrument 
  timbres or for producing the typical trance leads. 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** brown-noise
#+BEGIN_SRC clojure :results output
(doc brown-noise)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/brown-noise
([])
  
  Noise whose spectrum falls off in power by 6 dB per 
  octave. 

  []


  Useful for generating percussive sounds such as snares and 
  hand claps. Also useful for simulating wind or sea 
  effects, for producing breath effects in wind instrument 
  timbres or for producing the typical trance leads. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** pink-noise
#+BEGIN_SRC clojure :results output
(doc pink-noise)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/pink-noise
([])
  
  Noise whose spectrum falls off in power by 3 dB per 
  octave. 

  []


  Noise that gives equal power over the span of each 
  octave.

  Useful for generating percussive sounds such as snares and 
  hand claps. Also useful for simulating wind or sea 
  effects, for producing breath effects in wind instrument 
  timbres or for producing the typical trance leads.

  This version gives 8 octaves of pink noise. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** clip-noise
#+BEGIN_SRC clojure :results output
(doc clip-noise)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/clip-noise
([])
  
  Noise whose values are either -1 or 1. 

  []


  This produces the maximum energy for the least peak to 
  peak amplitude.

  Useful for generating percussive sounds such as snares and 
  hand claps. Also useful for simulating wind or sea 
  effects, for producing breath effects in wind instrument 
  timbres or for producing the typical trance leads. 

  Categories: 
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** gray-noise
#+BEGIN_SRC clojure :results output
(doc gray-noise)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/gray-noise
([])
  
  Random impulses from -1 to +1 given a density 

  []


  Given a density (average number of impulses per second) 
  creates a sequence of random impulses from -1 to +1.

  Useful for generating percussive sounds such as snares and 
  hand claps. Also useful for simulating wind or sea 
  effects, for producing breath effects in wind instrument 
  timbres or for producing the typical trance leads. 

  Categories: 
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** crackle
#+BEGIN_SRC clojure :results output
(doc crackle)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/crackle
([chaos-param])
  
  Chaotic noise generator 

  [chaos-param 1.5]

  chaos-param - A parameter of the chaotic 
                function with useful values from 
                just below 1.0 to just above 2.0. 
                Towards 2.0 the sound crackles. 

  A noise generator based on a chaotic function.

  Useful for generating percussive sounds such as snares and 
  hand claps. Also useful for simulating wind or sea 
  effects, for producing breath effects in wind instrument 
  timbres or for producing the typical trance leads. 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** logistic
#+BEGIN_SRC clojure :results output
(doc logistic)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/logistic
([chaos-param freq init])
  
  [chaos-param 3.0, freq 1000.0, init 0.5]

  chaos-param - A parameter of the chaotic 
                function with useful values from 
                0.0 to 4.0. Chaos occurs from 3.57 
                up. Don't use values outside this 
                range if you don't want the UGen 
                to blow up. 
  freq        - Frequency of calculation; if over 
                the sampling rate, this is clamped 
                to the sampling rate 
  init        - Initial value of y (see equation 
                below) 

  A noise generator based on the logistic map:

  y = chaos-param * y * (1.0 - y)

  y will stay in the range of 0.0 to 1.0 for normal values 
  of the chaos-param. This leads to a DC offset and may 
  cause a pop when you stop the Synth. For output you might 
  want to combine this UGen with a LeakDC or rescale around 
  0.0 via mul and add: see example below. 

  Categories: Generators -> Chaotic
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** lf-noise0
#+BEGIN_SRC clojure :results output
(doc lf-noise0)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lf-noise0
([freq])
  
  [freq 500.0]

  freq - Approximate rate at which to generate 
         random values. 

  Generates random values between -1 and 1 at a rate (the 
  rate is not guaranteed but approximate) 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** lf-noise1
#+BEGIN_SRC clojure :results output
(doc lf-noise1)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lf-noise1
([freq])
  
  [freq 500.0]

  freq - Approximate rate at which to generate 
         random values. 

  Generates linearly interpolated random values between -1 
  and 1 at the supplied rate (the rate is not guaranteed but 
  approximate). 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** lf-noise2
#+BEGIN_SRC clojure :results output
(doc lf-noise2)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lf-noise2
([freq])
  
  [freq 500.0]

  freq - Approximate rate at which to generate 
         random values. 

  Generates quadratically interpolated random values between 
  -1 and 1 at the supplied rate (the rate is not guaranteed 
  but approximate).

  Note: quadratic interpolation means that the noise values 
  can occasionally extend beyond the normal range of +-1, if 
  the freq varies in certain ways. If this is undesirable 
  then you might like to clip2 the values or use a 
  linearly-interpolating unit instead. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** lf-clip-noise
#+BEGIN_SRC clojure :results output
(doc lf-clip-noise)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lf-clip-noise
([freq])
  
  [freq 500.0]

  freq - Approximate rate at which to generate 
         random values. 

  Randomly generates the values -1 or +1 at a rate given by 
  the nearest integer division of the sample rate by the 
  freq argument. It is probably pretty hard on your 
  speakers! 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** lfd-noise0
#+BEGIN_SRC clojure :results output
(doc lfd-noise0)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lfd-noise0
([freq])
  
  [freq 500.0]

  freq - Rate at which to generate random values. 

  Like lf-noise0, it generates random values between -1 and 
  1 at a rate given by the freq argument, with two 
  differences: p * no time quantization

  * fast recovery from low freq values.

  (lf-noise0,1,2 quantize to the nearest integer division of 
  the samplerate and they poll the freq argument only when 
  scheduled, and thus seem to hang when freqs get very 
  low).

  If you don't need very high or very low freqs, or use 
  fixed freqs lf-noise0 is more efficient. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** lfd-noise1
#+BEGIN_SRC clojure :results output
(doc lfd-noise1)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lfd-noise1
([freq])
  
  [freq 500.0]

  freq - Rate at which to generate random values. 

  Like lf-noise1, it generates linearly interpolated random 
  values between -1 and 1 at a rate given by the freq 
  argument, with two differences:

  * no time quantization

  * fast recovery from low freq values.

  (lf-noise0,1,2 quantize to the nearest integer division of 
  the samplerate and they poll the freq argument only when 
  scheduled, and thus seem to hang when freqs get very 
  low).

  If you don't need very high or very low freqs, or use 
  fixed freqs lf-noise1 is more efficient. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** lfd-noise3
#+BEGIN_SRC clojure :results output
(doc lfd-noise3)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lfd-noise3
([freq])
  
  [freq 500.0]

  freq - Rate at which to generate random values. 

  Similar to lf-noise2, it generates polynomially 
  interpolated random values between -1 and 1 at a rate 
  given by the freq argument, with 3 differences:

  * no time quantization

  * fast recovery from low freq values

  * cubic instead of quadratic interpolation

  (lf-noise0,1,2 quantize to the nearest integer division of 
  the samplerate and they poll the freq argument only when 
  scheduled, and thus seem to hang when freqs get very low). 
  If you don't need very high or very low freqs, or use 
  fixed freqs lf-noise2 is more efficient. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

ldf-clip-noise

**** hasher
#+BEGIN_SRC clojure :results output
(doc hasher)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/hasher
([in])
  
  [in 0.0]

  in - Input signal 

  Returns a unique output value from zero to one for each 
  input value according to a hash function. The same input 
  value will always produce the same output value. The input 
  need not be from zero to one. 

  Categories: Filters -> Nonlinear
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** mantissa-mask
#+BEGIN_SRC clojure :results output
(doc mantissa-mask)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/mantissa-mask
([in bits])
  
  [in 0.0, bits 3]

  in   - Input signal 
  bits - The number of mantissa bits to preserve. 
         a number from 0 to 23. 

  Masks off bits in the mantissa of the floating point 
  sample value. This introduces a quantization noise, but is 
  less severe than linearly quantizing the signal. 

  Categories: Filters -> Nonlinear
  Rates: [ :ar ]
  Default rate: :ar
#+end_example

**** dust
#+BEGIN_SRC clojure :results output
(doc dust)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/dust
([density])
  
  [density 0.0]

  density - Average number of impulses per second 

  Generates random impulses from 0 to +1. 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** dust2
#+BEGIN_SRC clojure :results output
(doc dust2)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/dust2
([density])
  
  [density 0.0]

  density - Average number of impulses per second. 

  Generates random impulses from -1 to +1. 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

*** [#A] Oscillator UGens
****  osc
 #+BEGIN_SRC clojure :results output 
(doc osc)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/osc
 ([buffer freq phase])

   [buffer :none, freq 440.0, phase 0.0]

   buffer - Lookup buffer 
   freq   - Frequency in Hertz 
   phase  - Phase offset or modulator in radians 

   Linear interpolating wavetable lookup oscillator with 
   frequency and phase modulation inputs.

   This oscillator requires a buffer to be filled with a 
   wavetable format signal. This preprocesses the Signal into 
   a form which can be used efficiently by the Oscillator. 
   The buffer size must be a power of 2.

   This can be achieved by creating a Buffer object and 
   sending it one of the b_gen messages (sine1, sine2, sine3) 
   with the wavetable flag set to true.

   This can also be achieved by creating a Signal object and 
   sending it the 'asWavetable' message, saving it to disk, 
   and having the server load it from there. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  sin-osc
 #+BEGIN_SRC clojure :results output 
(doc sin-osc)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/sin-osc
 ([freq phase mul add])

   Sine table lookup oscillator 

   [freq 440.0, phase 0.0, mul 1, add 0]

   freq  - Frequency in Hertz 
   phase - Phase offset or modulator in radians 
   mul   - Output will be multiplied by this value. 
   add   - This value will be added to the output. 

   Outputs a sine wave with values oscillating between -1 and 
   1 similar to osc except that the table has already been 
   fixed as a sine table of 8192 entries.

   Sine waves are often used for creating sub-basses or are 
   mixed with other waveforms to add extra body or bottom end 
   to a sound. They contain no harmonics and consist entirely 
   of the fundamental frequency. This means that they're not 
   suitable for subtractive synthesis i.e. passing through 
   filters such as a hpf or lpf. However, they are useful for 
   additive synthesis i.e. adding multiple sine waves 
   together at different frequencies, amplitudes and phase to 
   create new timbres. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  sin-osc-fb
 #+BEGIN_SRC clojure :results output 
(doc sin-osc-fb)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/sin-osc-fb
 ([freq feedback])

   Sine oscillator with phase modulation feedback 

   [freq 440.0, feedback 0.0]

   freq     - Frequency of oscillator 
   feedback - Amplitude of phase feedback in 
              radians 

   Different feedback values results in a modulation between 
   a sine wave and a sawtooth like wave. Overmodulation 
   causes chaotic oscillation. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  osc-n
 #+BEGIN_SRC clojure :results output 
(doc osc-n)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/osc-n
 ([bufnum freq phase])

   [bufnum :none, freq 440.0, phase 0.0]

   bufnum - Buffer index. The buffer size must be a 
            power of 2. The buffer should NOT be 
            filled using Wavetable format (b_gen 
            commands should set wavetable flag to 
            false). Raw signals (not converted with 
            asWavetable) can be saved to disk and 
            loaded into the buffer. 
   freq   - Frequency in Hertz 
   phase  - Phase offset or modulator in radians 

   Noninterpolating wavetable lookup oscillator with 
   frequency and phase modulation inputs.

   It is usually better to use the interpolating oscillator. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  v-osc
 #+BEGIN_SRC clojure :results output 
(doc v-osc)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/v-osc
 ([bufpos freq phase])

   [bufpos :none, freq 440.0, phase 0.0]

   bufpos - Buffer index. Can be swept continuously 
            among adjacent wavetable buffers of the 
            same size. 
   freq   - Frequency in Hertz 
   phase  - Phase offset of modulator in radians 

   A wavetable lookup oscillator which can be swept smoothly 
   across wavetables. All the wavetables must be allocated to 
   the same size. Fractional values of table will interpolate 
   between two adjacent tables.

   This oscillator requires at least two buffers to be filled 
   with a wavetable format signal. This preprocesses the 
   Signal into a form which can be used efficiently by the 
   Oscillator. The buffer size must be a power of 2. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  v-osc3
 #+BEGIN_SRC clojure :results output 
(doc v-osc3)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/v-osc3
 ([bufpos freq1 freq2 freq3])

   [bufpos :none, freq1 110.0, freq2 220.0, freq3 440.0]

   bufpos - Buffer index. Can be swept continuously 
            among adjacent wavetable buffers of the 
            same size. 
   freq1  - Frequency in Hertz of first oscillator 
   freq2  - Frequency in Hertz of second oscillator 
   freq3  - Frequency in Hertz of third oscillator 

   Three variable wavetable oscillators.

   A wavetable lookup oscillator which can be swept smoothly 
   across wavetables. All the wavetables must be allocated to 
   the same size. Fractional values of table will interpolate 
   between two adjacent tables. This unit generator contains 
   three oscillators at different frequencies, mixed 
   together.

   This oscillator requires at least two buffers to be filled 
   with a wavetable format signal. This preprocesses the 
   Signal into a form which can be used efficiently by the 
   Oscillator. The buffer size must be a power of 2. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  c-osc
 #+BEGIN_SRC clojure :results output 
(doc c-osc)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/c-osc
 ([bufnum freq beats])

   [bufnum :none, freq 440.0, beats 0.5]

   bufnum - The number of a buffer filled in 
            wavetable format 
   freq   - Frequency in Hertz 
   beats  - Beat frequency in Hertz 

   Chorusing wavetable lookup oscillator. Produces sum of two 
   signals at (freq +/- (beats / 2)). Due to summing, the 
   peak amplitude is twice that of the wavetable. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example


****  formant
 #+BEGIN_SRC clojure :results output 
(doc formant)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/formant
 ([fundfreq formfreq bwfreq])

   [fundfreq 440.0, formfreq 1760.0, bwfreq 880.0]

   fundfreq - Fundamental frequency in Hertz 
              (control rate) 
   formfreq - Formant frequency in Hertz (control 
              rate) 
   bwfreq   - Pulse width frequency in Hertz. 
              Controls the bandwidth of the formant 
              (control rate) 

   Generates a set of harmonics around a formant frequency at 
   a given fundamental frequency.

   The frequency inputs are read at control rate only, so if 
   you use an audio rate UGen as an input, it will only be 
   sampled at the start of each audio synthesis block. 

   Categories: Generators -> Deterministic
   Rates: [ :ar ]
   Default rate: :ar
#+end_example


****  lf-saw
 #+BEGIN_SRC clojure :results output 
(doc lf-saw)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/lf-saw
 ([freq iphase])

   [freq 440.0, iphase 0.0]

   freq   - Frequency in Hertz 
   iphase - Initial phase offset. For efficiency 
            reasons this is a value ranging from 0 
            to 2. 

   Low freq (i.e. not band limited) sawtooth oscillator 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  lf-par
 #+BEGIN_SRC clojure :results output 
(doc lf-par)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/lf-par
 ([freq iphase])

   [freq 440.0, iphase 0.0]

   freq   - Frequency in Hertz 
   iphase - Initial phase offset. For efficiency 
            reasons this is a value ranging from 0 
            to 2. 

   A non band-limited parabolic oscillator outputing a high 
   of 1 and a low of zero. 

   Categories: 
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  lf-cub
 #+BEGIN_SRC clojure :results output 
(doc lf-cub)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/lf-cub
 ([freq iphase])

   [freq 440.0, iphase 0.0]

   freq   - Frequency in Hertz 
   iphase - Initial phase offset. For efficiency 
            reasons this is a value ranging from 0 
            to 2. 

   An oscillator outputting a sine like shape made of two 
   cubic pieces 

   Categories: 
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  lf-tri
 #+BEGIN_SRC clojure :results output 
(doc lf-tri)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/lf-tri
 ([freq iphase])

   a non-band-limited triangle oscillator 

   [freq 440.0, iphase 0.0]

   freq   - Frequency in Hertz 
   iphase - Initial phase offset. For efficiency 
            reasons this is a value ranging from 0 
            to 2. 

   The triangle wave shape features two linear slopes and is 
   not as harmonically rich as a sawtooth wave since it only 
   contains odd harmonics (partials). Ideally, this type of 
   wave form is mixed with a sine, square or pulse wave to 
   add a sparkling or bright effect to a sound and is often 
   employed on pads to give them a glittery feel. 

   Categories: 
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  lf-gauss
 #+BEGIN_SRC clojure :results output 
(doc lf-gauss)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/lf-gauss
 ([duration width iphase loop action])

   [duration 1, width 0.1, iphase 0.0, loop 1, action 0]

   duration - Duration of one full cycle ( for freq 
              input: dur = 1 / freq ) 
   width    - Relative width of the bell. Best to 
              keep below 0.25 when used as 
              envelope. 
   iphase   - Initial offset 
   loop     - If loop is > 0, UGen oscillates. 
              Otherwise it calls the done action 
              after one cycle 
   action   - Action to be evaluated after cycle 
              completes. Default: NO-ACTION. 

   A non-band-limited gaussian function oscillator. Output 
   ranges from minval to 1.

   LFGauss implements the formula: f(x) = exp(squared(x - 
   iphase) / (-2.0 * squared(width))) where x is to vary in 
   the range -1 to 1 over the period dur. minval is the 
   initial value at -1 

   Categories: 
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  lf-pulse
 #+BEGIN_SRC clojure :results output 
(doc   lf-pulse)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/lf-pulse
 ([freq iphase width])

   [freq 440.0, iphase 0.0, width 0.5]

   freq   - Frequency in Hertz 
   iphase - Initial phase offset in cycles ( 0..1 ) 
   width  - Pulse width duty cycle from zero to one 

   A non-band-limited pulse oscillator. Outputs a high value 
   of one and a low value of zero. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :kr
#+end_example

****  var-saw
 #+BEGIN_SRC clojure :results output 
(doc var-saw)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/var-saw
 ([freq iphase width])

   [freq 440.0, iphase 0.0, width 0.5]

   freq   - Frequency in Hertz 
   iphase - Initial phase offset in cycles ( 0..1 ) 
   width  - Duty cycle from zero to one. (0 = 
            downward sawtooth, 0.5 = triangle, 1 = 
            upward sawtooth) 

   A variable duty cycle saw wave oscillator 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  impulse
 #+BEGIN_SRC clojure :results output 
(doc impulse)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/impulse
 ([freq phase])

   [freq 440.0, phase 0.0]

   freq  - Frequency in Hertz 
   phase - Phase offset in cycles ( 0..1 ) 

   Non band limited impulse oscillator. Outputs a single 1 
   every freq cycles per second and 0 the rest of the time. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :kr
#+end_example

****  sync-saw
 #+BEGIN_SRC clojure :results output 
(doc sync-saw)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/sync-saw
 ([sync-freq saw-freq])

   hard sync sawtooth wave oscillator 

   [sync-freq 440.0, saw-freq 440.0]

   sync-freq - Frequency of the fundamental. 
   saw-freq  - Frequency of the slave synched 
               sawtooth wave. saw-freq should 
               always be greater than sync-freq. 

   A sawtooth wave that is hard synched to a fundamental 
   pitch. This produces an effect similar to moving formants 
   or pulse width modulation. The sawtooth oscillator has its 
   phase reset when the sync oscillator completes a cycle. 
   This is not a band limited waveform, so it may alias. 

   Categories: Generators -> Deterministic
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  wrap-index
 #+BEGIN_SRC clojure :results output 
(doc wrap-index)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/wrap-index
 ([bufnum in])

   [bufnum :none, in 0.0]

   bufnum - A buffer or buffer index value. 
   in     - The input signal 

   The input signal value is truncated to an integer value 
   and used as an index into the table (out of range index 
   values are wrapped) 

   Categories: 
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****    index-in-between
 #+BEGIN_SRC clojure :results output 
(doc   index-in-between)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/index-in-between
 ([bufnum in])

   [bufnum :none, in 0.0]

   bufnum - A buffer or buffer index value. 
   in     - The input signal 

   Finds the (lowest) point in the buffer at which the input 
   signal lies in-between the two values, and returns the 
   index 

   Categories: 
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  detect-index
 #+BEGIN_SRC clojure :results output 
(doc detect-index)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/detect-index
 ([bufnum in])

   [bufnum :none, in 0.0]

   bufnum - A buffer or buffer index value. 
   in     - The input signal 

   Search a buffer for a value 

   Categories: 
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  shaper
 #+BEGIN_SRC clojure :results output 
(doc shaper)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/shaper
 ([bufnum in])

   [bufnum :none, in 0.0]

   bufnum - A buffer or buffer index value. 
   in     - The input signal 

   Performs waveshaping on the input signal by indexing into 
   a table 

   Categories: 
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  degree-to-key
 #+BEGIN_SRC clojure :results output 
(doc degree-to-key)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/degree-to-key
 ([bufnum in octave])

   [bufnum :none, in 0.0, octave 12.0]

   bufnum - Index of the buffer which contains the 
            steps for each scale degree. 
   in     - The input signal. 
   octave - The number of steps per octave in the 
            scale. The default is 12. 

   The input signal value is truncated to an integer value 
   and used as an index into an octave repeating table of 
   note values (indices wrap around the table) 

   Categories: Conversion
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****    select
 #+BEGIN_SRC clojure :results output 
(doc   select)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/select
 ([which array])

   [which :none, array :none]

   which - Index of array to select 
   array - List of ugens to choose from 

   Select the output signal from an array of inputs 

   Categories: Multichannel -> Select
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  vibrato
 #+BEGIN_SRC clojure :results output 
(doc vibrato)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/vibrato
 ([freq rate depth delay onset rate-variation depth-variation iphase])

   Models a slow frequency modulation. 

   [freq 440.0, rate 6, depth 0.02, delay 0.0, onset 0.0, rate-variation 0.04, depth-variation 0.1, iphase 0.0]

   freq            - Fundamental frequency in 
                     Hertz. If the Vibrato UGen is 
                     running at audio rate, this 
                     must not be a constant, but an 
                     actual audio rate UGen 
   rate            - Vibrato rate, speed of wobble 
                     in Hertz. Note that if this is 
                     set to a low value (and 
                     definitely with 0.0), you may 
                     never get vibrato back, since 
                     the rate input is only checked 
                     at the end of a cycle. 
   depth           - Size of vibrato frequency 
                     deviation around the 
                     fundamental, as a proportion 
                     of the fundamental. 0.02 = 2% 
                     of the fundamental. 
   delay           - Delay before vibrato is 
                     established in seconds (a 
                     singer tends to attack a note 
                     and then stabilise with 
                     vibrato, for instance). 
   onset           - Transition time in seconds 
                     from no vibrato to full 
                     vibrato after the initial 
                     delay time. 
   rate-variation  - Noise on the rate, expressed 
                     as a proportion of the rate; 
                     can change once per cycle of 
                     vibrato. 
   depth-variation - Noise on the depth of 
                     modulation, expressed as a 
                     proportion of the depth; can 
                     change once per cycle of 
                     vibrato. The noise affects 
                     independently the up and the 
                     down part of vibrato shape 
                     within a cycle. 
   iphase          - Initial phase of vibrato 
                     modulation, allowing starting 
                     above or below the fundamental 
                     rather than on it. 

   Vibrato is a slow frequency modulation. Consider the 
   systematic deviation in pitch of a singer around a 
   fundamental frequency, or a violinist whose finger wobbles 
   in position on the fingerboard, slightly tightening and 
   loosening the string to add shimmer to the pitch. There is 
   often also a delay before vibrato is established on a 
   note. This UGen models these processes; by setting more 
   extreme settings, you can get back to the timbres of FM 
   synthesis. You can also add in some noise to the vibrato 
   rate and vibrato size (modulation depth) to make for a 
   more realistic motor pattern. The vibrato output is a 
   waveform based on a squared envelope shape with four 
   stages marking out 0.0 to 1.0, 1.0 to 0.0, 0.0 to -1.0, 
   and -1.0 back to 0.0. Vibrato rate determines how quickly 
   you move through these stages. 

   Categories: 
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

****  index
 #+BEGIN_SRC clojure :results output 
(doc index)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 -------------------------
 overtone.live/index
 ([bufnum in])

   [bufnum :none, in 0.0]

   bufnum - A buffer or buffer index value. 
   in     - The input signal 

   The input signal value is truncated to an integer and used 
   as an index into the table 

   Categories: Buffer
   Rates: [ :ar, :kr ]
   Default rate: :ar
#+end_example

*** Pan UGens
   pan2 lin-pan2 pan4 balance2 rotate2 pan-b pan-b2
   bi-pan-b2 decode-b2 pan-az x-fade2 lin-x-fade2

*** Random UGens                                                   :random:
**** rand-seed
#+BEGIN_SRC clojure :results output
(doc rand-seed)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/rand-seed
([trig seed])
  
  [trig 0.0, seed 56789]

  trig - Trigger signal 
  seed - Seed value 

  When the trigger signal changes from nonpositive to 
  positive, the synth's random generator seed is reset to 
  the given value. All synths that use the same random 
  number generator reproduce the same sequence of numbers 
  again. 

  Categories: Generators -> Stochastic
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** rand-id
#+BEGIN_SRC clojure :results output
(doc rand-id)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/rand-id
([seed])
  
  [seed 0]

  seed - Seed id 

  Choose which random number generator to use for this 
  synth. All synths that use the same generator reproduce 
  the same sequence of numbers when the same seed is set 
  again. 

  Categories: Generators -> Stochastic
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** i-rand
#+BEGIN_SRC clojure :results output
(doc i-rand)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/i-rand
([lo hi])
  
  [lo 0.0, hi 127.0]

  lo - Minimum value of generated integer 
  hi - Maximum value of generated integer 

  Generates a single random integer value in uniform 
  distribution from lo to hi 

  Categories: Generators -> Stochastic, Generators -> Single-value
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** t-rand
#+BEGIN_SRC clojure :results output
(doc t-rand)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/t-rand
([lo hi trig])
  
  [lo 0.0, hi 1.0, trig 0.0]

  lo   - Minimum value of generated float 
  hi   - Maximum value of generated float 
  trig - Trigger signal 

  Generates a random float value in uniform distribution 
  from lo to hi each time the trig signal changes from 
  nonpositive to positive values 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** ti-rand
#+BEGIN_SRC clojure :results output
(doc ti-rand)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/ti-rand
([lo hi trig])
  
  [lo 0, hi 127, trig 0.0]

  lo   - Minimum value of generated integer 
  hi   - Maximum value of generated integer 
  trig - Trigger signal 

  Generates a random integer value in uniform distribution 
  from lo to hi each time the trig signal changes from 
  nonpositive to positive values 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** n-rand
#+BEGIN_SRC clojure :results output
(doc n-rand)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/n-rand
([lo hi n])
  
  [lo 0.0, hi 1.0, n 0]

  lo - Minimum value of generated float 
  hi - Maximum value of generated float 
  n  - Distribution choice 

  Generates a single random float value in a sum of n 
  uniform distributions from lo to hi.

  n = 1 : uniform distribution - same as Rand

  n = 2 : triangular distribution

  n = 3 : smooth hump

  As n increases, distribution converges towards gaussian 

  Categories: Generators -> Stochastic, Generators -> Single-value
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** exp-rand
#+BEGIN_SRC clojure :results output
(doc exp-rand)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/exp-rand
([lo hi])
  
  [lo 0.01, hi 1.0]

  lo - Minimum value of generated float 
  hi - Maximum value of generated float 

  Generates a single random float value in an exponential 
  distributions from lo to hi. 

  Categories: Generators -> Stochastic, Generators -> Single-value
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

**** t-exp-rand
#+BEGIN_SRC clojure :results output
(doc t-exp-rand)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/t-exp-rand
([lo hi trig])
  
  [lo 0.01, hi 1.0, trig 0.0]

  lo   - Minimum value of generated float 
  hi   - Maximum value of generated float 
  trig - Trigger signal 

  Generates a random float value in exponential distribution 
  from lo to hi each time the trig signal changes from 
  nonpositive to positive values lo and hi must both have 
  the same sign and be non-zero. 

  Categories: Generators -> Stochastic
  Rates: [ :ar, :kr ]
  Default rate: :ar
#+end_example

**** coin-gate
#+BEGIN_SRC clojure :results output
(doc coin-gate)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/coin-gate
([prob trig])
  
  [prob :none, trig :none]

  prob - Value between 0 and 1 determines 
         probability of either possibilities 
  trig - Trigger signal 

  When it receives a trigger, it tosses a coin, and either 
  passes the trigger or doesn't. 

  Categories: Generators -> Stochastic
  Rates: [ :ir, :kr ]
  Default rate: :auto
#+end_example

**** lin-rand
#+BEGIN_SRC clojure :results output
(doc lin-rand)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/lin-rand
([lo hi minmax])
  
  [lo 0.0, hi 1.0, minmax 0]

  lo     - Minimum value of generated float 
  hi     - Maximum value of generated float 
  minmax - Skew direction (towards lo if negative 
           otherwise hi) 

  Generates a single random float value in linear 
  distribution from lo to hi, skewed towards lo if minmax < 
  0, otherwise skewed towards hi. 

  Categories: Generators -> Stochastic, Generators -> Single-value
  Rates: [ :ir ]
  Default rate: :auto
#+end_example

*** STK UGens
   stk-pluck stk-flute stk-bowed stk-mandolin
   stk-saxofony stk-shakers stk-banded-wg
   stk-voic-form stk-modal-bar stk-clarinet
   stk-blow-hole stk-moog stk-bee-three

*** Trig UGens

**** tw-index
#+BEGIN_SRC clojure :results output
(doc tw-index)
#+END_SRC

#+RESULTS:


**** trig1
#+BEGIN_SRC clojure :results output
(doc trig1)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/trig1
([trig dur])
  
  Timed trigger 

  [trig 0.0, dur 0.1]

  trig - Trigger. Trigger can be any signal. A 
         trigger happens when the signal changes 
         from non-positive to positive. 
  dur  - Duration of the trigger output in 
         seconds. 

  Outputs one for dur seconds whenever the input goes from 
  negative to positive, otherwise outputs 0. 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** trig
#+BEGIN_SRC clojure :results output
(doc trig)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/trig
([trig dur])
  
  Timed trigger 

  [trig 0.0, dur 0.1]

  trig - Trigger. Trigger can be any signal. A 
         trigger happens when the signal changes 
         from non-positive to positive. 
  dur  - Duration of the trigger output in 
         seconds. 

  When a nonpositive to positive transition occurs at the 
  input, Trig outputs the level of the triggering input for 
  the specified duration, otherwise it outputs zero. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** t-delay
#+BEGIN_SRC clojure :results output
(doc t-delay)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/t-delay
([trig dur])
  
  Trigger delay 

  [trig 0.0, dur 0.1]

  trig - Input trigger signal. 
  dur  - Delay time in seconds. 

  Delays an input trigger by dur, ignoring other triggers in 
  the meantime 

  Categories: Triggers, Delays
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** send-trig
#+BEGIN_SRC clojure :results output
(doc send-trig)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/send-trig
([in id value])
  
  Send a /tr OSC message to Overtone 

  [in 0.0, id 0, value 0.0]

  in    - Input trigger signal 
  id    - An integer that will be passed with the 
          trigger message. This is useful if you 
          have more than one send-trig in a synth 
          design. Consider using trig-id to 
          genearate a unique id. 
  value - A ugen or float that will be polled at 
          the time of trigger, and its value 
          passed with the trigger message 

  On receiving a trigger sends a :trigger event with id and 
  value. This command is the mechanism that synths can use 
  to trigger events in clients.

  The trigger message sent back to the client is this:

  int - node ID

  int - trigger ID

  float - trigger value

  This is then presented as an event on the event-stream 
  which is a map containing the key :path with the string 
  "/tr" and the key :args containing a sequence of the 
  values in the above order. i.e.

  {:path /tr, :args (34 3 123.0)}

  See on-trigger, on-latest-trigger and on-sync-trigger for 
  registering handlers for trigger events. 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** send-reply
#+BEGIN_SRC clojure :results output
(doc send-reply)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/send-reply
([trig cmd-name values reply-id])
  
  Send information via OSC to Overtone 

  [trig 0.0, cmd-name /reply, values 0.0, reply-id -1]

  trig     - Input trigger signal 
  cmd-name - A string or symbol, as a message 
             name. 
  values   - Array of ugens, or valid ugen inputs 
  reply-id - Integer id (similar to that used by 
             send-trig) 

  Send an array of values from the server via an message. 
  The OSC message is formed with cmd-name as the path, 
  followed by two compulsary args: node-id (the id of the 
  node that sent the message) and reply-id (the value 
  specified in the params). These args are then followed by 
  the list of values specified in the params.

  For example, if the ugen is used as follows:

  (send-reply tr "/foobar" [1 2 3] 42)

  When the trig tr triggers, Overtone will receive an event 
  that looks like the following (where 32 represents the 
  node-id of the synth that sent the message):

  {:path "/foobar" :args (32 42 1 2 3)}

  You can register to respond to this event as follows:

  (on-event "/foobar" (fn [msg] (println msg)) 
  ::handle-foobar) 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** latch
#+BEGIN_SRC clojure :results output
(doc latch)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/latch
([in trig])
  
  Sample and hold 

  [in 0.0, trig 0.0]

  in   - Input signal. 
  trig - Trigger. Trigger can be any signal. A 
         trigger happens when the signal changes 
         from non-positive to positive. 

  Holds input signal value when triggered. 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** gate
#+BEGIN_SRC clojure :results output
(doc gate)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/gate
([in trig])
  
  Gate or hold 

  [in 0.0, trig 0.0]

  in   - Input signal. 
  trig - Trigger. Trigger can be any signal. A 
         trigger happens when the signal changes 
         from non-positive to positive. 

  Lets signal flow when trig is positive, otherwise holds 
  last input value 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** pulse-count
#+BEGIN_SRC clojure :results output
(doc pulse-count)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/pulse-count
([trig reset])
  
  Pulse counter 

  [trig 0.0, reset 0.0]

  trig  - Trigger. Trigger can be any signal. A 
          trigger happens when the signal changes 
          from non-positive to positive. 
  reset - Resets the counter to zero when 
          triggered. 

  Each input trigger increments a counter value that is 
  output. 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** set-reset-ff
#+BEGIN_SRC clojure :results output
(doc set-reset-ff)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/set-reset-ff
([trig reset])
  
  Set-reset flip flop 

  [trig 0.0, reset 0.0]

  trig  - Trigger. Trigger can be any signal. A 
          trigger happens when the signal changes 
          from non-positive to positive. 
  reset - Resets the counter to zero when 
          triggered. 

  When a trigger is received the output is set to 1.0 
  Subsequent triggers have no effect When a trigger is 
  received in the reset input, the output is set back to 
  0.0

  One use of this is to have some precipitating event cause 
  something to happen until you reset it. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** peak
#+BEGIN_SRC clojure :results output
(doc peak)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/peak
([trig reset])
  
  Track peak signal amplitude 

  [trig 0.0, reset 0.0]

  trig  - Trigger. Trigger can be any signal. A 
          trigger happens when the signal changes 
          from non-positive to positive. 
  reset - Resets the counter to zero when 
          triggered. 

  Outputs the peak amplitude of the signal so far, a trigger 
  resets to current value 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** running-min
#+BEGIN_SRC clojure :results output
(doc running-min)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/running-min
([in trig])
  
  Track minimum level 

  [in 0.0, trig 0.0]

  in   - Input signal. 
  trig - Trigger. Trigger can be any signal. A 
         trigger happens when the signal changes 
         from non-positive to positive. 

  Outputs the minimum value received at the input. When 
  triggered, the minimum output value is reset to the 
  current value. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** running-max
#+BEGIN_SRC clojure :results output
(doc running-max)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/running-max
([in trig])
  
  Track maximum level 

  [in 0.0, trig 0.0]

  in   - Input signal. 
  trig - Trigger. Trigger can be any signal. A 
         trigger happens when the signal changes 
         from non-positive to positive. 

  Outputs the maximum value received at the input. When 
  triggered, the maximum output value is reset to the 
  current value. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** stepper
#+BEGIN_SRC clojure :results output
(doc stepper)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/stepper
([trig reset min max step resetval])
  
  Pulse counter 

  [trig 0, reset 0, min 0, max 7, step 1, resetval 1]

  trig     - Trigger. Trigger can be any signal. A 
             trigger happens when the signal 
             changes from non-positive to 
             positive. 
  reset    - Resets the counter to resetval when 
             triggered. 
  min      - Minimum value of the counter. 
  max      - Maximum value of the counter. 
  step     - Step value each trigger. May be 
             negative. 
  resetval - Value to which the counter is reset 
             when it receives a reset trigger. 

  Triggers increment a counter which is output as a signal. 
  The counter loops around from max to min by step 
  increments 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** pulse-divider
#+BEGIN_SRC clojure :results output
(doc pulse-divider)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/pulse-divider
([trig div start-val])
  
  Pulse divider 

  [trig 0.0, div 2.0, start-val 0.0]

  trig      - Trigger. Trigger can be any signal. 
              A trigger happens when the signal 
              changes from non-positive to 
              positive. 
  div       - Number of pulses to divide by. 
  start-val - Starting value for the trigger 
              count. This lets you start somewhere 
              in the middle of a count, or if 
              startCount is negative it adds that 
              many counts to the first time the 
              output is triggers. 

  Outputs a trigger every div input triggers 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** toggle-ff
#+BEGIN_SRC clojure :results output
(doc toggle-ff)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/toggle-ff
([trig])
  
  Toggle flip flop 

  [trig 0.0]

  trig - Trigger input 

  Flip-flops between zero and one each trigger 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** zero-crossing
#+BEGIN_SRC clojure :results output
(doc zero-crossing)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/zero-crossing
([in])
  
  Zero crossing frequency follower 

  [in 0.0]

  in - Input signal 

  Outputs a frequency based upon the distance between 
  interceptions of the X axis. The X intercepts are 
  determined via linear interpolation so this gives better 
  than just integer wavelength resolution. This is a very 
  crude pitch follower, but can be useful in some 
  situations. 

  Categories: Analysis -> Pitch
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** timer
#+BEGIN_SRC clojure :results output
(doc timer)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/timer
([trig])
  
  Trigger timer 

  [trig 0.0]

  trig - Trigger input 

  Outputs time since last trigger 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** sweep
#+BEGIN_SRC clojure :results output
(doc sweep)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/sweep
([trig rate])
  
  Triggered linear ramp 

  [trig 0.0, rate 1.0]

  trig - Trigger input 
  rate - Rate in seconds 

  Outputs a linear increasing signal by rate/second when 
  trig input crosses from non-positive to positive 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** phasor
#+BEGIN_SRC clojure :results output
(doc phasor)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/phasor
([trig rate start end reset-pos])
  
  Resettable linear ramp between two levels 

  [trig 0.0, rate 1.0, start 0.0, end 1.0, reset-pos 0.0]

  trig      - When triggered, reset value to 
              reset-pos (default: 0, phasor 
              outputs start initially) 
  rate      - The amount of change per sample i.e 
              at a rate of 1 the value of each 
              sample will be 1 greater than the 
              preceding sample 
  start     - Starting point of the ramp 
  end       - End point of the ramp 
  reset-pos - The value to jump to upon receiving 
              a trigger 

  Phasor is a linear ramp between start and end values. When 
  its trigger input crosses from non-positive to positive, 
  Phasor's output will jump to its reset position. Upon 
  reaching the end of its ramp Phasor will wrap back to its 
  start. N.B. Since end is defined as the wrap point, its 
  value is never actually output. 

  Categories: Triggers, Buffer
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** peak-follower
#+BEGIN_SRC clojure :results output
(doc peak-follower)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/peak-follower
([in decay])
  
  Track peak signal amplitude 

  [in 0.0, decay 0.999]

  in    - Input signal. 
  decay - Decay factor. 

  Outputs the peak signal amplitude, falling with decay over 
  time until reaching signal level 

  Categories: Analysis -> Amplitude
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** pitch
#+BEGIN_SRC clojure :results output
(doc pitch)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/pitch
([in init-freq min-freq max-freq exec-freq max-bins-per-octave median amp-threshold peak-threshold down-sample clar])
  
  Autocorrelation pitch follower 

  [in :none, init-freq 440.0, min-freq 60.0, max-freq 4000.0, exec-freq 100.0, max-bins-per-octave 16, median 1, amp-threshold 0.01, peak-threshold 0.5, down-sample 1, clar 0]

  in                  - Input signal 
  init-freq           - Value of output pitch 
                        until first pitch 
                        detected. 
  min-freq            - Minimum frequency of 
                        execution. 
  max-freq            - Maximum frequency of 
                        execution. 
  exec-freq           - The target rate to 
                        periodically execute in 
                        cps. Clipped between 
                        min-freq and max-freq. 
  max-bins-per-octave - Number of lags for course 
                        search. A larger value 
                        will cause the coarse 
                        search to take longer, a 
                        smaller value will cause 
                        the subsequent fine search 
                        to take longer. 
  median              - Median filter value of 
                        length median on the 
                        output estimation. Helps 
                        eliminate outliers and 
                        jitter. Value of 1 means 
                        no filter. 
  amp-threshold       - Minum peak to peak 
                        amplitude of input signal 
                        before pitch estimation is 
                        performed. 
  peak-threshold      - Finds the next peak that 
                        is above peak-threshold 
                        times the amplitude of the 
                        peak at lag zero. A value 
                        of 0.5 does a pretty good 
                        job of eliminating 
                        overtones. 
  down-sample         - Down sample the input 
                        signal by an integer 
                        factor. Helps reduce CPU 
                        overthead. Also reduces 
                        pitch resolution. 
  clar                - Clarity measurement 
                        (purity of the pitched 
                        signal) if greater than 0. 

  This is a better pitch follower than zero-crossing, but 
  more costly of CPU. For most purposes the default settings 
  can be used and only in needs to be supplied. Pitch 
  returns two values (via an Array of OutputProxys), a freq 
  which is the pitch estimate and has-freq, which tells 
  whether a pitch was found. Some vowels are still 
  problematic, for instance a wide open mouth sound 
  somewhere between a low pitched short 'a' sound as in 
  'sat', and long 'i' sound as in 'fire', contains enough 
  overtone energy to confuse the algorithm. None of these 
  settings are time variable. 

  Categories: Analysis -> Pitch, MachineListening
  Rates: [ :kr ]
  Default rate: :kr
#+end_example

**** in-range
#+BEGIN_SRC clojure :results output
(doc in-range)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/in-range
([in lo hi])
  
  Tests if a signal is within a given range 

  [in 0.0, lo 0.0, hi 1.0]

  in - Input signal 
  lo - Low threshold 
  hi - High threshold 

  If in is >= lo and <= hi output 1.0, otherwise output 0.0. 
  Output is initially zero. 

  Categories: Maths
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** fold
#+BEGIN_SRC clojure :results output
(doc fold)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/fold
([in lo hi])
  
  Fold a signal outside given thresholds. 

  [in 0.0, lo 0.0, hi 1.0]

  in - Input signal 
  lo - Low threshold 
  hi - High threshold 

  Folds input wave to within the lo and hi thresholds. This 
  differs from the ugen fold2 in that it allows one to set 
  both low and high thresholds. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** clip
#+BEGIN_SRC clojure :results output
(doc clip)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/clip
([in lo hi])
  
  Clip a signal outside given thresholds. 

  [in 0.0, lo 0.0, hi 1.0]

  in - The signal to be clipped 
  lo - Low threshold of clipping. Must be less 
       then hi 
  hi - High threshold of clipping. Must be greater 
       then lo 

  Clip a signal outside given thresholds. This differs from 
  the ugen clip2 in that it allows one to set both low and 
  high thresholds. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** wrap
#+BEGIN_SRC clojure :results output
(doc wrap)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/wrap
([in lo hi])
  
  Wrap a signal outside given thresholds. 

  [in 0.0, lo 0.0, hi 1.0]

  in - Input signal 
  lo - Low threshold 
  hi - High threshold 

  Wraps input wave to the low and high thresholds. This 
  differs from the ugen wrap2 in that it allows one to set 
  both low and high thresholds. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** schmidt
#+BEGIN_SRC clojure :results output
(doc schmidt)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/schmidt
([in lo hi])
  
  Schmidt trigger 

  [in 0.0, lo 0.0, hi 1.0]

  in - Input signal 
  lo - Low threshold 
  hi - High threshold 

  Outout one when signal greater than high, and zero when 
  lower than low. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** in-rect
#+BEGIN_SRC clojure :results output
(doc in-rect)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/in-rect
([x y left top right bottom])
  
  Test if a point is within a given rectangle. 

  [x 0.0, y 0.0, left :none, top :none, right :none, bottom :none]

  x      - X component signal 
  y      - Y component signal 
  left   - - 
  top    - - 
  right  - - 
  bottom - - 

  Outputs one if the 2d coordinate of x,y input values falls 
  inside a rectangle, else zero 

  Categories: Maths
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** trapezoid
#+BEGIN_SRC clojure :results output
(doc trapezoid)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/trapezoid
([in a b c d])
  
  [in 0.0, a 0.2, b 0.4, c 0.6, d 0.8]

  in - The input signal 
  a  - - 
  b  - - 
  c  - - 
  d  - - 

  No documentation has been defined for this ugen. 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** most-changed
#+BEGIN_SRC clojure :results output
(doc most-changed)
#+END_SRC

#+RESULTS:

**** least-change
#+BEGIN_SRC clojure :results output
(doc least-change)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/least-change
([a b])
  
  Output least changed 

  [a 0.0, b 0.0]

  a - First input 
  b - Second input 

  Output whichever signal changed the least 

  Categories: 
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

**** last-value
#+BEGIN_SRC clojure :results output
(doc last-value)
#+END_SRC

#+RESULTS:
#+begin_example
-------------------------
overtone.live/last-value
([in diff])
  
  Output the last value before the input changed 

  [in 0.0, diff 0.01]

  in   - Input signal 
  diff - Difference threshold 

  Output the last value before the input changed by a 
  threshold of diff 

  Categories: Triggers
  Rates: [ :ar, :kr ]
  Default rate: :kr
#+end_example

*** AY Extra UGens
   ay

*** BBCut2 Extra UGens
   analyse-events2

*** Bat Extra UGens
   coyote trig-avg w-amp markov-synth frame-compare
   needle-rect skip-needle

*** Berlach Extra UGens
   lpf1 lpfvs6 lpf18 bl-buf-rd clipper4 clipper8
   clipper32 soft-clipper4 soft-clipper8
   soft-clip-amp4 soft-clip-amp8 os-wrap4 os-wrap8
   os-fold4 os-fold8 os-trunc4 os-trunc8 drive-noise
   peak-eq2 peak-eq4

*** Bhob Extra UGens
   henon2-dn henon2-dl henon2-dc henon-trig
   gbman2-dn gbman2-dl gbman2-dc gbman-trig
   standard2-dn standard2-dl standard2-dc
   standard-trig latoocarfian2-dn latoocarfian2-dl
   latoocarfian2-dc latoocarfian-trig lorenz2-dn
   lorenz2-dl lorenz2-dc lorenz-trig fhn2-dn fhn2-dl
   fhn2-dc fhn-trig pv-common-mag pv-common-mul
   pv-mag-minus pv-mag-gate pv-compander pv-mag-scale
   pv-morph pv-x-fade pv-soft-wipe pv-cutoff
   nested-allpass-n nested-allpass-l nested-allpass-c
   double-nested-allpass-n double-nested-allpass-l
   double-nested-allpass-c moog-ladder rlpfd
   streson nl-filt-n nl-filt-l nl-filt-c gauss-trig
   lf-brown-noise0 lf-brown-noise1 lf-brown-noise2
   t-brown-rand dbrown2 d-gauss t-gauss-rand
   t-beta-rand gendy4 gendy5 t-grains2 t-grains3

*** Blackrain Extra UGens
   amplitude-mod b-moog iir-filter svf

*** Distortion Extra UGens
   crossover-distortion smooth-decimator sine-shaper
   decimator disintegrator

*** Glitch Extra UGens
   glitch-rhpf glitch-hpf

*** Mda Extra UGens
   mda-piano

*** Membrane Extra UGens
   membrane-circle membrane-hexagon

*** RFW Extra UGens
   switch-delay average-output

*** SLU Extra UGens
   breakcore brusselator double-well double-well2
   double-well3 gravity-grid gravity-grid2

*** Stk Extra UGens
   stk-pluck stk-flute stk-bowed stk-mandolin
   stk-saxofony stk-shakers stk-banded-wg
   stk-voic-form stk-modal-bar stk-clarinet
   stk-blow-hole stk-moog stk-bee-three

*** VOSIM Extra UGens
   vosim
   Revision: 0.9.1.2, Date: 17th December, 2013
   Sam Aaron (sam.aaron gmail com)
   
