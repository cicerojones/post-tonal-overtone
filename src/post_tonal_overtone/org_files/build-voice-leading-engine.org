* setting-up
** steps
Once you have followed the below steps:

1.

#+BEGIN_SRC bash
cd ~/git-projects/post_tonal_overtone
lein repl
#+END_SRC

or ~cider-jack-in~ from within the post_tonal_overtone
directory within emacs

2. 

evaluate (C-c C-k using CIDER) the post_tonal_definitions.clj file 

You will hopefully see overtone loading up in your cider-repl.

** considerations
One advantage to starting a lein repl and then connecting cider to it
(with cider-connect) is that the terminal window (which becomes
dedicated to the overtone server once overtone is loaded) seems happy
to ~println~ things that cider-repl doesn't. 

[Don't know how to explain it, but please document it here]

Also, note that whether you start cider from within the /src directory
or the project directory will make a difference. Use the top-level
project directory, with the project.clj file.
* loading namespaces and using the relevant vars 
** repl vs. babel
Again, there's more than one way to do this. You can choose to have
babel-blocks do the loading, but in this case the repl will remain
ignorant of what has been taking place (this hasn't always seemed to
be the case when working with both. But for whatever I have done, it
always seems to be the case now).

Maybe name a session to help learn about how babel and cider will
interact around namespaces

#+BEGIN_SRC clojure :session vle
 (in-ns 'post_tonal_overtone.core)
#+END_SRC

#+RESULTS:
: #<Namespace post_tonal_overtone.core>

#+BEGIN_SRC clojure :session vle
*ns*
#+END_SRC

#+RESULTS:

#+BEGIN_SRC clojure
*ns*
#+END_SRC

#+RESULTS:
: #<Namespace post_tonal_overtone.core>
** what's available
Do you have access to certain data structures you are going to want to use?
#+BEGIN_SRC clojure :session vle
set-class/cmajtriads
#+END_SRC

#+RESULTS:
| 48 | 52 | 55 |
| 48 | 52 | 67 |
| 48 | 52 | 79 |
| 48 | 64 | 55 |
| 48 | 64 | 67 |
| 48 | 64 | 79 |
| 48 | 76 | 55 |
| 48 | 76 | 67 |
| 48 | 76 | 79 |
| 60 | 52 | 55 |
| 60 | 52 | 67 |
| 60 | 52 | 79 |
| 60 | 64 | 55 |
| 60 | 64 | 67 |
| 60 | 64 | 79 |
| 60 | 76 | 55 |
| 60 | 76 | 67 |
| 60 | 76 | 79 |
| 72 | 52 | 55 |
| 72 | 52 | 67 |
| 72 | 52 | 79 |
| 72 | 64 | 55 |
| 72 | 64 | 67 |
| 72 | 64 | 79 |
| 72 | 76 | 55 |
| 72 | 76 | 67 |
| 72 | 76 | 79 |

What about libraries of functions that you might want to use? What
kind of namespace-qualification are you going to have to use? Will you
need to ~use~ anything directly?

#+BEGIN_SRC clojure :session vle
(finite-prob/certainly 11)
#+END_SRC

#+RESULTS:
| 11 | 1 |


Note, during all this loading and checking, you may have received
mysterious errors. Have you checked your REPL lately?
* check basic sounds
** sin wave
#+BEGIN_SRC clojure :session vle
(demo (sin-osc))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: post_tonal_ov485/audition-synth 56>
** white noise

#+BEGIN_SRC clojure :session vle
(demo (white-noise))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: post_tonal_ov485/audition-synth 57>
** loaded samples
*** piano
#+BEGIN_SRC clojure :session vle
(sampled-piano 60)
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: overtone.inst.973/sampled-piano 58>

#+BEGIN_SRC clojure :session vle
(sampled-piano (note :A4))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: overtone.inst.973/sampled-piano 60>
* construct meaningful musical units
** all-important idiom for playing a chord
  #+BEGIN_SRC clojure :session vle
(defn play-piano-chord [a-chord]
        (doseq [note a-chord] (sampled-piano note)))

(play-piano-chord [60 64 67])
 #+END_SRC

  #+RESULTS:
  : #'post_tonal_overtone.core/play-piano-chordnil
** playing a melody involves time idioms
*** start simply with 'this' moment
#+BEGIN_SRC clojure :session vle
(at (now) (play-piano-chord (chord :C4 :major)))
#+END_SRC
*** using a metronome as timer for more sequenced items
**** copied standard example
  #+BEGIN_SRC clojure
;; We can play a chord progression on the synth
;; using times:
(defn chord-progression-time []
  (let [time (now)]
    (at time (play-piano-chord (chord :C4 :major)))
    (at (+ 2000 time) (play-piano-chord (chord :G3 :major)))
    (at (+ 3000 time) (play-piano-chord (chord :F3 :sus4)))
    (at (+ 4300 time) (play-piano-chord (chord :F3 :major)))
    (at (+ 5000 time) (play-piano-chord (chord :G3 :major)))))

(chord-progression-time)

  #+END_SRC

  #+RESULTS:
  : #'post_tonal_overtone.core/chord-progression-timenil
**** modified and cleaned up standard

Make the function take displacement from time start arguments
  #+BEGIN_SRC clojure
;; We can play a chord progression on the synth
;; using times:
(defn my-chord-progression-time [times]
  (let [time (now)
        [time1 time2 time3 time4 time5] times]
    (at time (play-piano-chord (chord :C4 :dom7)))
    (at (+ time1 time) (play-piano-chord (chord :G3 :major7)))
    (at (+ time2 time) (play-piano-chord (chord :F3 :sus4)))
    (at (+ time3 time) (play-piano-chord (chord :F3 :sus2)))
    (at (+ time4 time) (play-piano-chord (chord :G3 :minor7)))
    (at (+ time4 time) (play-piano-chord (chord :C3 :dim7)))))

(my-chord-progression-time '(2000 4000 6000 8000 1000))

  #+END_SRC

  #+RESULTS:
  : #'post_tonal_overtone.core/my-chord-progression-timenil

*** defined play doesn't have an example?
**** as defined
Changed to work with sampled-piano instead of saw;
also, midi->hz appears unnecessary for sampled-piano
#+BEGIN_SRC clojure :session vle
(defn play [time notes sep]
  (let [note (first notes)]
    (when note
      (at time (sampled-piano note)))
    (let [next-time (+ time sep)]
      (apply-at next-time play [next-time (rest notes) sep]))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/play

#+BEGIN_SRC clojure :session vle
(play (now) [60 64 71] 200)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 4364621, created-at: Wed 04:48:14s, initial-delay: 199, desc: "Overtone delayed fn", scheduled? true>
**** nice:
#+BEGIN_SRC clojure :session vle
(play (now) (flatten set-class/cmajtriads) 100)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 3730374, created-at: Wed 04:37:55s, initial-delay: 100, desc: "Overtone delayed fn", scheduled? true>
#+BEGIN_SRC clojure :session vle
(play (now) (flatten set-class/cmajtriads) (rand-nth [100 150 200]))
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 4401268, created-at: Wed 04:48:49s, initial-delay: 200, desc: "Overtone delayed fn", scheduled? true>

**** modified (failed?)

#+BEGIN_SRC clojure :session vle
(defn my-play [ notes sep]
  (let [note (first notes)
        time (now)]
    (when note
      (at time (sampled-piano note)))
    (let [next-time (+ time sep)]
      (apply-at next-time play [(rest notes) sep]))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/my-play

#+BEGIN_SRC clojure :session vle
(my-play [60 64 67] 2000)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 3320421, created-at: Wed 04:31:10s, initial-delay: 1998, desc: "Overtone delayed fn", scheduled? true>

**** modify to play with random intervals between notes (fails)
#+BEGIN_SRC clojure :session vle
(defn new-play [time notes seps]
  (let [note (first notes)
        sep (rand-nth seps)]
    (when note
      (at time (sampled-piano note))
      (println sep))
    (let [next-time (+ time (rand-nth seps))]
      (apply-at next-time play [next-time (rest notes) (rand-nth seps)]))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/new-play

#+BEGIN_SRC clojure :session vle
(new-play (now) (flatten set-class/cmajtriads) [100 300 700])
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 424, created-at: Wed 04:54:41s, initial-delay: 698, desc: "Overtone delayed fn", scheduled? true>

* generate large databases of musical events

** transpose triply nested list
#+BEGIN_SRC clojure :session vle
(defn tn-colls [tn coll-of-colls]
  (map (fn [coll] (map #(+ tn %) coll)) coll-of-colls))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/tn-colls

#+BEGIN_SRC clojure :session vle
(first set-class/nested-transposed-tetrachords)
#+END_SRC

#+RESULTS:
| 11 | 12 | 13 | 14 |
| 10 | 11 | 12 | 13 |
|  9 | 10 | 11 | 12 |
|  8 |  9 | 10 | 11 |
|  7 |  8 |  9 | 10 |
|  6 |  7 |  8 |  9 |
|  5 |  6 |  7 |  8 |
|  4 |  5 |  6 |  7 |
|  3 |  4 |  5 |  6 |
|  2 |  3 |  4 |  5 |
|  1 |  2 |  3 |  4 |

#+BEGIN_SRC clojure :session vle
(tn-colls 60 (first set-class/nested-transposed-tetrachords))
#+END_SRC

#+RESULTS:
| 71 | 72 | 73 | 74 |
| 70 | 71 | 72 | 73 |
| 69 | 70 | 71 | 72 |
| 68 | 69 | 70 | 71 |
| 67 | 68 | 69 | 70 |
| 66 | 67 | 68 | 69 |
| 65 | 66 | 67 | 68 |
| 64 | 65 | 66 | 67 |
| 63 | 64 | 65 | 66 |
| 62 | 63 | 64 | 65 |
| 61 | 62 | 63 | 64 |


#+BEGIN_SRC clojure :session vle
(subvec (vec set-class/nested-transposed-tetrachords) 0 2)
#+END_SRC

#+RESULTS:
| (11 12 13 14) | (10 11 12 13) | (9 10 11 12) | (8 9 10 11) | (7 8 9 10) | (6 7 8 9)  | (5 6 7 8) | (4 5 6 7) | (3 4 5 6) | (2 3 4 5) | (1 2 3 4) |
| (11 12 13 15) | (10 11 12 14) | (9 10 11 13) | (8 9 10 12) | (7 8 9 11) | (6 7 8 10) | (5 6 7 9) | (4 5 6 8) | (3 4 5 7) | (2 3 4 6) | (1 2 3 5) |

#+BEGIN_SRC clojure :session vle
((fn [cococ] (map #(tn-colls 60 %) cococ)) (subvec (vec set-class/nested-transposed-tetrachords) 0 3))
#+END_SRC

#+RESULTS:
| (71 72 73 74) | (70 71 72 73) | (69 70 71 72) | (68 69 70 71) | (67 68 69 70) | (66 67 68 69) | (65 66 67 68) | (64 65 66 67) | (63 64 65 66) | (62 63 64 65) | (61 62 63 64) |
| (71 72 73 75) | (70 71 72 74) | (69 70 71 73) | (68 69 70 72) | (67 68 69 71) | (66 67 68 70) | (65 66 67 69) | (64 65 66 68) | (63 64 65 67) | (62 63 64 66) | (61 62 63 65) |
| (71 72 74 75) | (70 71 73 74) | (69 70 72 73) | (68 69 71 72) | (67 68 70 71) | (66 67 69 70) | (65 66 68 69) | (64 65 67 68) | (63 64 66 67) | (62 63 65 66) | (61 62 64 65) |

