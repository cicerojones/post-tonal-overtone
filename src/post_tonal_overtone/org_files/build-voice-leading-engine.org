* setting-up
** steps
Once you have followed the below steps:

1.

#+BEGIN_SRC bash
cd ~/git-projects/post_tonal_overtone
lein repl
#+END_SRC

or ~cider-jack-in~ from within the post_tonal_overtone
directory within emacs

2. 

evaluate (C-c C-k using CIDER) the post_tonal_definitions.clj file 

You will hopefully see overtone loading up in your cider-repl.

** considerations
One advantage to starting a lein repl and then connecting cider to it
(with cider-connect) is that the terminal window (which becomes
dedicated to the overtone server once overtone is loaded) seems happy
to ~println~ things that cider-repl doesn't. 

[Don't know how to explain it, but please document it here]

Also, note that whether you start cider from within the /src directory
or the project directory will make a difference. Use the top-level
project directory, with the project.clj file.
* loading namespaces and using the relevant vars 
** repl vs. babel
Again, there's more than one way to do this. You can choose to have
babel-blocks do the loading, but in this case the repl will remain
ignorant of what has been taking place (this hasn't always seemed to
be the case when working with both. But for whatever I have done, it
always seems to be the case now).

Maybe name a session to help learn about how babel and cider will
interact around namespaces

#+BEGIN_SRC clojure :session vle
 (in-ns 'post_tonal_overtone.core)
#+END_SRC

#+RESULTS:
: #<Namespace post_tonal_overtone.core>

#+BEGIN_SRC clojure :session vle
*ns*
#+END_SRC

#+RESULTS:
: #<Namespace user>

#+BEGIN_SRC clojure
*ns*
#+END_SRC

#+RESULTS:
: #<Namespace post_tonal_overtone.core>
** what's available
Do you have access to certain data structures you are going to want to
use? If not, how do you load these things?

#+BEGIN_SRC clojure :session vle
set-class/cmajtriads
#+END_SRC

#+RESULTS:
| 48 | 52 | 55 |
| 48 | 52 | 67 |
| 48 | 52 | 79 |
| 48 | 64 | 55 |
| 48 | 64 | 67 |
| 48 | 64 | 79 |
| 48 | 76 | 55 |
| 48 | 76 | 67 |
| 48 | 76 | 79 |
| 60 | 52 | 55 |
| 60 | 52 | 67 |
| 60 | 52 | 79 |
| 60 | 64 | 55 |
| 60 | 64 | 67 |
| 60 | 64 | 79 |
| 60 | 76 | 55 |
| 60 | 76 | 67 |
| 60 | 76 | 79 |
| 72 | 52 | 55 |
| 72 | 52 | 67 |
| 72 | 52 | 79 |
| 72 | 64 | 55 |
| 72 | 64 | 67 |
| 72 | 64 | 79 |
| 72 | 76 | 55 |
| 72 | 76 | 67 |
| 72 | 76 | 79 |

What about libraries of functions that you might want to use? What
kind of namespace-qualification are you going to have to use? Will you
need to ~use~ anything directly?

#+BEGIN_SRC clojure :session vle
(finite-prob/certainly 11)
#+END_SRC

#+RESULTS:
| 11 | 1 |


Note, during all this loading and checking, you may have received
mysterious errors. Have you checked your REPL lately?
* check basic sounds and levels
** sin wave
*** basic
#+BEGIN_SRC clojure :session vle
(demo (sin-osc))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: post_tonal_ov485/audition-synth 56>
*** louder
#+BEGIN_SRC clojure :session vle
(demo  (out 0 (* 2 (sin-osc))))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: post_tonal_ov485/audition-synth 57>

** white noise

#+BEGIN_SRC clojure :session vle
(demo (white-noise))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: post_tonal_ov485/audition-synth 58>
** loaded samples
*** piano
#+BEGIN_SRC clojure :session vle
(sampled-piano 60)
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: overtone.inst.973/sampled-piano 59>

#+BEGIN_SRC clojure :session vle
(sampled-piano (note :A4))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: overtone.inst.973/sampled-piano 60>
* construct meaningful musical units
** all-important idiom for playing a chord
*** simple middle C triad
  #+BEGIN_SRC clojure :session vle
(defn play-piano-chord [a-chord]
        (doseq [note a-chord] (sampled-piano note)))

(play-piano-chord [60 64 67])
 #+END_SRC

  #+RESULTS:
  : #'post_tonal_overtone.core/play-piano-chordnil
*** randomly voice an A7 flat9 sharp13, play chord as side-effect
**** 4 note voicing
#+BEGIN_SRC clojure :session vle :results output
(defn mod12 [n] (mod n 12))

(let [midis (rand-chord :A2 :7+5-9 4 48)]
(do (println (map find-note-name midis))
    (println midis)
    (println (map mod12 midis))
    (play-piano-chord midis)
  ))
#+END_SRC

#+RESULTS:
: (:C#3 :F3 :Bb3 :Bb5)
: (49 53 58 82)
: (1 5 10 10)
*** remember meaningful phenomena
**** write 6 note voicing to disk

Define mod12 function 
#+BEGIN_SRC clojure :session vle :results output


(let [midis (rand-chord :A2 :7+5-9 6 48)]
  (play-piano-chord midis)
  (do (println (map find-note-name midis))
      (println midis)
      (println (map mod12 midis))
      (spit "src/post_tonal_overtone/data/saved-voicings.clj"
            (pr-str midis) :append true)
  ))
#+END_SRC

#+RESULTS:
: (:F3 :A3 :Bb3 :F4 :G5 :A5)
: (53 57 58 65 79 81)
: (5 9 10 5 7 9) nil
**** stateful versions

For example, this generated chord was particularly attractive.
Wouldn't it be nice to keep track of such things? And to revist and
try out sequences of these things? And then be able to vary their
order? And articulate them differently? Or subsume them within some
larger structure that begins to emerge after using a bunch of them?


i.e. how do you cycle between these two things?
#+BEGIN_SRC clojure
(play-piano-chord '(57 58 65 67 79 85))
;; (play-piano-chord '(53 57 58 65 79 81))
#+END_SRC

#+RESULTS:
: nil

You CAN do this, but whether you should is another matter. Or rather
an exact understanding of why you shouldn't and what you should do
instead is what ultimately is most important (it involves ~atoms~).
For now, however, let's see how this works.
#+BEGIN_SRC clojure :session vle :results output
(def stateful-chord (rand-chord :A2 :7+5-9 6 48))

(let [midis stateful-chord]
  (play-piano-chord midis)
  (do (println (map find-note-name midis))
  (println midis)
  (println (map mod12 midis)
    )))
#+END_SRC

#+RESULTS:
: (:A3 :Bb3 :F4 :G4 :G5 :C#6)
: (57 58 65 67 79 85)
: (9 10 5 7 7 1)

See it here again:
#+BEGIN_SRC clojure
stateful-chord
#+END_SRC

#+RESULTS:
| 57 | 58 | 65 | 67 | 79 | 85 |


If you particularly liked it, why not write it to disk?

#+BEGIN_SRC clojure
(spit "src/post_tonal_overtone/data/fave-voicings.clj"
      (pr-str stateful-chord) :append true)
#+END_SRC

#+RESULTS:
: nil

And C-c C-o to see that the file contains the last "stateful chord"
[[file:~/git-projects/post_tonal_overtone/src/post_tonal_overtone/data/fave-voicings.clj]]

Compare writing out to disk with java.io interop. (See 
[[file:~/git/org/clojure-books.org::*4.9.%20Reading%20and%20Writing%20Text%20Files][4.9. Reading and Writing Text Files]] in cookbook
 #+BEGIN_SRC clojure
(with-open [w (clojure.java.io/writer "stuff.txt")] (doseq [line some-large-seq-of-strings] (.write w line) (.newLine w)))
 #+END_SRC
**** developing an understanding of state
The real issue in the above comes when there are other "clients"
interacting with that "object." Or what about if you wanted to keep
that object available in clojure and not just on disk somehow, i.e.
how should it persist?

And what if you wanted to keep that thing around when using clojure
and wanted it to contain an ever expanding list of your favorite chords?
#+BEGIN_SRC clojure

#+END_SRC
** playing a melody involves time idioms
*** start simply with 'this' moment
#+BEGIN_SRC clojure :session vle
(at (now) (play-piano-chord (chord :C4 :major)))
#+END_SRC

#+RESULTS:
: nil

*** using a metronome as timer for more sequenced items
**** copied standard example
  #+BEGIN_SRC clojure
;; We can play a chord progression on the synth
;; using times:
(defn chord-progression-time []
  (let [time (now)]
    (at time (play-piano-chord (chord :C4 :major)))
    (at (+ 2000 time) (play-piano-chord (chord :G3 :major)))
    (at (+ 3000 time) (play-piano-chord (chord :F3 :sus4)))
    (at (+ 4300 time) (play-piano-chord (chord :F3 :major)))
    (at (+ 5000 time) (play-piano-chord (chord :G3 :major)))))

(chord-progression-time)

  #+END_SRC

  #+RESULTS:
  : #'post_tonal_overtone.core/chord-progression-timenil
**** cleaned up standard modified with other chord qualities

Make the function take displacement from time start arguments
  #+BEGIN_SRC clojure
;; you will now be able to assign play-times relative to the start
;; time, by passing in a list of "on-times" in milliseconds
(defn my-chord-progression-time [times]
  (let [time (now)
        [time1 time2 time3 time4 time5] times]
    (at time (play-piano-chord (chord :C4 :dom7)))
    (at (+ time1 time) (play-piano-chord (chord :G3 :major7)))
    (at (+ time2 time) (play-piano-chord (chord :F3 :sus4)))
    (at (+ time3 time) (play-piano-chord (chord :F3 :sus2)))
    (at (+ time4 time) (play-piano-chord (chord :G3 :minor7)))
    (at (+ time5 time) (play-piano-chord (chord :C3 :dim7)))))



  #+END_SRC

  #+RESULTS:
  : #'post_tonal_overtone.core/my-chord-progression-timenil

#+BEGIN_SRC clojure
(my-chord-progression-time '(2000 4000 6000 9000 130000))
#+END_SRC

#+RESULTS:
: nil

*** defined ~play~ doesn't have an example in the documentation
**** as defined, will play a sequence separated by a specified millisecond amount
Changed to work with sampled-piano instead of saw;
also, midi->hz appears unnecessary for sampled-piano
#+BEGIN_SRC clojure :session vle
(defn play [time notes sep]
  (let [note (first notes)]
    (when note
      (at time (sampled-piano note)))
    (let [next-time (+ time sep)]
      (apply-at next-time play [next-time (rest notes) sep]))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/play

#+BEGIN_SRC clojure :session vle
(play (now) [60 64 71] 200)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 1, created-at: Wed 04:48:12s, initial-delay: 198, desc: "Overtone delayed fn", scheduled? false>
**** nice: provide a large list as an argument and get out a long sequence of notes
#+BEGIN_SRC clojure :session vle
(play (now) (flatten set-class/cmajtriads) 100)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 223, created-at: Wed 04:48:57s, initial-delay: 99, desc: "Overtone delayed fn", scheduled? true>

#+RESULTS:
: #<ScheduledJob id: 4401268, created-at: Wed 04:48:49s, initial-delay: 200, desc: "Overtone delayed fn", scheduled? true>

**** modified (fails?)
Why do you need to pass in the time it starts? Any reason that
shouldn't be now? Wouldn't be more useful to be able to vary what
instrument you want to be playing?
#+BEGIN_SRC clojure :session vle
(defn my-play [inst notes sep]
  (let [note (first notes)
        time (now)]
    (when note
      (at time (inst note)))
    (let [next-time (+ time sep)]
      (apply-at next-time my-play [inst (rest notes) sep]))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/my-play

#+BEGIN_SRC clojure :session vle
(my-play sampled-piano [60 64 67] 2000)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 3858, created-at: Wed 04:52:54s, initial-delay: 1999, desc: "Overtone delayed fn", scheduled? true>

**** modify to play with random intervals between notes (fails to reapply)
#+BEGIN_SRC clojure :session vle
(defn new-play [time notes seps]
  (let [note (first notes)
        sep (rand-nth seps)]
    (when note
      (at time (sampled-piano note))
      (println sep))
    (let [next-time (+ time (rand-nth seps))]
      (apply-at next-time play [next-time (rest notes) (rand-nth seps)]))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/new-play

#+BEGIN_SRC clojure :session vle
(new-play (now) (flatten set-class/cmajtriads) [100 1000])
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 5259, created-at: Wed 04:53:56s, initial-delay: 99, desc: "Overtone delayed fn", scheduled? true>

* generate large databases of musical events
** transpose triply nested list
#+BEGIN_SRC clojure :session vle
(defn tn-colls [tn coll-of-colls]
  (map (fn [coll] (map #(+ tn %) coll)) coll-of-colls))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/tn-colls

#+BEGIN_SRC clojure :session vle
(first set-class/nested-transposed-tetrachords)
#+END_SRC

#+RESULTS:
| 11 | 12 | 13 | 14 |
| 10 | 11 | 12 | 13 |
|  9 | 10 | 11 | 12 |
|  8 |  9 | 10 | 11 |
|  7 |  8 |  9 | 10 |
|  6 |  7 |  8 |  9 |
|  5 |  6 |  7 |  8 |
|  4 |  5 |  6 |  7 |
|  3 |  4 |  5 |  6 |
|  2 |  3 |  4 |  5 |
|  1 |  2 |  3 |  4 |

#+BEGIN_SRC clojure :session vle
(tn-colls 60 (first set-class/nested-transposed-tetrachords))
#+END_SRC

#+RESULTS:
| 71 | 72 | 73 | 74 |
| 70 | 71 | 72 | 73 |
| 69 | 70 | 71 | 72 |
| 68 | 69 | 70 | 71 |
| 67 | 68 | 69 | 70 |
| 66 | 67 | 68 | 69 |
| 65 | 66 | 67 | 68 |
| 64 | 65 | 66 | 67 |
| 63 | 64 | 65 | 66 |
| 62 | 63 | 64 | 65 |
| 61 | 62 | 63 | 64 |


#+BEGIN_SRC clojure :session vle
(subvec (vec set-class/nested-transposed-tetrachords) 0 2)
#+END_SRC

#+RESULTS:
| (11 12 13 14) | (10 11 12 13) | (9 10 11 12) | (8 9 10 11) | (7 8 9 10) | (6 7 8 9)  | (5 6 7 8) | (4 5 6 7) | (3 4 5 6) | (2 3 4 5) | (1 2 3 4) |
| (11 12 13 15) | (10 11 12 14) | (9 10 11 13) | (8 9 10 12) | (7 8 9 11) | (6 7 8 10) | (5 6 7 9) | (4 5 6 8) | (3 4 5 7) | (2 3 4 6) | (1 2 3 5) |

#+BEGIN_SRC clojure :session vle
((fn [cococ] (map #(tn-colls 60 %) cococ)) (subvec (vec set-class/nested-transposed-tetrachords) 0 3))
#+END_SRC

#+RESULTS:
| (71 72 73 74) | (70 71 72 73) | (69 70 71 72) | (68 69 70 71) | (67 68 69 70) | (66 67 68 69) | (65 66 67 68) | (64 65 66 67) | (63 64 65 66) | (62 63 64 65) | (61 62 63 64) |
| (71 72 73 75) | (70 71 72 74) | (69 70 71 73) | (68 69 70 72) | (67 68 69 71) | (66 67 68 70) | (65 66 67 69) | (64 65 66 68) | (63 64 65 67) | (62 63 64 66) | (61 62 63 65) |
| (71 72 74 75) | (70 71 73 74) | (69 70 72 73) | (68 69 71 72) | (67 68 70 71) | (66 67 69 70) | (65 66 68 69) | (64 65 67 68) | (63 64 66 67) | (62 63 65 66) | (61 62 64 65) |
** start working with keyworded maps instead of unadorned lists
*** basic uses of hashes (sets)
#+BEGIN_SRC clojure :session vle
#{:a '(1 2 3) :b '(12 13 14)}
#+END_SRC

#+RESULTS:
: #{(12 13 14) (1 2 3) :b :a}

#+BEGIN_SRC clojure :session vle
(type #{:a '(1 2 3) :b '(12 13 14)})
#+END_SRC

#+RESULTS:
: clojure.lang.PersistentHashSet
*** hash-maps
**** simple
#+BEGIN_SRC clojure :session vle
(def h {:a '(1 2 3) :b '(12 13 14)})
(type h)
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/hclojure.lang.PersistentHashMap

#+BEGIN_SRC clojure :session vle
(get h :a)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |
**** pc-related
#+BEGIN_SRC clojure :session vle
(def chords {:0123-tn11 [11 12 13 14] :0123-tn10 [10 11 12 13] :0123-tn9 [9 10 11 12]})
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/chords

#+BEGIN_SRC clojure :session vle
(get chords :0123-tn10)
#+END_SRC  

#+RESULTS:
| 10 | 11 | 12 | 13 |
**** automate key assignment (arbitrary) for sets of chords
** note names vs. midi numbers--note vs. find-note-name
#+BEGIN_SRC clojure :session vle
(note :A4)
#+END_SRC

#+RESULTS:
: 69

#+BEGIN_SRC clojure :session vle
(find-note-name 21)
#+END_SRC

#+RESULTS:
: :A0

#+BEGIN_SRC clojure :session vle
(note-info "C#5")
#+END_SRC

#+RESULTS:
: '(:match "C#5"  :pitch-class :C#  :octave 5  :interval 1  :midi-note 73)

