* setting-up
** steps
Once you have followed the below steps:

1.

#+BEGIN_SRC bash
cd ~/git-projects/post_tonal_overtone
lein repl
#+END_SRC

or ~cider-jack-in~ from within the post_tonal_overtone
directory within emacs

2. 

evaluate (C-c C-k using CIDER) the post_tonal_definitions.clj file 

You will hopefully see overtone loading up in your cider-repl.

** considerations
One advantage to starting a lein repl and then connecting cider to it
(with cider-connect) is that the terminal window (which becomes
dedicated to the overtone server once overtone is loaded) seems happy
to ~println~ things that cider-repl doesn't. 

[Don't know how to explain it, but please document it here]

Also, note that whether you start cider from within the /src directory
or the project directory will make a difference. Use the top-level
project directory, with the project.clj file.
* loading namespaces and using the relevant vars 
** repl vs. babel
Again, there's more than one way to do this. You can choose to have
babel-blocks do the loading, but in this case the repl will remain
ignorant of what has been taking place (this hasn't always seemed to
be the case when working with both. But for whatever I have done, it
always seems to be the case now).

Maybe name a session to help learn about how babel and cider will
interact around namespaces

#+BEGIN_SRC clojure :session vle
 (in-ns 'post_tonal_overtone.core)
#+END_SRC

#+RESULTS:
: #<Namespace post_tonal_overtone.core>

#+BEGIN_SRC clojure :session vle
*ns*
#+END_SRC

#+RESULTS:
: #<Namespace post_tonal_overtone.core>

#+BEGIN_SRC clojure
*ns*
#+END_SRC

#+RESULTS:
: #<Namespace post_tonal_overtone.core>
** what's available
Do you have access to certain data structures you are going to want to
use? If not, how do you load these things?

#+BEGIN_SRC clojure :session vle
set-class/cmajtriads
#+END_SRC

#+RESULTS:
| 48 | 52 | 55 |
| 48 | 52 | 67 |
| 48 | 52 | 79 |
| 48 | 64 | 55 |
| 48 | 64 | 67 |
| 48 | 64 | 79 |
| 48 | 76 | 55 |
| 48 | 76 | 67 |
| 48 | 76 | 79 |
| 60 | 52 | 55 |
| 60 | 52 | 67 |
| 60 | 52 | 79 |
| 60 | 64 | 55 |
| 60 | 64 | 67 |
| 60 | 64 | 79 |
| 60 | 76 | 55 |
| 60 | 76 | 67 |
| 60 | 76 | 79 |
| 72 | 52 | 55 |
| 72 | 52 | 67 |
| 72 | 52 | 79 |
| 72 | 64 | 55 |
| 72 | 64 | 67 |
| 72 | 64 | 79 |
| 72 | 76 | 55 |
| 72 | 76 | 67 |
| 72 | 76 | 79 |

What about libraries of functions that you might want to use? What
kind of namespace-qualification are you going to have to use? Will you
need to ~use~ anything directly?

#+BEGIN_SRC clojure :session vle
(finite-prob/certainly 11)
#+END_SRC

#+RESULTS:
| 11 | 1 |


Note, during all this loading and checking, you may have received
mysterious errors. Have you checked your REPL lately?
* check basic sounds and levels
** sin wave
*** basic
#+BEGIN_SRC clojure :session vle
(demo (sin-osc))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: post_tonal_ov485/audition-synth 10911>
*** louder
#+BEGIN_SRC clojure :session vle
(demo  (out 0 (* 2 (sin-osc))))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: post_tonal_ov485/audition-synth 10910>

** white noise

#+BEGIN_SRC clojure :session vle
(demo (white-noise))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: post_tonal_ov485/audition-synth 10912>
** loaded samples
*** piano
#+BEGIN_SRC clojure :session vle
(sampled-piano 60)
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: overtone.inst.973/sampled-piano 7904>

#+BEGIN_SRC clojure :session vle
(sampled-piano (note :A4))
#+END_SRC

#+RESULTS:
: #<synth-node[loading]: overtone.inst.973/sampled-piano 7905>
* construct meaningful musical units
** all-important idiom for playing a chord
*** simple middle C triad
  #+BEGIN_SRC clojure :session vle
(defn play-piano-chord [a-chord]
        (doseq [note a-chord] (sampled-piano note)))

(play-piano-chord [60 64 67])
 #+END_SRC

  #+RESULTS:
  : #'post_tonal_overtone.core/play-piano-chordnil
*** randomly voice an A7 flat9 sharp13, play chord as side-effect
#+BEGIN_SRC clojure :session vle
(let [midis (rand-chord :A2 :7+5-9 5 48)]
  (play-piano-chord midis)
  midis)
#+END_SRC

#+RESULTS:
| 49 | 53 | 58 | 70 | 79 |

** playing a melody involves time idioms
*** start simply with 'this' moment
#+BEGIN_SRC clojure :session vle
(at (now) (play-piano-chord (chord :C4 :major)))
#+END_SRC

#+RESULTS:
: nil

*** using a metronome as timer for more sequenced items
**** copied standard example
  #+BEGIN_SRC clojure
;; We can play a chord progression on the synth
;; using times:
(defn chord-progression-time []
  (let [time (now)]
    (at time (play-piano-chord (chord :C4 :major)))
    (at (+ 2000 time) (play-piano-chord (chord :G3 :major)))
    (at (+ 3000 time) (play-piano-chord (chord :F3 :sus4)))
    (at (+ 4300 time) (play-piano-chord (chord :F3 :major)))
    (at (+ 5000 time) (play-piano-chord (chord :G3 :major)))))

(chord-progression-time)

  #+END_SRC

  #+RESULTS:
  : #'post_tonal_overtone.core/chord-progression-timenil
**** cleaned up standard modified with other chord qualities

Make the function take displacement from time start arguments
  #+BEGIN_SRC clojure
;; We can play a chord progression on the synth
;; using times:
(defn my-chord-progression-time [times]
  (let [time (now)
        [time1 time2 time3 time4 time5] times]
    (at time (play-piano-chord (chord :C4 :dom7)))
    (at (+ time1 time) (play-piano-chord (chord :G3 :major7)))
    (at (+ time2 time) (play-piano-chord (chord :F3 :sus4)))
    (at (+ time3 time) (play-piano-chord (chord :F3 :sus2)))
    (at (+ time4 time) (play-piano-chord (chord :G3 :minor7)))
    (at (+ time4 time) (play-piano-chord (chord :C3 :dim7)))))

(my-chord-progression-time '(2000 4000 6000 8000 1000))

  #+END_SRC

  #+RESULTS:
  : #'post_tonal_overtone.core/my-chord-progression-timenil

*** defined play doesn't have an example?
**** as defined
Changed to work with sampled-piano instead of saw;
also, midi->hz appears unnecessary for sampled-piano
#+BEGIN_SRC clojure :session vle
(defn play [time notes sep]
  (let [note (first notes)]
    (when note
      (at time (sampled-piano note)))
    (let [next-time (+ time sep)]
      (apply-at next-time play [next-time (rest notes) sep]))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/play

#+BEGIN_SRC clojure :session vle
(play (now) [60 64 71] 200)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 1, created-at: Thu 12:37:01s, initial-delay: 199, desc: "Overtone delayed fn", scheduled? true>
**** nice:
#+BEGIN_SRC clojure :session vle
(play (now) (flatten set-class/cmajtriads) 100)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 1, created-at: Tue 11:39:53s, initial-delay: 100, desc: "Overtone delayed fn", scheduled? true>

#+RESULTS:
: #<ScheduledJob id: 4401268, created-at: Wed 04:48:49s, initial-delay: 200, desc: "Overtone delayed fn", scheduled? true>

**** modified (failed?)

#+BEGIN_SRC clojure :session vle
(defn my-play [ notes sep]
  (let [note (first notes)
        time (now)]
    (when note
      (at time (sampled-piano note)))
    (let [next-time (+ time sep)]
      (apply-at next-time play [(rest notes) sep]))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/my-play

#+BEGIN_SRC clojure :session vle
(my-play [60 64 67] 2000)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 3320421, created-at: Wed 04:31:10s, initial-delay: 1998, desc: "Overtone delayed fn", scheduled? true>

**** modify to play with random intervals between notes (fails)
#+BEGIN_SRC clojure :session vle
(defn new-play [time notes seps]
  (let [note (first notes)
        sep (rand-nth seps)]
    (when note
      (at time (sampled-piano note))
      (println sep))
    (let [next-time (+ time (rand-nth seps))]
      (apply-at next-time play [next-time (rest notes) (rand-nth seps)]))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/new-play

#+BEGIN_SRC clojure :session vle
(new-play (now) (flatten set-class/cmajtriads) [100 300 700])
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 1, created-at: Wed 10:34:54s, initial-delay: 99, desc: "Overtone delayed fn", scheduled? true>

* generate large databases of musical events
** transpose triply nested list
#+BEGIN_SRC clojure :session vle
(defn tn-colls [tn coll-of-colls]
  (map (fn [coll] (map #(+ tn %) coll)) coll-of-colls))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/tn-colls

#+BEGIN_SRC clojure :session vle
(first set-class/nested-transposed-tetrachords)
#+END_SRC

#+RESULTS:
| 11 | 12 | 13 | 14 |
| 10 | 11 | 12 | 13 |
|  9 | 10 | 11 | 12 |
|  8 |  9 | 10 | 11 |
|  7 |  8 |  9 | 10 |
|  6 |  7 |  8 |  9 |
|  5 |  6 |  7 |  8 |
|  4 |  5 |  6 |  7 |
|  3 |  4 |  5 |  6 |
|  2 |  3 |  4 |  5 |
|  1 |  2 |  3 |  4 |

#+BEGIN_SRC clojure :session vle
(tn-colls 60 (first set-class/nested-transposed-tetrachords))
#+END_SRC

#+RESULTS:
| 71 | 72 | 73 | 74 |
| 70 | 71 | 72 | 73 |
| 69 | 70 | 71 | 72 |
| 68 | 69 | 70 | 71 |
| 67 | 68 | 69 | 70 |
| 66 | 67 | 68 | 69 |
| 65 | 66 | 67 | 68 |
| 64 | 65 | 66 | 67 |
| 63 | 64 | 65 | 66 |
| 62 | 63 | 64 | 65 |
| 61 | 62 | 63 | 64 |


#+BEGIN_SRC clojure :session vle
(subvec (vec set-class/nested-transposed-tetrachords) 0 2)
#+END_SRC

#+RESULTS:
| (11 12 13 14) | (10 11 12 13) | (9 10 11 12) | (8 9 10 11) | (7 8 9 10) | (6 7 8 9)  | (5 6 7 8) | (4 5 6 7) | (3 4 5 6) | (2 3 4 5) | (1 2 3 4) |
| (11 12 13 15) | (10 11 12 14) | (9 10 11 13) | (8 9 10 12) | (7 8 9 11) | (6 7 8 10) | (5 6 7 9) | (4 5 6 8) | (3 4 5 7) | (2 3 4 6) | (1 2 3 5) |

#+BEGIN_SRC clojure :session vle
((fn [cococ] (map #(tn-colls 60 %) cococ)) (subvec (vec set-class/nested-transposed-tetrachords) 0 3))
#+END_SRC

#+RESULTS:
| (71 72 73 74) | (70 71 72 73) | (69 70 71 72) | (68 69 70 71) | (67 68 69 70) | (66 67 68 69) | (65 66 67 68) | (64 65 66 67) | (63 64 65 66) | (62 63 64 65) | (61 62 63 64) |
| (71 72 73 75) | (70 71 72 74) | (69 70 71 73) | (68 69 70 72) | (67 68 69 71) | (66 67 68 70) | (65 66 67 69) | (64 65 66 68) | (63 64 65 67) | (62 63 64 66) | (61 62 63 65) |
| (71 72 74 75) | (70 71 73 74) | (69 70 72 73) | (68 69 71 72) | (67 68 70 71) | (66 67 69 70) | (65 66 68 69) | (64 65 67 68) | (63 64 66 67) | (62 63 65 66) | (61 62 64 65) |
** start working with keyworded maps instead of unadorned lists
*** basic uses of hashes (sets)
#+BEGIN_SRC clojure :session vle
#{:a '(1 2 3) :b '(12 13 14)}
#+END_SRC

#+RESULTS:
: #{(12 13 14) (1 2 3) :b :a}

#+BEGIN_SRC clojure :session vle
(type #{:a '(1 2 3) :b '(12 13 14)})
#+END_SRC

#+RESULTS:
: clojure.lang.PersistentHashSet
*** hash-maps
**** simple
#+BEGIN_SRC clojure :session vle
(def h {:a '(1 2 3) :b '(12 13 14)})
(type h)
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/hclojure.lang.PersistentHashMap

#+BEGIN_SRC clojure :session vle
(get h :a)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |
**** pc-related
#+BEGIN_SRC clojure :session vle
(def chords {:0123-tn11 [11 12 13 14] :0123-tn10 [10 11 12 13] :0123-tn9 [9 10 11 12]})
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/chords

#+BEGIN_SRC clojure :session vle
(get chords :0123-tn10)
#+END_SRC  

#+RESULTS:
| 10 | 11 | 12 | 13 |
**** automate key assignment (arbitrary) for sets of chords
** note names vs. midi numbers--note vs. find-note-name
#+BEGIN_SRC clojure :session vle
(note :A4)
#+END_SRC

#+RESULTS:
: 69

#+BEGIN_SRC clojure :session vle
(find-note-name 21)
#+END_SRC

#+RESULTS:
: :A0

#+BEGIN_SRC clojure :session vle
(note-info "C#5")
#+END_SRC

#+RESULTS:
: '(:match "C#5"  :pitch-class :C#  :octave 5  :interval 1  :midi-note 73)

