* starting-up--basics
** namespaces
*** simple
 You'll discover that it is good practice to define a namespace at the
 beginning of a file of related code.
 #+BEGIN_SRC clojure :session pt :tangle yes
(ns post-tonal-overtone.core)
 #+END_SRC

 #+RESULTS:
 : nil

 #+BEGIN_SRC clojure :session pt :tangle yes 
*ns*
 #+END_SRC

 #+RESULTS:
 : #<Namespace post-tonal-overtone.core>
*** eventually more complex, as you realize what your work will require
note, that this is for the Babel session for the "getting-started" program
#+BEGIN_SRC clojure :session getting-started
(ns post-tonal-overtone.core
  (:use overtone.live
        overtone.inst.sampled-piano
	org.clojure/math.combinatorics "0.1.1"
	clojure.repl))
#+END_SRC

#+RESULTS:

Note you can also just call this requirement in directly to whatever
namespace you happen to be in. Does this code cause nREPL to time out
for some reason?

 #+BEGIN_SRC clojure :session pt :tangle yes 
(use 'overtone.live)
 #+END_SRC

 #+RESULTS:
 : nil

** test sound with definst noise 
*** a definst template (noise, non-pitched)
 #+BEGIN_SRC clojure :session pt :tangle yes 
(definst noisey2 [attack 0.01 sustain 0.4 release 0.1 vol 0.4 length 3] 
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (pink-noise) ; also have (white-noise) and others...
     vol))

(noisey2)
 #+END_SRC

 #+RESULTS:
 : #<instrument: noisey2>#<synth-node[loading]: post-tonal-overtone.915/noisey2 164>

*** definst can involve an envelope for the scaling the ugen output--using lin
use of lin presents several default keyword args, when called for env-gen
#+BEGIN_SRC clojure 
(lin :attack :sustain :release :level :curve)
#+END_SRC
*** scale output using an env-gen
#+BEGIN_SRC clojure
(env-gen :envelope :gate :level-scale :level-bias :time-scale :action
#+END_SRC

*** define constant pink noise
  #+BEGIN_SRC clojure :session pt :tangle yes 
(definst noisey-sustained [vol 0.5] 
  (* (pink-noise) ; also have (white-noise) and others...
     vol))
  #+END_SRC

  #+RESULTS:
  : #<instrument: noisey-sustained>

  #+BEGIN_SRC clojure :session pt :tangle yes 
(noisey-sustained 1)
  #+END_SRC

  #+RESULTS:
  : #<synth-node[loading]: post-tonal-915/noisey-sustained 52>

  #+BEGIN_SRC clojure :session pt :tangle yes 
(stop)
  #+END_SRC

  #+RESULTS:
  : nil

* producing basic sounds
** play long white noise from above function (now called with parameters)
*** example--10 second version, long release?

experimenting with different parameter values reveals that the
mechanics of ~env-gen~ function are not entirely clear. An attack of
'1' and sustain of '0' would seem weirder than what sounds.
  #+BEGIN_SRC clojure :session pt :tangle yes 
(noisey2 :attack 1 :sustain 0 :release 0.5 :vol 0.3 :length 10)
  #+END_SRC

  #+RESULTS:
  : #<synth-node[loading]: post-tonal-overtone.915/noisey2 47>
** build some synth instruments for playing chords
 #+BEGIN_SRC clojure :session pt :tangle yes 
(definst sin3 [freq 880 attack 0.1 sustain 0.15 release 0.25 vol 0.4 length 5]
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (sin-osc freq)
     vol))

(sin3)
 #+END_SRC

 #+RESULTS:
 : #<instrument: sin3>#<synth-node[loading]: post-tonal-overtone.core/sin3 2527>

 #+BEGIN_SRC clojure :session pt :tangle yes 
(definst saw1 [freq 880 attack 0.1 sustain 0.15 release 0.25 vol 0.4 length 5]
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (saw freq)
     vol))
 #+END_SRC

 #+RESULTS:
 : #<instrument: saw1>

* develop post-tonal chords progressions with basic timing using 'now'
** start working with post tonal set classes
*** pt babel session
note, this will only work if...you are in the proper namespace. What
that really means is...
 #+BEGIN_SRC clojure :session pt :tangle yes 
(load "set-class-data")
 #+END_SRC

 #+RESULTS:
 : nil
vs.
#+BEGIN_SRC clojure :session 
"/Users/a/git-projects/post_tonal_overtone/src/post_tonal_overtone/set-class-data.clj"
#+END_SRC

** make a function to work with sets
 #+BEGIN_SRC clojure :session pt :tangle yes 
(defn voice-and-transpose-rand-set [set-type tn-level]
  (let [set (rand-nth set-type)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
        transposed-set (map #(+ tn-level %) voiced-set)
        set-voicing-group (list set voiced-set tn-level transposed-set)]
    (do
      (println set-voicing-group)
      (last set-voicing-group))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/voice-and-transpose-rand-set

** play chords using above sin wave instrument

*** doseq chord tones by giving sin3 midi-converted hz values
 #+BEGIN_SRC clojure :session pt :tangle yes 
(defn play-chord-sin2 [a-chord]
  (doseq [note a-chord] (sin3 (midi->hz note))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/play-chord-sin2

 #+BEGIN_SRC clojure :session pt :tangle yes 
(sin3 330)
 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC clojure :session pt :tangle yes 
(sin3 (midi->hz 96))
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-overtone.core/sin3 49>

 #+BEGIN_SRC clojure :session pt :tangle yes 
(play-chord-sin2 [64 76 81 86 91 96 101])
 #+END_SRC

 #+RESULTS:
 : nil

#+COMMENT why do you want to hear an extremely high pitched sin wave?
 #+BEGIN_SRC clojure :session pt :tangle yes 
(definst med96 [] (* 0.01 (sin-osc (midi->hz 96))))

(med96)
 #+END_SRC

 #+RESULTS:
 : #<instrument: med96>

** define a set of chord progressions to be played in time
*** use 'at' to schedule chord events, hard-coding offsets
 #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time1 []
  (let [time (now)]
    (at time          (play-chord-sin2 [68 81 46 50 88]))
    (at (+ 2000 time) (play-chord-sin2 [80 69 46 73 86]))
    (at (+ 4000 time) (play-chord-sin2 [68 59 48 85 64]))
    (at (+ 6000 time) (play-chord-sin2 [68 69 72 87 52]))
    (at (+ 8000 time) (play-chord-sin2 [89 55 45 60 62]))))

(chord-progression-time1)
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/chord-progression-time1

*** test out single event versions using 'at'
 #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time2 [inst]
  (let [time (now)]
    (at time (inst :attack 0.15 :sustain 0.2 :release 0.4 :vol 0.5 :length 10))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/chord-progression-time2

 #+BEGIN_SRC clojure :session pt :tangle yes 
(chord-progression-time2 sin3)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-overtone.core/sin3 92>

 #+BEGIN_SRC clojure :session pt :tangle yes 
(chord-progression-time2 saw1)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-overtone.core/saw1 93>

** test out a single chord player

*** this functionality has largely been superseded elsewhere
This provides sets of pitches to a sine instrument. The pitches are
chosen with the above machinery.
 #+BEGIN_SRC clojure :session pt :tangle yes 
(defn sine-tetra-diss []
  (doseq [notes (voice-and-transpose-rand-set ; voicing
                       *tetrachords* ; set-type
                       (rand-int 12))]
    (sin3 (midi->hz notes))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/sine-tetra-diss

 #+BEGIN_SRC clojure :session pt :tangle yes 
(sine-tetra-diss)
 #+END_SRC

 #+RESULTS:
 : nil

* begin creating scheduled events
** old experiments
*** establish a beat for scheduling events using metronome
  #+BEGIN_SRC clojure :session pt :tangle yes 
(def metro (metronome 60))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/metro

*** define and use a chord progression player--use 'apply-at'

 Note that this uses the sine-tetra-diss as a hard-coded 'instrument',
 or rather an instrumentalist.
  # the best one yet

  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time8 [nome]
  (let [beat (nome)]
    (at (nome beat) (sine-tetra-diss))
    (apply-at (nome (inc beat)) chord-progression-time8 nome [])))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/chord-progression-time8

  # to paraphrase "A Foggy Day", how long can this thing last?

  #+BEGIN_SRC clojure :session pt :tangle yes 
(chord-progression-time8 metro)
  #+END_SRC

  #+RESULTS:
  : #<ScheduledJob id: 1, created-at: Tue 05:51:04s, initial-delay: 1069, desc: "Overtone delayed fn", scheduled? true>

*** use sawtooth synth to play various chords
  #+BEGIN_SRC clojure :session pt :tangle yes 
(map saw1 (map #(midi->hz %) (last (voice-rand-set *pentachords*))))
  #+END_SRC

  #+RESULTS:
  : '(#<synth-node(loading): post-tonal-overtone.core/saw1 1126> #<synth-node(loading): post-tonal-overtone.core/saw1 1127> #<synth-node(loading): post-tonal-overtone.core/saw1 1128> #<synth-node(loading): post-tonal-overtone.core/saw1 1129> #<synth-node(loading): post-tonal-overtone.core/saw1 1130>)

*** chord progression number 3--sawtooth intensive

  a lot of repetition with this one
  # apply-at appears to cause problems when attempting to
  # call a functions that takes more than one argument

  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time3 [nome]
  (let [beat (nome)]
    (at (nome beat)
        (doseq [note (rand-nth [[60 61 62] [60 49 51 55 44]])]
          (saw1 (midi->hz note))))
    (apply-at (nome (inc beat)) chord-progression-time3 nome [])))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/chord-progression-time3

  #+BEGIN_SRC clojure :session pt :tangle yes 
(chord-progression-time3 metro)
  #+END_SRC

  #+RESULTS:
  : #<ScheduledJob id: 1, created-at: Tue 05:47:31s, initial-delay: 1872, desc: "Overtone delayed fn", scheduled? true>

*** chord progression 4
  # loops through random tetrachords without printing

  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time4 [nome]
  (let [beat (nome)]
    (at (nome beat)
        (doseq [notes (voice-and-transpose-rand-set ; voicing
                       *tetrachords* ; set-type
                       (rand-int 12))]
          (saw1 (midi->hz notes))))
    (apply-at (nome (inc beat)) chord-progression-time4 nome [])))
  #+END_SRC

  #+BEGIN_SRC clojure :session pt :tangle yes 
(chord-progression-time4 metro)
  #+END_SRC

*** chord progression 5
  # hack to get around the apply-at problem


  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time5 [nome]
  (let [beat (nome)]
    (at (nome beat)
        (doseq [note (rand-nth some-midis)]
          (saw1 (midi->hz note))))
    (apply-at (nome (inc beat)) chord-progression-time5 nome [])))
  #+END_SRC

*** use a set of pitched chords
  #+BEGIN_SRC clojure :session pt :tangle yes 
(def some-midis [[72 61 50 46] [60 49 51 55 44] [74 63 52 68] [42 79
70 61]])
  #+END_SRC

  #+BEGIN_SRC clojure :session pt :tangle yes 
(chord-progression-time5 metro)
  #+END_SRC

*** define a sawtooth random chord player
  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn saw-diss []
  (doseq [notes (voice-and-transpose-rand-set ; voicing
                       *tetrachords* ; set-type
                       (rand-int 12))]
    (saw1 (midi->hz notes))))
  #+END_SRC


  #+BEGIN_SRC clojure :session pt :tangle yes 
(saw-diss)
  #+END_SRC



  # also good, only prints first chord

*** chord progression 6
  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time6 [nome]
  (let [beat (nome)]
    (at (nome beat) (saw-diss))
    (apply-at (nome (inc beat)) chord-progression-time6 nome [])))
  #+END_SRC

  #+BEGIN_SRC clojure :session pt :tangle yes 
(chord-progression-time6 metro)
  #+END_SRC

*** chord progression 7
  # broken? because of apply-at problem?


  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time7 [nome sound]
  (let [beat (nome)]
    (at (nome beat) sound)
    (apply-at (nome (inc beat)) chord-progression-time7 nome sound
[])))
  #+END_SRC

  #+BEGIN_SRC clojure :session pt :tangle yes 
(chord-progression-time7 metro saw-diss)
  #+END_SRC

*** develop a looping function

 The use of "metro" hardcoded in causes problems?
  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn looper [sound]    
    (let [beat (metro)]
        (at (metro beat) (sound))
        (apply-at (metro (inc beat)) looper sound [])))
  #+END_SRC

  #+BEGIN_SRC clojure :session pt :tangle yes 
(looper (play-chord-sin2 '(80 69 46 73 86)))
  #+END_SRC

  #+RESULTS:

*** make a sawtooth chord player
  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn play-chord-saw1 [a-chord]
  (doseq [note a-chord] (saw1 (midi->hz note))))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/play-chord-saw1

*** define a preselected set of chords for progression 9
  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time9 []
  (let [time (now)]
    (at time          (play-chord-saw1 [68 81 46 50 88]))
    (at (+ 2000 time) (play-chord-saw1 [80 69 46 73 86]))
    (at (+ 4000 time) (play-chord-saw1 [68 59 48 85 64]))
    (at (+ 6000 time) (play-chord-saw1 [68 69 72 87 52]))
    (at (+ 8000 time) (play-chord-saw1 [89 55 45 60 62]))))
  #+END_SRC

  #+RESULTS:
  : #'post-tonal-overtone.core/chord-progression-time9


  #+BEGIN_SRC clojure :session pt :tangle yes             
(chord-progression-time9)
  #+END_SRC

  #+RESULTS:
  : nil

*** refactor chord progressions to use a player-fn
  #+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-progression-time10 [player-fn]
  (let [time (now)]
    (at (+ 0.00 time) (player-fn [68 81 46 50 88]))
    (at (+ 2000 time) (player-fn [80 69 46 73 86]))
    (at (+ 4000 time) (player-fn [68 59 48 85 64]))
    (at (+ 6000 time) (player-fn [68 69 72 87 52]))
    (at (+ 8000 time) (player-fn [89 55 45 60 62]))))
  #+END_SRC


  #+BEGIN_SRC clojure :session pt :tangle yes             
(chord-progression-time10 play-chord-saw1)
  #+END_SRC

** from the 'sequencing' wiki tutorial
*** use kick on each beat of a metronome
#+BEGIN_SRC clojure
(def kick (sample (freesound-path 2086)))

; setup a tempo for our metronome to use
(def forty-bpm (metronome 40))

; this function will play our sound at whatever tempo we've set our metronome to 
(defn looper [nome sound]    
    (let [beat (nome)]
        (at (nome beat) (sound))
        (apply-by (nome (inc beat)) looper nome sound [])))

; turn on the metronome
(looper forty-bpm kick)
#+END_SRC

#+RESULTS:
: #'post-tonal-overtone.core/kick#'post-tonal-overtone.core/one-twenty-bpm#'post-tonal-overtone.core/looper#<ScheduledJob id: 1, created-at: Mon 05:02:32s, initial-delay: 2694, desc: "Overtone delayed fn", scheduled? true>
#+BEGIN_SRC clojure
(stop)

#+END_SRC

#+RESULTS:
: nil

*** startup a metronome and check in with its beats as it runs
#+BEGIN_SRC clojure
; to get a feel for how the metronome works, try defining one at the REPL
(def nome (metronome 200))
#+END_SRC

#+BEGIN_SRC clojure
(nome)
#+END_SRC

#+RESULTS:
: 284

#+BEGIN_SRC clojure :session getting-started
; setup a tempo for our metronome to use
(def forty-bpm (metronome 40))

; this function will play our sound at whatever tempo we've set our metronome to 
(defn looper [nome sound]    
    (let [beat (nome)]
        (at (nome beat) (sound))
        (apply-by (nome (inc beat)) looper nome sound [])))

; turn on the metronome
(looper forty-bpm (play-quieter-piano-chord (map #(+ % 60) (repeatedly 6 (partial rand-int 12)))))
#+END_SRC

#+RESULTS:
: #'post-tonal-overtone.core/forty-bpm#'post-tonal-overtone.core/looper

#+BEGIN_SRC clojure
(defn foo [t freq]
  (at t (sin3 freq))
  (let [next-t (+ t 3000)
        next-f (+ freq 10)]
    (apply-by next-t #'foo [next-t next-f])))

(foo (now) 40)
#+END_SRC

#+RESULTS:
: #<ScheduledJob id: 1, created-at: Mon 05:35:33s, initial-delay: 0, desc: "Overtone delayed fn", scheduled? false>

this one, using sin3 as defined above, gradually steps up and up
through the frequencies from a given fundamental
#+BEGIN_SRC clojure
(defn foo [t freq]
  (at t (sin3 freq))
  (let [next-t (+ t 6000)
        next-f (+ freq 10)]
    (apply-by next-t #'foo [next-t next-f])))

(foo (now) 40)
#+END_SRC
* miscellaneous utilities

** 
#+BEGIN_SRC clojure :session pt :tangle yes 
(LET [TIME (NOW) ]
     (
      (AT (+ 0 TIME) (PLAYER-FN '(1 2 3)))
      (AT (+ 1000 TIME) (PLAYER-FN '(4 5 6)))))
#+END_SRC


# downcase


#+BEGIN_SRC clojure :session pt :tangle yes 
(defn chord-prog-time11 [player-fn]
  (let [TIME (NOW) ] 
       (AT (+ 0 TIME) (PLAYER-FN '(68 81 46 50 88)))
       (AT (+ 1000 TIME) (PLAYER-FN '(80 69 46 73 86)))
       (AT (+ 2000 TIME) (PLAYER-FN '(68 59 48 85 64)))
       (AT (+ 3000 TIME) (PLAYER-FN '(68 69 72 87 52)))
       (AT (+ 4000 TIME) (PLAYER-FN '(89 55 45 60 62)))))
#+END_SRC


#+BEGIN_SRC clojure :session pt :tangle yes 
(stop)
#+END_SRC

#+RESULTS:
: nil

