* starting-up
** namespaces
 You'll discover that it is good practice to define a namespace at the
 beginning of a file of related code.
 #+BEGIN_SRC clojure :session pt
(ns post-tonal-overtone.core)
 #+END_SRC

 #+RESULTS:
 : nil

 #+BEGIN_SRC clojure :session pt 
*ns*
 #+END_SRC

 #+RESULTS:
 : #<Namespace post-tonal-overtone.core>

** load your library
 #+BEGIN_SRC clojure :session pt 
(use 'overtone.live)
 #+END_SRC

** start defining overtone instruments

*** a definst template (noise, non-pitched)
 #+BEGIN_SRC clojure :session pt 
(definst noisey2 [attack 0.01 sustain 0.4 release 0.1 vol 0.4 length 3] 
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (pink-noise) ; also have (white-noise) and others...
     vol))
 #+END_SRC

 #+RESULTS:
 : #<instrument: noisey2>

** play white noise
 #+BEGIN_SRC clojure :session pt 
(noisey2)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-overtone.915/noisey2 357>

* developing sounds
** play long white noise
*** example
  #+BEGIN_SRC clojure :session pt 
(noisey2 :attack 0.15 :sustain 0.2 :release 0.3 :vol 0.3 :length 10)
  #+END_SRC

  #+RESULTS:
  : #<synth-node[loading]: post-tonal-overtone.915/noisey2 358>
*** development
The template and keywords that go with definst:

 #+BEGIN_SRC clojure :session pt 
(definst noisey2 [attack 0.01 sustain 0.4 release 0.1 vol 0.4 length 3] 
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (pink-noise) ; also have (white-noise) and others...
     vol))
 #+END_SRC

  #+BEGIN_SRC clojure :session pt 
(noisey2 :attack 0.15 
         :sustain 0.2
         :release 0.3
         :vol 0.3
         :length 10)
  #+END_SRC
*** arguments for an env-gen
 #+BEGIN_SRC clojure :session pt 
(definst noisey2 [attack 0.01 sustain 0.4 release 0.1 vol 0.4 length 3] 
  (* (env-gen (lin attack sustain release)
              1
              1
              0
              length
              FREE)
     (pink-noise) ; also have (white-noise) and others...
     vol))
 #+END_SRC

** define constant pink noise
 #+BEGIN_SRC clojure :session pt 
(definst noisey-sustained [vol 0.5] 
  (* (pink-noise) ; also have (white-noise) and others...
     vol))
 #+END_SRC

 #+RESULTS:
 : #<instrument: noisey-sustained>

 #+BEGIN_SRC clojure :session pt 
(noisey-sustained 1)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-915/noisey-sustained 363>

 #+BEGIN_SRC clojure :session pt 
(stop)
 #+END_SRC

 #+RESULTS:
 : nil

* developing post-tonal chords progressions
** start working with post tonal set classes
 #+BEGIN_SRC clojure :session pt 
(load "set-class-data")
 #+END_SRC

 #+RESULTS:
 : nil


 #+BEGIN_SRC clojure :session pt 
(rand-nth *tetrachords*)
 #+END_SRC 

 note that the following functions will print out, to both the
 cider-repl and the lein terminal repl, apparently

 For some reason, I had to define voice-rand-set right in the REPL,
 rather than with the .org babel version


 #+BEGIN_SRC clojure :session pt 
(defn voice-rand-set [set-type]
  (let [set (rand-nth set-type)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
        set-voicing-pair (list set voiced-set)]
    (do
      (println set-voicing-pair)
      set-voicing-pair)))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/voice-rand-set

 #+BEGIN_SRC clojure :session pt 
(voice-rand-set *tetrachords*)
 #+END_SRC

 #+RESULTS:
 |  0 |  1 |  3 |  7 |
 | 48 | 37 | 51 | 55 |

 What the fuck is going on here? It is quite nice actually, with the
 org-babel results, becuase of the way lists are aligned into the table!

** make a function to work with sets
 #+BEGIN_SRC clojure :session pt 
(defn voice-and-transpose-rand-set [set-type tn-level]
  (let [set (rand-nth set-type)
        voiced-set (map #(+ (rand-nth [36 48 60 72]) %) set)
        transposed-set (map #(+ tn-level %) voiced-set)
        set-voicing-group (list set voiced-set tn-level transposed-set)]
    (do
      (println set-voicing-group)
      (last set-voicing-group))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/voice-and-transpose-rand-set

** build some synth instruments for playing chords
 #+BEGIN_SRC clojure :session pt 
(definst sin3 [freq 880 attack 0.1 sustain 0.15 release 0.25 vol 0.4 length 5]
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (sin-osc freq)
     vol))
 #+END_SRC

 #+RESULTS:
 : #<instrument: sin3>

 #+BEGIN_SRC clojure :session pt 
(definst saw1 [freq 880 attack 0.1 sustain 0.15 release 0.25 vol 0.4 length 5]
  (* (env-gen (lin attack sustain release) 1 1 0 length FREE)
     (saw freq)
     vol))
 #+END_SRC

 #+RESULTS:
 : #<instrument: saw1>

** play chords using sin wave instrument
 #+BEGIN_SRC clojure :session pt 
(defn play-chord-sin2 [a-chord]
  (doseq [note a-chord] (sin3 (midi->hz note))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/play-chord-sin2

 #+BEGIN_SRC clojure :session pt 
(sin3 330)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-overtone.core/sin3 48>

 #+BEGIN_SRC clojure :session pt 
(sin3 (midi->hz 96))
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-overtone.core/sin3 49>

 #+BEGIN_SRC clojure :session pt 
(play-chord-sin2 [64 76 81 86 91 96 101])
 #+END_SRC

 #+RESULTS:
 : nil

 #+BEGIN_SRC clojure :session pt 
(definst med96 [] (* 0.01 (sin-osc (midi->hz 96))))
 #+END_SRC

 #+RESULTS:
 : #<instrument: med96>

 #+BEGIN_SRC clojure :session pt 
(med96)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-overtone.core/med96 68>

** define a set of chord progressions to be played in time
 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time1 []
  (let [time (now)]
    (at time          (play-chord-sin2 [68 81 46 50 88]))
    (at (+ 2000 time) (play-chord-sin2 [80 69 46 73 86]))
    (at (+ 4000 time) (play-chord-sin2 [68 59 48 85 64]))
    (at (+ 6000 time) (play-chord-sin2 [68 69 72 87 52]))
    (at (+ 8000 time) (play-chord-sin2 [89 55 45 60 62]))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/chord-progression-time1

 #+BEGIN_SRC clojure :session pt             
(chord-progression-time1)
 #+END_SRC

 #+RESULTS:
 : nil

 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time2 [inst]
  (let [time (now)]
    (at time (inst :attack 0.15 :sustain 0.2 :release 0.4 :vol
0.5 :length 10))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/chord-progression-time2

 #+BEGIN_SRC clojure :session pt 
(chord-progression-time2 sin3)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-overtone.core/sin3 92>

 #+BEGIN_SRC clojure :session pt 
(chord-progression-time2 saw1)
 #+END_SRC

 #+RESULTS:
 : #<synth-node[loading]: post-tonal-overtone.core/saw1 93>

** test out a single chord player
 #+BEGIN_SRC clojure :session pt 
(defn sine-tetra-diss []
  (doseq [notes (voice-and-transpose-rand-set ; voicing
                       *tetrachords* ; set-type
                       (rand-int 12))]
    (sin3 (midi->hz notes))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/sine-tetra-diss

 #+BEGIN_SRC clojure :session pt 
(sine-tetra-diss)
 #+END_SRC

 #+RESULTS:
 : nil

* begin creating scheduled events
** establish a beat for scheduling events
 #+BEGIN_SRC clojure :session pt 
(def metro (metronome 60))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/metro

** define and use a chord progression player
 # the best one yet

 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time8 [nome]
  (let [beat (nome)]
    (at (nome beat) (sine-tetra-diss))
    (apply-at (nome (inc beat)) chord-progression-time8 nome [])))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/chord-progression-time8

 # to paraphrase "A Foggy Day", how long can this thing last?

 #+BEGIN_SRC clojure :session pt 
(chord-progression-time8 metro)
 #+END_SRC

 #+RESULTS:
 : #<ScheduledJob id: 1, created-at: Tue 05:51:04s, initial-delay: 1069, desc: "Overtone delayed fn", scheduled? true>

** use sawtooth synth to play various chords
 #+BEGIN_SRC clojure :session pt 
(map saw1 (map #(midi->hz %) (last (voice-rand-set *pentachords*))))
 #+END_SRC

 #+RESULTS:
 : '(#<synth-node(loading): post-tonal-overtone.core/saw1 1126> #<synth-node(loading): post-tonal-overtone.core/saw1 1127> #<synth-node(loading): post-tonal-overtone.core/saw1 1128> #<synth-node(loading): post-tonal-overtone.core/saw1 1129> #<synth-node(loading): post-tonal-overtone.core/saw1 1130>)

** chord progression number 3--sawtooth intensive

 a lot of repetition with this one
 # apply-at appears to cause problems when attempting to
 # call a functions that takes more than one argument

 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time3 [nome]
  (let [beat (nome)]
    (at (nome beat)
        (doseq [note (rand-nth [[60 61 62] [60 49 51 55 44]])]
          (saw1 (midi->hz note))))
    (apply-at (nome (inc beat)) chord-progression-time3 nome [])))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/chord-progression-time3

 #+BEGIN_SRC clojure :session pt 
(chord-progression-time3 metro)
 #+END_SRC

 #+RESULTS:
 : #<ScheduledJob id: 1, created-at: Tue 05:47:31s, initial-delay: 1872, desc: "Overtone delayed fn", scheduled? true>

** chord progression 4
 # loops through random tetrachords without printing

 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time4 [nome]
  (let [beat (nome)]
    (at (nome beat)
        (doseq [notes (voice-and-transpose-rand-set ; voicing
                       *tetrachords* ; set-type
                       (rand-int 12))]
          (saw1 (midi->hz notes))))
    (apply-at (nome (inc beat)) chord-progression-time4 nome [])))
 #+END_SRC

 #+BEGIN_SRC clojure :session pt 
(chord-progression-time4 metro)
 #+END_SRC

** chord progression 5
 # hack to get around the apply-at problem


 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time5 [nome]
  (let [beat (nome)]
    (at (nome beat)
        (doseq [note (rand-nth some-midis)]
          (saw1 (midi->hz note))))
    (apply-at (nome (inc beat)) chord-progression-time5 nome [])))
 #+END_SRC

** use a set of pitched chords
 #+BEGIN_SRC clojure :session pt 
(def some-midis [[72 61 50 46] [60 49 51 55 44] [74 63 52 68] [42 79
70 61]])
 #+END_SRC

 #+BEGIN_SRC clojure :session pt 
(chord-progression-time5 metro)
 #+END_SRC

** define a sawtooth random chord player
 #+BEGIN_SRC clojure :session pt 
(defn saw-diss []
  (doseq [notes (voice-and-transpose-rand-set ; voicing
                       *tetrachords* ; set-type
                       (rand-int 12))]
    (saw1 (midi->hz notes))))
 #+END_SRC


 #+BEGIN_SRC clojure :session pt 
(saw-diss)
 #+END_SRC



 # also good, only prints first chord

** chord progression 6
 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time6 [nome]
  (let [beat (nome)]
    (at (nome beat) (saw-diss))
    (apply-at (nome (inc beat)) chord-progression-time6 nome [])))
 #+END_SRC

 #+BEGIN_SRC clojure :session pt 
(chord-progression-time6 metro)
 #+END_SRC


** chord progression 7
 # broken? because of apply-at problem?


 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time7 [nome sound]
  (let [beat (nome)]
    (at (nome beat) sound)
    (apply-at (nome (inc beat)) chord-progression-time7 nome sound
[])))
 #+END_SRC

 #+BEGIN_SRC clojure :session pt 
(chord-progression-time7 metro saw-diss)
 #+END_SRC

** develop a looping function
 #+BEGIN_SRC clojure :session pt 
(defn looper [sound]    
    (let [beat (metro)]
        (at (metro beat) (sound))
        (apply-at (metro (inc beat)) looper sound [])))
 #+END_SRC

 #+BEGIN_SRC clojure :session pt 
(looper (play-chord-sin2 '(80 69 46 73 86)))
 #+END_SRC

** make a sawtooth chord player
 #+BEGIN_SRC clojure :session pt 
(defn play-chord-saw1 [a-chord]
  (doseq [note a-chord] (saw1 (midi->hz note))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/play-chord-saw1

** define a preselected set of chords for progression 9
 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time9 []
  (let [time (now)]
    (at time          (play-chord-saw1 [68 81 46 50 88]))
    (at (+ 2000 time) (play-chord-saw1 [80 69 46 73 86]))
    (at (+ 4000 time) (play-chord-saw1 [68 59 48 85 64]))
    (at (+ 6000 time) (play-chord-saw1 [68 69 72 87 52]))
    (at (+ 8000 time) (play-chord-saw1 [89 55 45 60 62]))))
 #+END_SRC

 #+RESULTS:
 : #'post-tonal-overtone.core/chord-progression-time9


 #+BEGIN_SRC clojure :session pt             
(chord-progression-time9)
 #+END_SRC

 #+RESULTS:
 : nil

** refactor chord progressions to use any type of instrument player
 #+BEGIN_SRC clojure :session pt 
(defn chord-progression-time10 [player-fn]
  (let [time (now)]
    (at (+ 0.00 time) (player-fn [68 81 46 50 88]))
    (at (+ 2000 time) (player-fn [80 69 46 73 86]))
    (at (+ 4000 time) (player-fn [68 59 48 85 64]))
    (at (+ 6000 time) (player-fn [68 69 72 87 52]))
    (at (+ 8000 time) (player-fn [89 55 45 60 62]))))
 #+END_SRC


 #+BEGIN_SRC clojure :session pt             
(chord-progression-time10 play-chord-saw1)
 #+END_SRC

* miscellaneous utilities
#+BEGIN_SRC clojure :session pt 
(LET [TIME (NOW) ]
     (
      (AT (+ 0 TIME) (PLAYER-FN '(1 2 3)))
      (AT (+ 1000 TIME) (PLAYER-FN '(4 5 6)))))
#+END_SRC


# downcase


#+BEGIN_SRC clojure :session pt 
(defn chord-prog-time11 [player-fn]
  (let [TIME (NOW) ] 
       (AT (+ 0 TIME) (PLAYER-FN '(68 81 46 50 88)))
       (AT (+ 1000 TIME) (PLAYER-FN '(80 69 46 73 86)))
       (AT (+ 2000 TIME) (PLAYER-FN '(68 59 48 85 64)))
       (AT (+ 3000 TIME) (PLAYER-FN '(68 69 72 87 52)))
       (AT (+ 4000 TIME) (PLAYER-FN '(89 55 45 60 62)))))
#+END_SRC


#+BEGIN_SRC clojure :session pt 
(stop)
#+END_SRC

#+RESULTS:
: nil

